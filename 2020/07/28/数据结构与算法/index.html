<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="Edgecloudsim Java Algorithm">
  <meta name="author" content="">
  <meta name="keywords" content="">
  <title>数据结构与算法 - 九流人</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 60vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>九流人</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bg/astronaut.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
                数据结构与算法
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-07-28 15:53">
      2020年7月28日 下午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      11.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      128
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：2020年8月17日 凌晨
                
              </p>
            
            <article class="markdown-body">
              <p>文章对常用的数据结构做归纳总结。</p>
<a id="more"></a>



<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><ul>
<li>时间和空间的转换，两者之间平衡的意识；</li>
<li>掌握常用的基础数据结构，包括内部实现、常用操作的时间和空间复杂度；</li>
<li>针对不同的场景，能够选择较为合适的数据结构；</li>
</ul>
<h1 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a>常用数据结构</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li><p>用一组连续的内存空间，存储一组具有相同类型的数据；</p>
</li>
<li><p>支持随机访问，但插入、删除操作比较低效；</p>
</li>
</ul>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="随机访问"><a href="#随机访问" class="headerlink" title="随机访问"></a>随机访问</h4><p>一维寻址公式：a[k]_address = base_address + k * type_size；</p>
<p>二维寻址公式，对于 m*n 的数组：a[i][j]_address = base_address + (i*n+j) * type_size；</p>
<p>所以，根据下标随机访问的时间复杂度为 O(1)；</p>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><ul>
<li>开头插入：最坏时间复杂度是O(n)；</li>
<li>平均情况时间复杂度： (1+2+…n)/n = O(n)；</li>
<li>在中间第 k 位插入：时间复杂度可以达到是O(1)；<ul>
<li>如果数组中的数据是有序的，在某个位置插入一个新的元素时，就必须搬移 k 之后的数据，但是，</li>
<li>如果数组中存储的数据没有任何规律，数组只是被当作一个存储数据的集合。这种情况下，如果要将某个数据插入到第 k 个位置，为了避免大规模的数据搬移，还有一个简单的办法，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置；</li>
</ul>
</li>
<li>在末尾插入：时间复杂度是O(1)；</li>
</ul>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><ul>
<li>开头删除：最坏时间复杂度O(n)；</li>
<li>平均情况时间复杂度O(n)；</li>
<li>在中间第 k 位删除：每次删除操作只记录数据已被删除。当没有更多空间时，才触发执行真正的删除操作；<ul>
<li>在某些特殊场景下，并不一定要求数组中数据的连续性。如果将多次删除操作集中在一起执行，删除的效率会有所提高；</li>
<li>JVM 的标记清除垃圾回收算法的核心思想应用了这个思想；</li>
</ul>
</li>
<li>在末尾删除：时间复杂度O(1)；</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li><p>平时的业务开发，使用编程语言提供的容器类比较方便，有助于提高开发效率；</p>
</li>
<li><p>底层的开发适合直接使用数组，更加高效；</p>
</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul>
<li>通过指针将一组零散的内存块串联起来使用；</li>
<li>插入、删除数据快；</li>
</ul>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>根据指针一个节点一个节点依次遍历，直到找到目标节点。</p>
<h4 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h4><p>只要考虑相邻节点的指针改变，时间复杂度是O(1)。</p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>一种特殊的单链表，尾节点指针指向链表的头节点。</p>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><ul>
<li><p>支持两个方向，后继指针 next 指向后面的节点，前驱指针 pre 指向前面的节点；</p>
</li>
<li><p>查找、插入、删除的效率都比单链表高；</p>
</li>
</ul>
<h4 id="删除“值等于给定值”的节点"><a href="#删除“值等于给定值”的节点" class="headerlink" title="删除“值等于给定值”的节点"></a>删除“值等于给定值”的节点</h4><ul>
<li><p>从头节点开始遍历，依次对比，直到找到值等于给定值的节点，通过指针操作将其删除；</p>
</li>
<li><p>时间复杂度为O(n)；</p>
</li>
</ul>
<h4 id="删除给定指针指向的节点"><a href="#删除给定指针指向的节点" class="headerlink" title="删除给定指针指向的节点"></a>删除给定指针指向的节点</h4><ul>
<li>对于单链表，已经知道了要删除的节点，但是要删除某个结点 q 需要知道其前驱结点，而单链表不可以直接获取前驱结点，所以为了找到前驱结点，要从头结点开始遍历链表，直到 p-&gt;next=q，说明 p 是 q 的前驱结点。时间复杂度为O(n)；</li>
<li>对于双向链表，因为节点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，O(1) 的时间复杂度就可以完成操作；</li>
</ul>
<h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><ul>
<li><p>链表适合插入、删除操作比较频繁的场景；</p>
</li>
<li><p>双向链表比单链表的插入、删除等操作简单、高效，适用在很多场景；</p>
</li>
<li><p>循环链表适合要处理的数据具有环形结构的特点，比如约瑟夫环问题；</p>
</li>
</ul>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>一种操作受限的线性表，只允许在一端插入和删除数据，特点是FILO。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li><p>只需要一个栈顶指针；</p>
</li>
<li><p>用数组实现的栈叫顺序栈，用链表实现的栈叫链式栈；</p>
</li>
</ul>
<h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 基于数组实现的顺序栈</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayStack</span> </span>&#123;
  <span class="hljs-keyword">private</span> String[] items;  <span class="hljs-comment">// 数组</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;       <span class="hljs-comment">// 栈中元素个数</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;           <span class="hljs-comment">// 栈的大小</span>

  <span class="hljs-comment">// 初始化数组，申请一个大小为n的数组空间</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayStack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
    <span class="hljs-keyword">this</span>.items = <span class="hljs-keyword">new</span> String[n];
    <span class="hljs-keyword">this</span>.n = n;
    <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;
  &#125;

  <span class="hljs-comment">// 入栈操作</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">push</span><span class="hljs-params">(String item)</span> </span>&#123;
    <span class="hljs-comment">// 数组空间不够了，直接返回false，入栈失败。</span>
    <span class="hljs-keyword">if</span> (count == n) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    <span class="hljs-comment">// 将item放到下标为count的位置，并且count加一</span>
    items[count] = item;
    ++count;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
  &#125;
  
  <span class="hljs-comment">// 出栈操作</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">// 栈为空，则直接返回null</span>
    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    <span class="hljs-comment">// 返回下标为count-1的数组元素，并且栈中元素个数count减一</span>
    String tmp = items[count-<span class="hljs-number">1</span>];
    --count;
    <span class="hljs-keyword">return</span> tmp;
  &#125;
&#125;</code></pre>



<h4 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 基于链表实现的链式栈</span>
<span class="hljs-comment"> * 注意：通俗的理解，节点的next指针是指向“底下”的节点，是指向下面的节点</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackBasedOnLinkedList</span> </span>&#123;
  <span class="hljs-keyword">private</span> Node top = <span class="hljs-keyword">null</span>;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;
    Node newNode = <span class="hljs-keyword">new</span> Node(value, <span class="hljs-keyword">null</span>);
    <span class="hljs-comment">// 判断是否栈空</span>
    <span class="hljs-keyword">if</span> (top == <span class="hljs-keyword">null</span>) &#123;
      top = newNode;
    &#125; <span class="hljs-keyword">else</span> &#123;
      newNode.next = top;
      top = newNode;
    &#125;
  &#125;

  <span class="hljs-comment">/**</span>
<span class="hljs-comment">   * 这里用-1表示栈中没有数据。</span>
<span class="hljs-comment">   */</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">if</span> (top == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> value = top.data;
    top = top.next;
    <span class="hljs-keyword">return</span> value;
  &#125;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printAll</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">// 用一个临时变量</span>
    Node p = top;
    <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;
      System.out.print(p.data + <span class="hljs-string">" "</span>);
      p = p.next;
    &#125;
    System.out.println();
  &#125;

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data;
    <span class="hljs-keyword">private</span> Node next;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data, Node next)</span> </span>&#123;
      <span class="hljs-keyword">this</span>.data = data;
      <span class="hljs-keyword">this</span>.next = next;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-keyword">return</span> data;
    &#125;
  &#125;
&#125;</code></pre>



<h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><ul>
<li>不管是顺序栈还是链式栈，存储数据只需要一个大小为 n 的数组。在<strong>入栈</strong>和<strong>出栈</strong>过程中，只需要一两个临时变量存储空间，所以<strong>空间复杂度是 O(1)</strong>；<ul>
<li><strong>注：</strong>这里存储数据需要一个大小为 n 的数组，并不是说空间复杂度就是 O(n)。因为这 n 个空间是必须的，无法省掉。<strong>所以空间复杂度，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间</strong>；</li>
</ul>
</li>
<li>顺序栈还是链式栈，<strong>入栈、出栈</strong>只涉及<strong>栈顶</strong>个别数据的操作，所以时间复杂度都是 O(1)；</li>
</ul>
<h3 id="动态扩容的栈"><a href="#动态扩容的栈" class="headerlink" title="动态扩容的栈"></a>动态扩容的栈</h3><p>尽管链式栈的大小不受限，但要存储 next 指针，<strong>内存消耗相对较多</strong>。</p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><ul>
<li><p>底层依赖一个支持动态扩容的数组；</p>
</li>
<li><p>栈满之后，要申请一个更大的数组，将原来的数据搬移到新的数组中；</p>
</li>
</ul>
<h4 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h4><ul>
<li><p>最好情况时间复杂度是O(1)；</p>
</li>
<li><p>最坏情况时间复杂度是O(n)；</p>
</li>
<li><p>均摊时间复杂度是O(1)；</p>
</li>
</ul>
<h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><p>时间复杂度是O(1)。</p>
<h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><h4 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h4><p>作为一个比较基础的数据结构，<strong>应用场景较多</strong>。一个比较经典的应用场景就是<strong>函数调用栈</strong>。栈可以用于在函数调用时保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？</p>
<ul>
<li>其实，不一定非要用栈来保存临时变量，只不过函数调用符合<strong>后进先出</strong>的特性，用栈这种数据结构来实现，是最<strong>顺理成章</strong>的选择；</li>
<li>从调用函数进入被调用函数，对于<strong>数据</strong>来说，变化的是什么呢？是<strong>作用域</strong>。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段<strong>栈空间</strong>给这个函数的变量，在函数结束的时候，将<strong>栈顶复位</strong>，正好回到调用函数的作用域内；</li>
</ul>
<p><strong>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构</strong>，用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
   <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>; 
   <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
   ret = add(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>);
   res = a + ret;
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, res);
   reuturn <span class="hljs-number">0</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;
   <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
   sum = x + y;
   <span class="hljs-keyword">return</span> sum;
&#125;</code></pre>



<p><img src="%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88.PNG" srcset="/img/loading.gif" alt=""></p>
<h4 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h4><p>算术表达式只包含加减乘除四则运算。一个保存操作数的栈，另一个是保存运算符的栈。</p>
<ul>
<li>从左向右遍历表达式，当遇到<strong>数字</strong>，就直接<strong>压入操作数栈</strong>；</li>
<li>当遇到<strong>运算符</strong>，就与<strong>运算符栈的栈顶元素</strong>进行比较，<ul>
<li>如果比运算符栈顶元素的<strong>优先级高</strong>，就将当前运算符<strong>压栈</strong>；</li>
<li>如果比运算符栈顶元素的优先级<strong>低或者相同</strong>，从运算符栈中<strong>取栈顶运算符</strong>，从操作数栈的栈顶<strong>取 2 个操作数</strong>，然后进行计算，再把计算完的结果<strong>压入操作数栈</strong>，继续比较；</li>
</ul>
</li>
</ul>
<h4 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h4><p>表达式中只包含三种括号，圆括号 ()、方括号[]和花括号{}，可以任意嵌套。给定一个包含三种括号的表达式字符串。用栈可以解决检查它的合法性。</p>
<ul>
<li>用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；</li>
<li>当扫描到右括号时，从栈顶取出一个左括号，<ul>
<li>如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串；</li>
<li>如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式；</li>
</ul>
</li>
<li>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式；</li>
</ul>
<h4 id="实现浏览器的前进、后退功能"><a href="#实现浏览器的前进、后退功能" class="headerlink" title="实现浏览器的前进、后退功能"></a>实现浏览器的前进、后退功能</h4><p>使用两个栈，X 和 Y，把首次浏览的页面依次压入栈 X，</p>
<ul>
<li>当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y；</li>
<li>当点击前进按钮时，依次从栈 Y 中取出数据，放入栈 X 中；</li>
<li>当栈 X 中没有数据时，就说明没有页面可以继续后退浏览了；当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了；</li>
</ul>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>一种操作受限的线性表数据结构，特性是FIFO。</p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>需要两个指针，head指针指向队头，tail指针指向队尾。</p>
<h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><ul>
<li><p>用数组实现的队列；</p>
</li>
<li><p>出队时不用搬移数据。如果没有空闲空间，只需要在入队时再集中触发一次数据的搬移操作；</p>
</li>
</ul>
<p>队满的判断条件是 tail == n，队空的判断条件是 head == tail。</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 基于数组实现的队列</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayQueue</span> </span>&#123;
  <span class="hljs-comment">// 数组：items，数组大小：n</span>
  <span class="hljs-keyword">private</span> String[] items;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// head表示队头下标，tail表示队尾下标</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tail = <span class="hljs-number">0</span>;

  <span class="hljs-comment">// 申请一个大小为capacity的数组</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;
    items = <span class="hljs-keyword">new</span> String[capacity];
    n = capacity;
  &#125;

  <span class="hljs-comment">// 入队</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(String item)</span> </span>&#123;
    <span class="hljs-comment">// 如果tail == n 表示队列已经满了</span>
    <span class="hljs-keyword">if</span> (tail == n) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    items[tail] = item;
    ++tail;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
  &#125;

  <span class="hljs-comment">// 出队</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">// 如果head == tail 表示队列为空</span>
    <span class="hljs-keyword">if</span> (head == tail) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    <span class="hljs-comment">// 为了让其他语言的同学看的更加明确，把--操作放到单独一行来写了</span>
    String ret = items[head];
    ++head;
    <span class="hljs-keyword">return</span> ret;
  &#125;
&#125;</code></pre>



<p>以上的不停地入队、出队操作，head 和 tail 都会持续往后移动。当 tail 移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。</p>
<p>一个可能的解决方案：在出队时可以不用搬移数据。<strong>如果没有空闲空间，只需要在入队时，再集中触发一次数据的搬移操作</strong>。借助这个思想，出队函数 dequeue() 保持不变，<strong>改造一下入队函数 enqueue()</strong> 的实现，就可以解决刚才的问题。</p>
<pre><code class="hljs java"><span class="hljs-comment">// 入队操作，将item放入队尾</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(String item)</span> </span>&#123;
  <span class="hljs-comment">// tail == n表示队列末尾没有空间了</span>
  <span class="hljs-keyword">if</span> (tail == n) &#123;
    <span class="hljs-comment">// tail ==n &amp;&amp; head==0，表示整个队列都占满了</span>
    <span class="hljs-keyword">if</span> (head == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    <span class="hljs-comment">// 数据搬移</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head; i &lt; tail; ++i) &#123;
      items[i-head] = items[i];
    &#125;
    <span class="hljs-comment">// 搬移完之后重新更新head和tail</span>
    tail -= head;
    head = <span class="hljs-number">0</span>;
  &#125;
  
  items[tail] = item;
  ++tail;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
&#125;</code></pre>



<h3 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h3><p>用链表实现的队列。基于链表的实现，需要两个指针：</p>
<ul>
<li>head 指针指向链表的第一个结点；</li>
<li>tail 指针指向最后一个结点；</li>
<li>入队时：tail-&gt;next= new_node, tail = tail-&gt;next；</li>
<li>出队时：head = head-&gt;next；</li>
</ul>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 基于链表实现的队列</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueueBasedOnLinkedList</span> </span>&#123;

  <span class="hljs-comment">// 队列的队首和队尾</span>
  <span class="hljs-keyword">private</span> Node head = <span class="hljs-keyword">null</span>;
  <span class="hljs-keyword">private</span> Node tail = <span class="hljs-keyword">null</span>;

  <span class="hljs-comment">// 入队</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(String value)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (tail == <span class="hljs-keyword">null</span>) &#123;
      Node newNode = <span class="hljs-keyword">new</span> Node(value, <span class="hljs-keyword">null</span>);
      head = newNode;
      tail = newNode;
    &#125; <span class="hljs-keyword">else</span> &#123;
      tail.next = <span class="hljs-keyword">new</span> Node(value, <span class="hljs-keyword">null</span>);
      tail = tail.next;
    &#125;
  &#125;

  <span class="hljs-comment">// 出队</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;

    String value = head.data;
    head = head.next;
    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;
      tail = <span class="hljs-keyword">null</span>;
    &#125;
    <span class="hljs-keyword">return</span> value;
  &#125;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printAll</span><span class="hljs-params">()</span> </span>&#123;
    Node p = head;
    <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;
      System.out.print(p.data + <span class="hljs-string">" "</span>);
      p = p.next;
    &#125;
    System.out.println();
  &#125;

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;
    <span class="hljs-keyword">private</span> String data;
    <span class="hljs-keyword">private</span> Node next;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(String data, Node next)</span> </span>&#123;
      <span class="hljs-keyword">this</span>.data = data;
      <span class="hljs-keyword">this</span>.next = next;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-keyword">return</span> data;
    &#125;
  &#125;

&#125;</code></pre>



<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>用数组来实现队列的时候，在 tail==n 时，会有<strong>数据搬移</strong>操作，这样入队操作性能就会受到影响。可以使用逻辑上数组首尾相连成环的循环队列解决这个问题。</p>
<h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>确定好队空和队满的判定条件：</p>
<ul>
<li>队空：head == tail；</li>
<li>队满：(tail + 1) % n == head；</li>
</ul>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 基于数组实现的循环队列</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircularQueue</span> </span>&#123;
  <span class="hljs-comment">// 数组：items，数组大小：n</span>
  <span class="hljs-keyword">private</span> String[] items;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// head表示队头下标，tail表示队尾下标</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tail = <span class="hljs-number">0</span>;

  <span class="hljs-comment">// 申请一个大小为capacity的数组</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CircularQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;
    items = <span class="hljs-keyword">new</span> String[capacity];
    n = capacity;
  &#125;

  <span class="hljs-comment">// 入队</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(String item)</span> </span>&#123;
    <span class="hljs-comment">// 队列满了</span>
    <span class="hljs-keyword">if</span> ((tail + <span class="hljs-number">1</span>) % n == head) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    items[tail] = item;
    tail = (tail + <span class="hljs-number">1</span>) % n;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
  &#125;

  <span class="hljs-comment">// 出队</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">// 如果head == tail 表示队列为空</span>
    <span class="hljs-keyword">if</span> (head == tail) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    String ret = items[head];
    head = (head + <span class="hljs-number">1</span>) % n;
    <span class="hljs-keyword">return</span> ret;
  &#125;
&#125;</code></pre>



<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>队列满时，tail指向的位置没有存储数据，所以循环队列会浪费一个数组的存储空间。</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><ul>
<li><p>在队列的基础上增加了阻塞操作；</p>
</li>
<li><p>队列为空时，从队头取数据会被阻塞；</p>
</li>
</ul>
<h3 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h3><p>线程安全的队列。</p>
<h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>方式一：直接在enqueue()、dequeue() 上加锁，锁粒度大并发度会比较低下，同一时刻仅允许一个存取数操作。</p>
<p>方式二：利用 CAS 原子操作，可以实现非常高效的并发队列。</p>
<h3 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h3><ul>
<li>平时的业务很少直接用到队列；</li>
<li>一些具有特殊特性的队列应用比较广泛，比如循环队列、阻塞队列和并发队列；</li>
<li>循环队列比链式队列应用更加广泛；</li>
<li>高性能队列 Disruptor、Linux环形缓存，都用到了循环并发队列；</li>
<li>Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等；</li>
</ul>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>每个节点最多有两个子节点，即左子节点和右子节点。</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul>
<li><p>节点高度 = 节点到叶子节点的最长路径（边数）；</p>
</li>
<li><p>节点深度 =  根节点到这个节点所经历的边的个数；</p>
</li>
<li><p>节点层数 = 节点深度 + 1；</p>
</li>
<li><p>树的高度 = 根节点的高度；</p>
</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li><p>满二叉树：叶子节点全都在最底层，除叶子节点之外，每个节点都有左右两个子节点；</p>
</li>
<li><p>完全二叉树：叶子节点都在最底下两层，而且最后一层的叶子节点都靠左排列；</p>
</li>
<li><p>二叉查找树：最大的特点是支持<strong>动态数据集合的快速插入、删除、查找操作</strong>。树中的任意一个节点，</p>
<ul>
<li>其左子树中的每个节点的值，都要小于这个节点的值；</li>
<li>其右子树中的每个节点的值，都要大于这个节点的值；</li>
</ul>
</li>
</ul>
<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><h3 id="BST查找操作"><a href="#BST查找操作" class="headerlink" title="BST查找操作"></a>BST查找操作</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySearchTree</span> </span>&#123;
  <span class="hljs-keyword">private</span> Node tree;

  <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;
    Node p = tree;
    <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">if</span> (data &lt; p.data) p = p.left;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data &gt; p.data) p = p.right;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> p;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
  &#125;

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data;
    <span class="hljs-keyword">private</span> Node left;
    <span class="hljs-keyword">private</span> Node right;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;
      <span class="hljs-keyword">this</span>.data = data;
    &#125;
  &#125;
&#125;</code></pre>



<h3 id="BST的插入操作"><a href="#BST的插入操作" class="headerlink" title="BST的插入操作"></a>BST的插入操作</h3><p>二叉查找树的插入过程有点类似查找操作。新插入的数据<strong>一般都是在叶子节点</strong>上，所以只需要从根节点开始，依次<strong>比较要插入的数据和节点的大小关系</strong>。</p>
<ul>
<li>如果要插入的数据比节点的数据大：<ol>
<li>并且节点的右子树为空，就将新数据直接插到右子节点的位置；</li>
<li>如果不为空，就递归遍历右子树，查找插入位置；</li>
</ol>
</li>
<li>如果要插入的数据比节点数值小：<ol>
<li>并且节点的左子树为空，就将新数据直接插到左子节点的位置；</li>
<li>如果不为空，就递归遍历左子树，查找插入位置；</li>
</ol>
</li>
</ul>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;
  <span class="hljs-keyword">if</span> (tree == <span class="hljs-keyword">null</span>) &#123;
    tree = <span class="hljs-keyword">new</span> Node(data);
    <span class="hljs-keyword">return</span>;
  &#125;

  Node p = tree;
  <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;
    <span class="hljs-keyword">if</span> (data &gt; p.data) &#123;
      <span class="hljs-keyword">if</span> (p.right == <span class="hljs-keyword">null</span>) &#123;
        p.right = <span class="hljs-keyword">new</span> Node(data);
        <span class="hljs-keyword">return</span>;
      &#125;
      p = p.right;
    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// data &lt; p.data</span>
      <span class="hljs-keyword">if</span> (p.left == <span class="hljs-keyword">null</span>) &#123;
        p.left = <span class="hljs-keyword">new</span> Node(data);
        <span class="hljs-keyword">return</span>;
      &#125;
      p = p.left;
    &#125;
  &#125;
&#125;</code></pre>



<h3 id="BST的删除操作"><a href="#BST的删除操作" class="headerlink" title="BST的删除操作"></a>BST的删除操作</h3><p>BST的删除操作相对复杂，针对要删除节点的子节点个数的不同，需要分三种情况来处理。</p>
<ul>
<li>如果<strong>要删除的节点没有子节点</strong>，只需要直接将父节点中，指向要删除节点的指针置为 null。</li>
<li>如果<strong>要删除的节点只有一个子节点</strong>（只有左子节点或者右子节点），只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。</li>
<li>如果<strong>要删除的节点有两个子节点</strong>。那么需要<strong>找到这个节点的右子树中的最小节点</strong>，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点。</li>
</ul>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;
  Node p = tree; <span class="hljs-comment">// p指向要删除的节点，初始化指向根节点</span>
  Node pp = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// pp记录的是p的父节点</span>
  <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; p.data != data) &#123;
    pp = p;
    <span class="hljs-keyword">if</span> (data &gt; p.data) p = p.right;
    <span class="hljs-keyword">else</span> p = p.left;
  &#125;
  <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 没有找到</span>

  <span class="hljs-comment">// 要删除的节点有两个子节点</span>
  <span class="hljs-keyword">if</span> (p.left != <span class="hljs-keyword">null</span> &amp;&amp; p.right != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 查找右子树中最小节点</span>
    Node minP = p.right;
    Node minPP = p; <span class="hljs-comment">// minPP表示minP的父节点</span>
    <span class="hljs-keyword">while</span> (minP.left != <span class="hljs-keyword">null</span>) &#123;
      minPP = minP;
      minP = minP.left;
    &#125;
    p.data = minP.data; <span class="hljs-comment">// 将minP的数据替换到p中</span>
    p = minP; <span class="hljs-comment">// 下面就变成了删除minP了</span>
    pp = minPP;
  &#125;

  <span class="hljs-comment">// 删除节点是叶子节点或者仅有一个子节点</span>
  Node child; <span class="hljs-comment">// p的子节点</span>
  <span class="hljs-keyword">if</span> (p.left != <span class="hljs-keyword">null</span>) child = p.left;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.right != <span class="hljs-keyword">null</span>) child = p.right;
  <span class="hljs-keyword">else</span> child = <span class="hljs-keyword">null</span>;

  <span class="hljs-keyword">if</span> (pp == <span class="hljs-keyword">null</span>) tree = child; <span class="hljs-comment">// 删除的是根节点</span>
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pp.left == p) pp.left = child;
  <span class="hljs-keyword">else</span> pp.right = child;
&#125;</code></pre>



<h3 id="BST的其他操作"><a href="#BST的其他操作" class="headerlink" title="BST的其他操作"></a>BST的其他操作</h3><ul>
<li>除了<strong>插入、删除、查找</strong>操作之外，二叉查找树中还可以支持快速地<strong>查找最大节点</strong>和<strong>最小节点</strong>、<strong>前驱节点</strong>和<strong>后继节点</strong>；</li>
<li>二叉查找树除了支持上面几个操作之外，还有一个重要的特性，就是<strong>中序遍历二叉查找树，可以输出有序的数据序列</strong>，时间复杂度是 O(n)，非常高效。因此，二叉查找树也叫作<strong>二叉排序树</strong>；</li>
<li>支持重复数据的二叉查找树： <ul>
<li>很多时候，在二叉查找树中存储的是一个包含很多字段的对象。利用对象的某个字段作为<strong>键值</strong>来构建二叉查找树。对象中的其他字段叫作<strong>卫星数据</strong>；</li>
</ul>
</li>
</ul>
<h3 id="散列表与BST"><a href="#散列表与BST" class="headerlink" title="散列表与BST"></a>散列表与BST</h3><p>散列表也支持这些操作，且相比于二叉查找树更高效，时间复杂度是 O(1)。思考这两种数据结构的适用场景。</p>
<ul>
<li>散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。BST中序遍历可以在 O(n) 时间复杂度内输出有序的数据序列；</li>
<li>散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定；尽管二叉查找树的性能不稳定，但是在工程中，最常用的平衡二叉查找树的性能稳定，时间复杂度稳定在 O(logn)；</li>
<li>尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定比平衡二叉查找树的效率高；</li>
<li>散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定；</li>
<li>为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间；</li>
</ul>
<p>综合这几点，平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲突。实际的开发过程中，需要结合具体的需求来选择使用哪一个。</p>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><ul>
<li><p>链式存储法</p>
</li>
<li><p>顺序存储法</p>
</li>
</ul>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>将所有节点都遍历打印出来。经典的方法有<strong>前序遍历、中序遍历和后序遍历</strong>。其中，前、中、后序，表示的是<strong>节点与它的左右子树节点</strong>遍历打印的<strong>先后顺序</strong>。二叉树的前、中、后序遍历是一个<strong>递归</strong>的过程。时间复杂度均为O(n)；</p>
<ul>
<li>前序遍历：根-&gt;左子树-&gt;右子树；</li>
<li>中序遍历：左子树-&gt;根-&gt;右子树；</li>
<li>后序遍历：左子树-&gt;右子树-&gt;根；</li>
</ul>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><ul>
<li>一个完全二叉树；</li>
<li>每一个节点的值都必须大于等于（或小于等于）其子树中的每个节点的值；</li>
</ul>
<h2 id="存储-1"><a href="#存储-1" class="headerlink" title="存储"></a>存储</h2><p>完全二叉树比较适合用数组来存储。用数组来存储完全二叉树节省存储空间。通过数组的下标，可以找到一个节点的左右子节点和父节点，而不需要存储左右子节点的指针。假设节点在数组中的下标为 i，那么：</p>
<ul>
<li>其父节点的下标为 i/2；</li>
<li>其左子节点的下标为 i∗2；</li>
<li>其右子节点的下标为 i∗2+1；</li>
</ul>
<h2 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h2><p>插入一个元素和删除堆顶元素。</p>
<h2 id="基于堆实现排序"><a href="#基于堆实现排序" class="headerlink" title="基于堆实现排序"></a>基于堆实现排序</h2><ol>
<li>建堆<ul>
<li>思路1：从前往后处理数组，并且每个数据插入堆中时，都是从下往上堆化；</li>
<li>思路2：从后往前处理数组，并且每个数据都是从上往下堆化</li>
</ul>
</li>
<li>第二步：排序<ol>
<li>堆顶跟最后一个元素交换，把下标为n的元素放到堆顶，通过堆化的方法，将剩下的 n - 1 个元素重新构建成堆；</li>
<li>堆化完成之后，取堆顶的元素，放到下标是 n - 1 的位置；</li>
<li>一直重复这个过程，直到最后堆中只剩下标为 1 的一个元素，排序工作完成</li>
</ol>
</li>
</ol>
<h3 id="快速排序与堆排序"><a href="#快速排序与堆排序" class="headerlink" title="快速排序与堆排序"></a>快速排序与堆排序</h3><ul>
<li><p>堆排序数据访问的方式没有快速排序友好</p>
<ul>
<li><p>对于快速排序来说，数据是顺序访问的；</p>
</li>
<li><p>对于堆排序来说，数据是跳着访问的；</p>
<ul>
<li>堆排序中，最重要的一个操作就是数据的堆化。对堆顶节点进行堆化，访问数组的元素对应的下标是跳跃的，快速排序则是局部顺序访问。所以，堆排序<strong>对 CPU 缓存是不友好的</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>同样的数据，在排序过程中，堆排序算法的数据交换次数多于快速排序</p>
<ul>
<li>排序的时候有序度和逆序度两个概念；</li>
<li>对于<strong>基于比较的排序算法</strong>来说，整个排序过程就是由<strong>比较和交换（或移动）</strong>这两个基本的操作组成的；</li>
<li><strong>快速排序数据交换的次数不会比逆序度多</strong>，但是堆排序的第一步是建堆，<strong>建堆</strong>的过程会打乱数据原有的相对先后顺序，<strong>导致原数据的有序度降低</strong>。比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了；</li>
</ul>
</li>
<li><p>所以，快速排序比堆排序性能好</p>
</li>
</ul>
<h2 id="堆内容小结"><a href="#堆内容小结" class="headerlink" title="堆内容小结"></a>堆内容小结</h2><ul>
<li>堆是一种<strong>完全二叉树</strong>。它最大的特性是：<strong>每个节点的值都大于等于（或小于等于）其子树节点的值</strong>。因此，堆被分成了两类，<strong>大顶堆和小顶堆</strong>；</li>
<li>堆中比较重要的两个操作是<strong>插入一个数据</strong>和<strong>删除堆顶元素</strong>。这两个操作都要用到堆化；<ul>
<li><strong>插入</strong>一个数据的时候，把新插入的数据<strong>放到数组的最后</strong>，然后<strong>从下往上堆化</strong>；</li>
<li><strong>删除堆顶数据</strong>的时候，把数组中的<strong>最后一个元素放到堆顶</strong>，然后从<strong>上往下堆化</strong>；</li>
<li>这两个操作时间复杂度都是 O(logn)；</li>
</ul>
</li>
<li>堆排序，堆排序包含两个过程：</li>
<li>建堆和排序；<ul>
<li>建堆：将<strong>下标从 n/2 到 1 的节点</strong>，依次进行<strong>从上到下的堆化操作</strong>，就可以将数组中的数据组织成堆这种数据结构；</li>
<li>排序：<strong>迭代地将堆顶的元素放到堆的末尾，并将堆的大小减一，然后再堆化</strong>。重复这个过程，直到堆中只剩下一个元素，整个数组中的数据就都<strong>有序排列</strong>了；</li>
</ul>
</li>
<li><strong>优先级队列</strong>是一种特殊的队列，优先级高的数据先出队，不像普通的队列那样，先进先出。实际上，<strong>堆就可以看作优先级队列</strong>，只是称谓不一样罢了；</li>
<li><strong>Top K 问题</strong>可以分为<strong>针对静态数据</strong>和<strong>针对动态数据</strong>，只需要利用一个堆，就可以做到非常高效率的查询 Top K 的数据；</li>
<li><strong>求中位数</strong>实际上还有很多变形，比如<strong>求 99 百分位数据、90 百分位数据</strong>等，处理的思路都是一样的，即<strong>利用两个堆，一个大顶堆，一个小顶堆</strong>，随着数据的动态添加，<strong>动态调整两个堆中的数据</strong>，最后<strong>大顶堆的堆顶元素就是要求的数据</strong>；</li>
</ul>
<h2 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h2><h3 id="实现优先级队列"><a href="#实现优先级队列" class="headerlink" title="实现优先级队列"></a>实现优先级队列</h3><p>队列最大的特性就是先进先出。在优先级队列中，数据的出队顺序不是先进先出，而是按照<strong>优先级</strong>来，优先级最高的，最先出队。</p>
<p>实现一个优先级队列的方法有很多，但是用堆来实现是<strong>最直接、最高效</strong>的。这是因为，堆和优先级队列非常相似。一个堆就可以看作一个优先级队列。很多时候，它们只是概念上的区分而已。<strong>往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素</strong>。</p>
<p>优先级队列的应用场景非常多。很多数据结构和算法都要依赖它。比如，赫夫曼编码、图的最短路径、最小生成树算法等等。很多语言都提供了优先级队列的实现，Java 的 PriorityQueue，C++ 的 priority_queue 等。</p>
<h3 id="合并有序小文件"><a href="#合并有序小文件" class="headerlink" title="合并有序小文件"></a>合并有序小文件</h3><p>假设有 100 个小文件，每个文件的大小是 100MB，每个文件中存储的都是有序的字符串。希望将这些 100 个小文件合并成一个有序的大文件。</p>
<p><strong>方法一：</strong>整体思路有点像归并排序中的合并函数：</p>
<ul>
<li>从这 100 个文件中，<strong>各取第一个字符串</strong>，放入数组中，然后比较大小，把<strong>最小的字符串</strong>放入合并后的大文件中，并从数组中删除；</li>
<li>假设，这个最小的字符串来自于 a.txt 这个小文件，就再从这个小文件<strong>取下一个字符串</strong>，放到数组中，<strong>重新比较大小</strong>，并且选择最小的放入合并后的大文件，将它从数组中删除；</li>
<li>依次类推，直到所有的文件中的数据都放入到大文件为止；</li>
<li>这里用数组这种数据结构，来存储从小文件中取出来的字符串。每次从数组中取最小字符串，都需要循环遍历整个数组，显然，这不是很高效。</li>
</ul>
<p><strong>方法二：</strong>优先级队列，也可以说是堆：</p>
<ul>
<li>把小文件中取出来的字符串放入到小顶堆中，<strong>堆顶的元素就是优先级队列队首的元素</strong>，就是最小的字符串；</li>
<li>将这个字符串放入到大文件中，并将其从堆中删除；</li>
<li>再从小文件中取出下一个字符串，放入到堆中；</li>
<li>循环这个过程，就可以将 100 个小文件中的数据依次放入到大文件中；</li>
<li>删除堆顶数据和往堆中插入数据的时间复杂度都是 O(logn)，n 表示堆中的数据个数，这里就是 100。该方法比原来数组存储的方式高效；</li>
</ul>
<h3 id="高性能定时器"><a href="#高性能定时器" class="headerlink" title="高性能定时器"></a>高性能定时器</h3><p>假设有一个定时器，定时器中维护了很多定时任务，每个任务都设定了一个要触发执行的时间点。<strong>定时器每过一个很小的单位时间（比如 1 秒），就扫描一遍任务，看是否有任务到达设定的执行时间。如果到达了，就拿出来执行。</strong></p>
<p>但是，这样每过 1 秒就扫描一遍任务列表的做法比较低效，主要原因有两点：</p>
<ul>
<li>任务的约定执行时间离当前时间可能还有很久，这样前面很多次扫描其实都是徒劳的；</li>
<li>每次都要扫描整个任务列表，如果任务列表很大的话，势必会比较耗时。</li>
</ul>
<p>针对这些问题，可以用优先级队列来解决：</p>
<ul>
<li>按照任务设定的执行时间，将这些任务存储在优先级队列中，<strong>队列首部（也就是小顶堆的堆顶）存储的是最先执行的任务</strong>；<ul>
<li>这样，定时器就不需要每隔 1 秒就扫描遍历任务列表了；</li>
</ul>
</li>
<li>取队首任务的执行时间点，与当前时间点相减，得到一个<strong>时间间隔 T</strong>。这个时间间隔 T 就是，从当前时间开始，需要等待多久，才会有第一个任务需要被执行。这样，<strong>定时器就可以设定在 T 秒之后，定时器取优先级队列中队首的任务执行</strong>。<ul>
<li>这样，当前时间点到（T-1）秒这段时间里，定时器都不需要做任何事情；</li>
</ul>
</li>
<li>再计算新的队首任务的执行时间点与当前时间点的差值，把这个值作为定时器执行下一个任务需要等待的时间；</li>
<li><strong>循环以上操作</strong>，定时器既不用间隔 1 秒就轮询一次，也不用遍历整个任务列表，性能就提高了。</li>
</ul>
<h3 id="针对静态-动态数据集合求Top-K"><a href="#针对静态-动态数据集合求Top-K" class="headerlink" title="针对静态/动态数据集合求Top K"></a>针对静态/动态数据集合求Top K</h3><ul>
<li>针对静态数据集合，也就是说数据集合事先确定，不会再变；<ul>
<li>在一个包含 n 个数据的数组中，查找前 K 大数据：<ul>
<li><strong>维护一个大小为 K 的小顶堆</strong>，顺序遍历数组，从数组中取出数据与堆顶元素比较：<ul>
<li>若比堆顶元素大，就把堆顶元素删除，并且将这个元素插入到堆中；</li>
<li>若比堆顶元素小，则不做处理，继续遍历数组；</li>
<li>遍历数组中的数据，遍历结束后，堆中的数据就是前 K 大数据了。</li>
</ul>
</li>
<li>遍历数组需要 O(n) 的时间复杂度，<strong>一次堆化操作需要 O(logK)</strong> 的时间复杂度，所以最坏情况下，n 个元素都入堆一次，时间复杂度就是 O(nlogK)。</li>
</ul>
</li>
</ul>
</li>
<li>针对动态数据集合，也就是说数据集合事先并不确定，有数据动态地加入到集合中：<ul>
<li>针对动态数据求得 Top K 就是实时 Top K。一个数据集合中有两个操作，一个是<strong>添加数据</strong>，另一个询问<strong>当前的前 K 大数据</strong>：<ul>
<li>如果每次询问前 K 大数据，都基于当前的数据重新计算的话，那时间复杂度就是 O(nlogK)，n 表示当前的数据的大小。</li>
<li>实际上，可以一直都<strong>维护一个 K 大小的小顶堆</strong>，当有数据被添加到集合中时，将其与堆顶的元素对比：<ul>
<li>若比堆顶元素大，就把堆顶元素删除，并且将这个元素插入到堆中；</li>
<li>若比堆顶元素小，则不做处理；</li>
<li>这样，无论任何时候需要查询当前的前 K 大数据，都可以立刻将结果返回。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="热榜-Top10-关键词"><a href="#热榜-Top10-关键词" class="headerlink" title="热榜 Top10 关键词"></a>热榜 Top10 关键词</h3><p>处理这个问题，有很多高级的解决方法，比如使用 MapReduce 等。</p>
<p>将处理的场景限定为单机，可以使用的内存为 1GB，该问题的可选解决方案为：</p>
<ul>
<li>用户搜索的关键词，有很多可能都是重复的，所以首先要统计每个搜索关键词出现的频率。可以通过<strong>散列表、平衡二叉查找树或者其他一些支持快速查找、插入的数据结构</strong>，来记录关键词及其出现的次数；<ul>
<li>假设选用<strong>散列表</strong>，可以顺序扫描这 10 亿个搜索关键词。当扫描到某个关键词时，就去散列表中查询：<ul>
<li>如果存在，将对应的次数加一；</li>
<li>如果不存在，将它插入到散列表，并记录次数为 1；</li>
<li>遍历完这 10 亿个搜索关键词之后，散列表中就存储了不重复的搜索关键词以及出现的次数；</li>
</ul>
</li>
</ul>
</li>
<li>然后，再根据前面讲的<strong>用堆求 Top K 的方法</strong>，建立一个大小为 10 的小顶堆，遍历散列表，依次取出每个搜索关键词及对应出现的次数，然后与堆顶的搜索关键词对比。如果出现次数比堆顶搜索关键词的次数多，那就删除堆顶的关键词，将这个出现次数更多的关键词加入到堆中；</li>
<li>以此类推，当遍历完整个散列表中的搜索关键词之后，堆中的搜索关键词就是出现次数最多的 Top 10 搜索关键词了；</li>
<li><strong>上面的解决思路其实存在漏洞</strong>。10 亿的关键词还是很多的。假设 10 亿条搜索关键词中不重复的有 1 亿条，如果每个搜索关键词的平均长度是 50 个字节，那存储 1 亿个关键词起码需要 <strong>5GB</strong> 的内存空间，而散列表因为要避免频繁冲突，不会选择太大的装载因子，所以<strong>消耗的内存空间就更多</strong>了。而<strong>机器只有 1GB 的可用内存空间</strong>，所以无法一次性将所有的搜索关键词加入到内存中。</li>
<li>在哈希算法那一节讲过，<strong>相同数据经过哈希算法得到的哈希值是一样的</strong>。可以根据哈希算法的这个特点，<strong>将 10 亿条搜索关键词先通过哈希算法分片到 10 个文件中</strong>。具体可以这样做：<ul>
<li>创建 10 个空文件 00，01，02，……，09；</li>
<li><strong>遍历这 10 亿个关键词，并且通过某个哈希算法对其求哈希值，然后哈希值同 10 取模，</strong>得到的结果就是这个搜索关键词应该被分到的文件编号；</li>
</ul>
</li>
<li>对这<strong>10亿个关键词分片</strong>之后，每个文件都只有 1 亿的关键词，去除掉重复的，可能就只有 1000 万个，每个关键词平均 50 个字节，所以总的大小就是 500MB。1GB 的内存完全可以放得下；</li>
<li><strong>针对每个包含 1 亿条搜索关键词的文件，利用散列表和堆，分别求出 Top 10</strong>，然后把这个 10 个 Top 10 放在一块，然后取这 100 个关键词中，出现次数最多的 10 个关键词，这就是这 10 亿数据中的 Top 10 最频繁的搜索关键词了；</li>
</ul>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>一种非线性表数据结构，比树要复杂</p>
<h2 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h2><ul>
<li><p>有向图</p>
</li>
<li><p>无向图</p>
</li>
<li><p>带权图</p>
</li>
</ul>
<h2 id="存储-2"><a href="#存储-2" class="headerlink" title="存储"></a>存储</h2><h3 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h3><p>缺点：浪费存储空间</p>
<p>优点：存储方式简单、直接、方便计算</p>
<p>应用：Floyd-Warshall算法</p>
<h3 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h3><ul>
<li>查询效率没有邻接矩阵存储方式高；</li>
<li>如果链过长，可以将链表转换成其他更高效的数据结构，比如平衡二叉查找树；</li>
<li>实际开发中，用红黑树或者其他动态数据结构，比如跳表、散列表等，更加快速地查找两个顶点之间是否存在边；</li>
<li>将链表改成有序动态数组，通过二分查找的方法快速定位两个顶点之间是否存在边；</li>
</ul>
<h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><ul>
<li><p>通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置；</p>
</li>
<li><p>当按照键值查询元素时，可以用同样的散列函数，将键值转化为数组下标，从对应的数组下标的位置取元素；</p>
</li>
<li><p>数组的一种扩展，由数组演化而来。没有数组，就没有散列表。</p>
</li>
</ul>
<h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>hash(key)（key表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值）。</p>
<h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><p>散列函数计算得到的散列值是一个非负整数。</p>
<ul>
<li><p>如果 key1 == key2, 那么 hash(key1) == hash(key2)</p>
</li>
<li><p>如果 key1 != key2, 那么 hash(key1) != hash(key2)</p>
</li>
</ul>
<h3 id="设计要点"><a href="#设计要点" class="headerlink" title="设计要点"></a>设计要点</h3><ul>
<li><p>散列函数的设计不能太过复杂；</p>
</li>
<li><p>散列函数生成的值要尽可能随机并且均匀分布；</p>
</li>
</ul>
<h2 id="装载因子"><a href="#装载因子" class="headerlink" title="装载因子"></a>装载因子</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>散列表的装载因子 = 填入表中的元素个数 / 散列表的长度；</p>
<ul>
<li>装填因子越大，说明空闲的位置越少，冲突越多，散列表的性能会下降；</li>
</ul>
<h3 id="装载因子过大怎么办"><a href="#装载因子过大怎么办" class="headerlink" title="装载因子过大怎么办"></a>装载因子过大怎么办</h3><ul>
<li>当装载因子过大时，可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到新散列表中；</li>
<li>针对散列表的扩容，数据搬移操作比数组要复杂的多，需要通过散列函数重新计算每个数据的存储位置；</li>
</ul>
<h2 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h2><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>如果出现散列冲突，就重新探测一个空闲位置，将其插入。</p>
<h4 id="应用-5"><a href="#应用-5" class="headerlink" title="应用"></a>应用</h4><p>数据量比较小，装载因子小的时候，适合采用开放寻址法。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li><p>散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度；</p>
</li>
<li><p>这样实现的散列表，序列化起来比较简单；</p>
</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><p>删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据；</p>
</li>
<li><p>装载因子的上限不能太大；</p>
</li>
</ul>
<h4 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h4><p>往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p>
<h4 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a>二次探测</h4><p>和线性探测有共同点：</p>
<ul>
<li><p>线性探测每次探测的步长是1，探测的下标序列就是hash(key) + 0，hash(key) + 1，hash(key) + 2，……</p>
</li>
<li><p>二次探测探测的步长就变成了原来的“二次方”，探测的下标序列就是hash(key) + 0，hash(key) + 1^2，hash(key) + 2^2，……</p>
</li>
</ul>
<h4 id="双重散列"><a href="#双重散列" class="headerlink" title="双重散列"></a>双重散列</h4><p>先用一组散列表中的第一个散列函数，计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p>
<h3 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h3><p>一种更加常用的散列冲突的解决办法，比开放寻址法简单很多。</p>
<p>每个“桶”（bucket）或者”槽“（slot）会对应一条链表。所有散列值相同的元素都放到相同槽位对应的链表中。</p>
<h4 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a>操作</h4><ul>
<li><p>插入时，只需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表中即可；</p>
</li>
<li><p>查找、删除一个元素时，同样通过散列函数计算出对应的槽，遍历链表查找或者删除；</p>
</li>
</ul>
<h4 id="应用-6"><a href="#应用-6" class="headerlink" title="应用"></a>应用</h4><ul>
<li><p>适合存储大对象，大数据量的散列表；</p>
</li>
<li><p>更加灵活、支持更多的优化策略，比如用红黑树代替链表；</p>
</li>
</ul>
<h2 id="散列表的应用"><a href="#散列表的应用" class="headerlink" title="散列表的应用"></a>散列表的应用</h2><h3 id="LRU淘汰缓存算法"><a href="#LRU淘汰缓存算法" class="headerlink" title="LRU淘汰缓存算法"></a>LRU淘汰缓存算法</h3><p>一个缓存（cache）系统主要包含下面这几个操作：</p>
<ul>
<li>往缓存中<strong>添加</strong>一个数据；</li>
<li>从缓存中<strong>删除</strong>一个数据；</li>
<li>在缓存中<strong>查找</strong>一个数据。</li>
</ul>
<p>维护一个按照访问时间从大到小有序排列的链表结构。因为缓存大小有限，当缓存空间不够，需要淘汰一个数据的时候，直接将链表<strong>头部</strong>的结点删除。</p>
<p>当要缓存某个数据的时候，先在链表中查找这个数据：</p>
<ul>
<li>如果没有找到，直接将数据放到链表的尾部；</li>
<li>如果找到了，把它移动到链表的尾部；</li>
<li>因为查找数据需要遍历链表，所以单纯用链表实现的 LRU 缓存淘汰算法的时间复杂很高，是 O(n)。</li>
</ul>
<p>如果将<strong>散列表</strong>和<strong>链表</strong>两种数据结构组合使用，可以将这三个操作的时间复杂度都降低到 O(1)。</p>
<p>pre和next组成<strong>双向链表</strong>，这个链表是按照缓存的时间由大到小，组成的一个<strong>缓存队列</strong>；</p>
<p>hnext（使用<strong>链表法</strong>解决冲突的<strong>散列表中的链表的next指针</strong>）的作用是，（当发生哈希冲突时）在链表中<strong>插入缓存数据</strong>时，用于<strong>哈希值相等的缓存数据的连接</strong>。</p>
<p><img src="LRU.PNG" srcset="/img/loading.gif" alt=""></p>
<p><strong>散列表和链表经常一块使用</strong>。散列表虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数<strong>打乱之后无规律存储</strong>的。</p>
<p>它<strong>无法支持按照某种顺序快速地遍历数据</strong>。如果希望按照<strong>顺序</strong>遍历散列表中的数据，需要将散列表中的数据拷贝到数组中，然后排序，再遍历。因为<strong>散列表是动态数据结构</strong>，不停地有数据的插入、删除，所以<strong>按序遍历散列表</strong>中的数据的时候，需要<strong>先排序，效率很低</strong>。为了解决这个问题，将散列表和链表（或者跳表）结合在一起使用。</p>
<h3 id="Word-拼写检查实现"><a href="#Word-拼写检查实现" class="headerlink" title="Word 拼写检查实现"></a>Word 拼写检查实现</h3><p>常用的英文单词有 20 万个左右，假设单词的平均长度是 10 个字母，平均一个单词占用 10 个字节的内存空间，那 20 万英文单词大约占 2MB 的存储空间，就算放大 10 倍也就是 20MB。</p>
<p>这个大小完全可以放在内存里面。所以<strong>可以用散列表来存储整个英文单词词典</strong>。当用户输入某个英文单词时，拿用户输入的单词<strong>去散列表中查找</strong>。如果查到，则说明拼写正确；如果没有查到，则说明拼写可能有误，给予提示。借助散列表这种数据结构，就可以轻松实现快速判断是否存在拼写错误。</p>
<h2 id="工业级散列表特性"><a href="#工业级散列表特性" class="headerlink" title="工业级散列表特性"></a>工业级散列表特性</h2><ul>
<li><p>支持快速的查询、插入、删除操作；</p>
</li>
<li><p>内存占用合理，不能浪费过多的内存空间；</p>
</li>
<li><p>性能稳定，极度情况下，散列表的性能也不会退化到无法接受的情况；</p>
</li>
</ul>
<h3 id="实现工业级散列表要点"><a href="#实现工业级散列表要点" class="headerlink" title="实现工业级散列表要点"></a>实现工业级散列表要点</h3><ul>
<li><p>设计一个合适的散列表；</p>
</li>
<li><p>定义装载因子的阈值，并且设计动态扩容策略；</p>
</li>
<li><p>选择合适的散列冲突解决方法；</p>
</li>
</ul>
<h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><ul>
<li><p>将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法；</p>
</li>
<li><p>通过原始数据映射之后得到的二进制值串就是哈希值；</p>
</li>
</ul>
<h2 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a>设计步骤</h2><ul>
<li><p>从哈希值不能反向导出原始数据；</p>
</li>
<li><p>堆输入数据非常敏感，哪怕原始数据只修改了一个bit，最后得到的哈希值也大不相同；</p>
</li>
<li><p>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；</p>
</li>
<li><p>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速计算出哈希值；</p>
</li>
</ul>
<h2 id="应用-7"><a href="#应用-7" class="headerlink" title="应用"></a>应用</h2><ul>
<li><p>安全加密</p>
</li>
<li><p>唯一标识</p>
</li>
<li><p>数据校验</p>
</li>
<li><p>散列函数</p>
</li>
<li><p>负载均衡</p>
</li>
<li><p>数据分片</p>
</li>
<li><p>分布式存储</p>
</li>
</ul>
<h1 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h1><ul>
<li><p>一种特殊的散列表；</p>
</li>
<li><p>通过数组下标来定位数据，访问效率非常高；</p>
</li>
<li><p>每个数字用一个二进制位来表示，数字范围不大的情况下，需要的内存空间非常节省；</p>
</li>
</ul>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p><img src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%89%E4%B8%AA%E6%8C%87%E6%A0%87.png" srcset="/img/loading.gif" alt=""></p>
<p><img src="%E4%B8%89%E7%A7%8D%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F.png" srcset="/img/loading.gif" alt=""></p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Data-Structure/">Data Structure</a>
                    
                      <a class="hover-with-bg" href="/tags/Algorithm/">Algorithm</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/07/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/">
                        <span class="hidden-mobile">操作系统基础</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    
  <!-- 备案信息 -->
  <div class="beian">
    <a href="http://beian.miit.gov.cn/" target="_blank"
       rel="nofollow noopener"></a>
    
  </div>


    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 2,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  














</body>
</html>
