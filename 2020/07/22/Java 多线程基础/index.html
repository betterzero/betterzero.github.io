<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="Edgecloudsim Java Algorithm">
  <meta name="author" content="">
  <meta name="keywords" content="">
  <title>Java 多线程基础 - 九流人</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 60vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>九流人</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bg/astronaut.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
                Java 多线程基础
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-07-22 18:14">
      2020年7月22日 晚上
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      13.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      154
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：2020年8月10日 晚上
                
              </p>
            
            <article class="markdown-body">
              <p>并发成为现代软件开发的基础能力，Java 精心设计的高效并发机制，是构建大规模应用的基础之一。本文介绍 Java 并发编程基础知识。主要内容为 线程生命周期、如何实现线程、synchronized与锁、volatile、线程池、并发包、CAS与原子操作。</p>
<a id="more"></a>



<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是<strong>应用程序在内存中分配的空间，也就是正在运行的程序</strong>，各个进程之间互不干扰。同时进程保存着程序每一个时刻运行的状态。进程的出现，使操作系统的性能大大提升，但是如果一个进程在一段时间只执行一个任务，那么当进程有多个子任务时，只能逐个执行这些子任务，效率较低。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>为了提高 CPU 和 IO 设备的综合利用率，线程个概念被提出并应用。线程是一个比进程更小的执行单位，一个进程包含了多个线程，同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，而<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>是私有的，每个线程负责一个单独的子任务。</p>
<h2 id="进程和线程的异同"><a href="#进程和线程的异同" class="headerlink" title="进程和线程的异同"></a>进程和线程的异同</h2><ul>
<li><p><strong>进程是操作系统进行资源分配的基本单位</strong>，<strong>线程是系统调度的最小单元</strong>；</p>
</li>
<li><p>线程是程序执行的最小单位，更加轻量级，线程间的切换和调度的成本远远小于进程。多线程可以在多核 CPU 上同时运行，减少了线程上下文切换的开销；</p>
</li>
<li><p>多线程并发编程是高并发系统的基础，好多线程机制可以提高系统整体的并发能力及性能；</p>
</li>
<li><p>一个进程可以包含多个线程，线程作为任务的真正执行者，有<strong>自己的栈、寄存器、本地存储（Thread Local）</strong>等，但是会<strong>和进程内其他线程共享文件描述符、虚拟地址空间等</strong>；</p>
</li>
<li><p>Java 中进程的内存占用如下图所示</p>
<p><img src="JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86.png" srcset="/img/loading.gif" alt=""></p>
</li>
</ul>
<h1 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h1><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>Java 5 以后，线程生命周期的不同状态被明确定义在其公共内部枚举类型 java.lang.Thread.State 中，分别是：</p>
<ul>
<li><p>新建（<strong>NEW</strong>），表示线程被创建出来还<strong>没真正启动</strong>的状态，可以认为它是个 Java 内部状态；</p>
</li>
<li><p>就绪（<strong>RUNNABLE</strong>），表示该线程已经在 JVM 中执行，当然由于执行需要计算资源，它<strong>可能是正在运行</strong>，也可能还在<strong>等待系统分配给它 CPU 片段，在就绪队列里面排队</strong>。在其他一些分析中，会额外区分一种状态 <strong>RUNNING</strong>，但是从 Java API 的角度，并不能表示出来；</p>
</li>
<li><p>阻塞（<strong>BLOCKED</strong>），这个状态和同步非常相关，<strong>阻塞表示线程在等待 Monitor lock</strong>。比如，线程试图<strong>通过 synchronized 去获取某个锁</strong>，但是其他线程已经独占了，那么当前线程就会处于阻塞状态；</p>
</li>
<li><p>等待（<strong>WAITING</strong>），表示正在<strong>等待其他线程采取某些操作</strong>。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（<strong>wait</strong>），另外的生产者线程去准备任务数据，然后通过类似 <strong>notify</strong> 等动作，通知消费线程可以继续工作了。<strong>Thread.join() 也会令线程进入等待状态</strong>。计时等待（<strong>TIMED_WAIT</strong>），其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如 <strong>wait 或 join 等方法的指定超时</strong>版本，如下面示例：</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;</code></pre>
</li>
<li><p>终止（<strong>TERMINATED</strong>），不管是<strong>意外退出还是正常执行结束，线程已经完成使命，终止运行</strong>。第二次调用 start() 方法的时候，线程可能处于终止或者其他（非 NEW）状态，但是不论如何，都<strong>不可以再次启动</strong>。</p>
</li>
</ul>
<h2 id="线程操作"><a href="#线程操作" class="headerlink" title="线程操作"></a>线程操作</h2><ul>
<li>start()：启动线程并执行相应的 run() 方法；</li>
<li>run()：子线程要执行的逻辑代码在 run() 中完成；</li>
<li>sleep()：让当前线程停止执行，把 CPU 让给其他线程执行，但<strong>不会释放对象锁和监控的状态</strong>，到了指定时间后线程又会自动恢复运行状态；<ul>
<li>注：线程睡眠到期自动苏醒，并返回到<strong>可运行状态</strong>，不是运行状态。sleep() 中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始执行；</li>
</ul>
</li>
<li>wait()：使一个线程处于等待（阻塞）状态，并且<strong>释放所持有的对象的锁</strong>；</li>
<li>join()：t.join() 方法只会使主线程（调用 t.join() 的线程）进入等待池并等待 t线程 执行完毕后才会被唤醒。不影响同一时刻处在运行状态的其他线程；<ul>
<li>使用场景示例：主线程创建并启动了线程，如果子线程中药进行大量耗时运算，主线程往往会早于子线程结束之前结束。如果主线程想等待子线程执行完成之后再结束，比如主线程要获取子线程处理的数据，就要用到 join() 方法；</li>
</ul>
</li>
<li>yield()：告诉调度器主动让出 CPU；<ul>
<li>注：让出 CPU 不代表当前线程不执行了。当前线程让出 CPU 后，还会进行 CPU 资源的争夺，但是不保证一定能够再次分配到；</li>
</ul>
</li>
<li>getPriority()：获取当前线程的优先级；<ul>
<li>注：两个等待的线程，优先级高的线程容易被 CPU 执行。优先级分为1~10等级，默认优先级是5；</li>
</ul>
</li>
<li>setPriority()：设置线程的优先级；</li>
<li>getId()：取得线程唯一标识；</li>
<li>isAlive()：判断当前线程是否处于活动状态，活动状态就是已经启动尚未终止；</li>
<li>currentThread()：返回代码段正在被哪个线程调用；</li>
<li>resume()、stop()、suspend() 方法被标记为过时，在 JDK 最新版本中，destory/stop 方法将被移除；</li>
<li>基类 Object 提供了一些基础的 wait() / notify() / notifyAll() 方法；<ul>
<li>如果持有某个对象的 Monitor 锁，调用 wait 会让当前线程处于等待状态，直到其他线程 notify 或者 notifyAll。所以，这些方法本质上是提供了 Monitor 的获取和释放的能力，是基本的线程间通信方式；</li>
</ul>
</li>
<li>并发类库中的工具，比如 CountDownLatch.await() 会让当前线程进入等待状态，直到 latch 被计数为 0，这可以看作是线程间通信的 Signal；</li>
</ul>
<h1 id="Java-中如何实现线程"><a href="#Java-中如何实现线程" class="headerlink" title="Java 中如何实现线程"></a>Java 中如何实现线程</h1><h2 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h2><ul>
<li><strong>创建一个任务类继承 Thread 类</strong>，Thread类实现了Runnable接口，所以自定义的任务类也实现了Runnable接口；<ul>
<li>扩展 java.lang.Thread 类来创建线程，java.lang.Thread 类主要有两个方法：<ul>
<li>start()：调用自定义对象的start()方法，可以启动线程；</li>
<li>run()：run()方法定义了具体的任务代码或处理逻辑，Thread 的子类应该重写run()方法；</li>
</ul>
</li>
<li>创建一个任务类对象，可以用 Thread 或者 Runnable 作为自定义的变量类型；</li>
<li>调用自定义对象的 start() 方法，启动一个线程；</li>
</ul>
</li>
<li><strong>定义一个任务类实现 Runnable 接口</strong>；<ul>
<li>实现 Runnable 接口中的 run() 方法；</li>
<li>定义了任务类后，为任务类创建一个任务对象；</li>
<li>任务必须在线程中执行，创建一个 Thread 类的对象，将前面创建的实现了 Runnable 接口的<strong>任务类对象作为参数传递给Thread类的构造方法</strong>；</li>
<li>调用Thread类对象的 start() 方法，启动一个线程。</li>
</ul>
</li>
</ul>
<h1 id="synchronized-与锁"><a href="#synchronized-与锁" class="headerlink" title="synchronized 与锁"></a>synchronized 与锁</h1><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>线程安全是一个多线程环境下<strong>正确性的概念</strong>，也就是保证多线程环境下<strong>共享的</strong>、<strong>可修改</strong>的<strong>状态</strong>的正确性，这里的状态反映在程序中其实可以看作是<strong>数据</strong>。换个角度来看，如果状态不是共享的，或者不是可修改的，也就不存在线程安全问题。线程安全需要保证几个基本特性：</p>
<ul>
<li>原子性：相关操作不会中途被其他线程干扰，一般通过<strong>同步机制</strong>实现；</li>
<li>可见性：一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为<strong>将线程本地状态反映到主内存上</strong>，<strong>volatile</strong> 可以负责保证可见性的；</li>
<li>有序性：保证线程内串行语义，<strong>避免指令重排</strong>等； </li>
</ul>
<h2 id="synchronized-与-ReentrantLock"><a href="#synchronized-与-ReentrantLock" class="headerlink" title="synchronized 与 ReentrantLock"></a>synchronized 与 ReentrantLock</h2><p>synchronized 是 Java 内建的同步机制，所以也称为 Intrinsic Locking，它提供了互斥的语义和可见性，<strong>当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在那里</strong>。</p>
<ul>
<li>Java 5 以前，synchronized 是仅有的同步手段，在代码中，synchronized 可以用来<strong>修饰方法</strong>，也可以使用在特定的<strong>代码块</strong>儿上，<strong>本质上 synchronized 方法等同于把方法全部语句用 synchronized 块包起</strong>；</li>
<li>synchronized 依赖于 <strong>JVM</strong>，ReentrantLock 依赖于 <strong>API</strong>，synchronized 是依赖于 JVM 实现的，没有直接暴露给用户；ReentrantLock 是 JDK 层面实现的（需要 lock() 和 unlock() 方法配合 try/finally 来完成），所以可以查看它的源代码；</li>
<li>ReentrantLock，是 Java 5 提供的锁实现，语义和 synchronized 基本相同。再入锁通过代码直接调用 lock() 方法获取，代码书写也更加灵活。ReentrantLock 提供了很多实用的方法，能够实现很多 synchronized 无法做到的<strong>细节控制</strong>，比如可以控制 fairness，也就是<strong>公平性</strong>，或者利用<strong>定义条件</strong>等。但是，编码中也需要注意，必须要<strong>明确调用 unlock() 方法释放</strong>，不然就会一直持有该锁；<ul>
<li>与 synchronized 相比，ReentrantLock 增加了一些高级功能，主要有三点：等待可中断；可实现公平锁；可实现选择性通知（锁可以绑定多个条件）；</li>
</ul>
</li>
<li>synchronized 和 ReentrantLock 的性能不能一概而论，早期版本 synchronized 在很多场景下性能相差较大，在后续版本进行了较多改进，在低竞争场景中表现可能优于 ReentrantLock；</li>
</ul>
<h2 id="syschronized-实现原理"><a href="#syschronized-实现原理" class="headerlink" title="syschronized 实现原理"></a>syschronized 实现原理</h2><p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。</p>
<p>synchronized 同步代码块由一对 monitorenter / monitorexit 指令实现，Monitor 对象是同步的基本实现单元；同步方法（需要看JVM底层实现）依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。</p>
<p><strong>同步代码块</strong>：monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁；</p>
<p><strong>同步方法</strong>：synchronized方法则会被翻译成普通的方法调用和返回指令如:invokevirtual、areturn指令，在VM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Klass做为锁对象。</p>
<ul>
<li>Java 6 之前，Monitor 的实现完全依靠<strong>操作系统内部的互斥锁</strong>，因为需要进行<strong>用户态到内核态的切换</strong>，所以同步操作是一个<strong>重量级操作</strong>；</li>
</ul>
<h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p>Monitor 可以理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。与一切皆对象一样，所有的 Java 对象是天生的Monitor，每一个 Java 对象都有成为 Monitor 的潜质。因为在 Java 的设计中 ，每一个 Java 对象本身就带了一把看不见的锁，它叫做内部锁或者 Monitor 锁。</p>
<p>Monitor 是线程私有的数据结构，每一个线程都有一个可用 monitor record 列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个 monitor 关联（对象头的 MarkWord 中的 LockWord 指向 monitor 的起始地址），同时 monitor 中有一个 Owner 字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h3><p>Java中每一个对象都可以作为锁：</p>
<ul>
<li><p>普通同步方法，锁是当前实例对象；</p>
</li>
<li><p>静态同步方法，锁是当前类的class对象；</p>
</li>
<li><p>同步方法块，锁是括号里面的对象。</p>
</li>
</ul>
<p>JDK 1.6 对锁的实现引入了大量的优化，如锁粗化（Lock Coarsening）、锁消除（Lock Elimination）、轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）、适应性自旋（Adaptive Spinning）等技术来减少锁操作的开销。</p>
<p><strong>锁粗化：</strong>减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁；</p>
<p><strong>锁消除：</strong>通过运行时 JIT 编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，通过逃逸分析也可以在线程本地 Stack上进行对象空间的分配（同时还可以减少Heap上的垃圾收集开销）；</p>
<p><strong>轻量级锁：</strong>实现的背后基于这样一种假设：在真实的情况下程序中的大部分同步代码一般都处于无锁竞争状态（即单线程执行环境），在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在 monitorenter 和 monitorexit 中只需要依靠一条 CAS 原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行 CAS 指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒；</p>
<p><strong>偏向锁：</strong>为了在无锁竞争的情况下避免在锁获取过程中执行不必要的 CAS 原子指令，因为 CAS 原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟；</p>
<p><strong>适应性自旋：</strong>线程在获取轻量级锁的过程中执行 CAS 操作失败时，在进入与 monitor 相关联的操作系统重量级锁（mutex semaphore）前会进入忙等待然后再次尝试，当尝试一定的次数后如果仍然没有成功则调用与该 monitor 关联的 semaphore（即互斥锁）进入到阻塞状态。</p>
<h3 id="锁的升级和降级"><a href="#锁的升级和降级" class="headerlink" title="锁的升级和降级"></a>锁的升级和降级</h3><ul>
<li>现代的（Oracle）JDK 中，JVM 对此进行了改进，提供了<strong>三种不同的 Monitor 实现</strong>，也就是常说的三种不同的锁：<strong>偏向锁</strong>（Biased Locking）、<strong>轻量级锁</strong>和<strong>重量级锁</strong>，大大改进了其性能；</li>
<li>锁的升级、降级，指的是 <strong>JVM 优化 synchronized 运行的机制</strong>，当 JVM 检测到不同的竞争状况时，会<strong>自动切换到适合的锁实现</strong>，这种切换就是锁的升级、降级；</li>
<li>当<strong>没有竞争</strong>出现时，默认会使用偏向锁。JVM 会利用 <strong>CAS 操作</strong>（compare and swap），在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，<strong>大部分对象生命周期中最多会被一个线程锁定</strong>，使用<strong>偏向锁可以降低无竞争开销</strong>；</li>
<li>如果有<strong>另外的线程试图锁定某个已经被偏斜过的对象</strong>，JVM 就需要撤销（revoke）偏向锁，并切换到<strong>轻量级锁实现</strong>。轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，<strong>如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁；</strong></li>
<li>有的观点认为 Java 不会进行锁降级。有的观点认为，锁降级是会发生的，当 <strong>JVM 进入安全点</strong>（SafePoint）的时候，会检查是否有闲置的 Monitor，然后试图进行降级。</li>
</ul>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个共享变量的值，而另外一个线程还继续使用它的本地内存中共享变量的副本，造成<strong>数据的不一致</strong>。</p>
<p>注：在多个线程之间能够被共享的变量被称为共享变量。共享变量包括所有的实例变量，静态变量和数组元素。他们都被存放在堆内存中，volatile 只作用于共享变量。</p>
<h2 id="volatile-定义"><a href="#volatile-定义" class="headerlink" title="volatile 定义"></a>volatile 定义</h2><p>java 编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java 语言提供了 volatile，在某些情况下比锁更加方便。如果一个字段被声明成 volatile，java 线程内存模型确保所有线程看到这个变量的值是一致的。</p>
<p>Volatile 是<strong>轻量级的 synchronized</strong>，它在多处理器开发中保证了共享变量的“<strong>可见性</strong>”。可见性指的是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h2><p>池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。线程池提供了一种限制和管理资源的技术。 每个线程池维护一些基本统计信息，例如已完成任务的数量。</p>
<ul>
<li><strong>降低资源消耗</strong>：通过重复利用已创建的线程降低线程创建和销毁造成的消耗；</li>
<li>*<em>提高响应速度 *</em>：当任务到达时，任务可以不需要的等待线程的创建就能立即执行；</li>
<li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控；</li>
</ul>
<h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>通常开发者可以利用 Executors 提供的通用线程池创建方法，创建不同配置的线程池，主要区别在于不同的 ExecutorService 类型或者不同的初始参数。Executors 目前提供了 5 种不同的线程池创建配置：</p>
<ul>
<li>newCachedThreadPool()：<strong>用来处理大量短时间工作任务的线程池</strong>，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</li>
<li>newFixedThreadPool(int nThreads)：<strong>重用指定数目（nThreads）的线程，底层使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的</strong>。如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；</li>
<li>newSingleThreadExecutor()：<strong>工作线程数目被限制为 1</strong>，操作一个无界的工作队列，<strong>保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态</strong>，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；</li>
<li>newSingleThreadScheduledExecutor() 和 newScheduledThreadPool(int corePoolSize)：创建的是个 ScheduledExecutorService，可以进行<strong>定时或周期性的工作调度</strong>，区别在于单一工作线程还是多个工作线程；</li>
<li>newWorkStealingPool(int parallelism)：Java 8 加入这个创建方法，内部会构建ForkJoinPool，利用Work-Stealing算法，<strong>并行地处理任务，不保证处理顺序</strong>；</li>
</ul>
<p>注：</p>
<ul>
<li>newFixedThreadPool 和 newSingleThreadExecutor：允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致OOM。</li>
<li>newCachedThreadPool 和 newScheduledThreadPool：允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</li>
</ul>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal 是一个数据结构，有点像HashMap，可以保存”key : value”键值对，但是一个ThreadLocal只能保存一个，并且各个线程的数据互不干扰。</p>
<pre><code class="hljs java">ThreadLocal&lt;String&gt; localName = <span class="hljs-keyword">new</span> ThreadLocal();
localName.set(<span class="hljs-string">"线程1"</span>);
String name = localName.get();</code></pre>



<p>在线程1中初始化了一个ThreadLocal对象 localName，并通过set方法，保存了一个值 线程1，同时在线程1中通过 localName.get() 可以拿到之前设置的值，但是如果在线程2中，拿到的将是一个null。</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Returns the value in the current thread's copy of this</span>
<span class="hljs-comment"> * thread-local variable.  If the variable has no value for the</span>
<span class="hljs-comment"> * current thread, it is first initialized to the value returned</span>
<span class="hljs-comment"> * by an invocation of the &#123;<span class="hljs-doctag">@link</span> #initialValue&#125; method.</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the current thread's value of this thread-local</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;
        ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);
        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)
            T result = (T)e.value;
            <span class="hljs-keyword">return</span> result;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> setInitialValue();
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Sets the current thread's copy of this thread-local variable</span>
<span class="hljs-comment"> * to the specified value.  Most subclasses will have no need to</span>
<span class="hljs-comment"> * override this method, relying solely on the &#123;<span class="hljs-doctag">@link</span> #initialValue&#125;</span>
<span class="hljs-comment"> * method to set the values of thread-locals.</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value the value to be stored in the current thread's copy of</span>
<span class="hljs-comment"> *        this thread-local.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)
        map.set(<span class="hljs-keyword">this</span>, value);
    <span class="hljs-keyword">else</span>
        createMap(t, value);
&#125;</code></pre>



<p>从源码可以看到，每个线程中都有一个 ThreadLocalMap 数据结构，当执行set方法时，其值是保存在当前线程的 threadLocals 变量中，当执行set方法中，是从当前线程的 threadLocals 变量获取。所以在线程1中set的值，对线程2来说是摸不到的，而且在线程2中重新set的话，也不会影响到线程1中的值，保证了线程之间不会相互干扰。</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * ThreadLocalMap is a customized hash map suitable only for</span>
<span class="hljs-comment"> * maintaining thread local values. No operations are exported</span>
<span class="hljs-comment"> * outside of the ThreadLocal class. The class is package private to</span>
<span class="hljs-comment"> * allow declaration of fields in class Thread.  To help deal with</span>
<span class="hljs-comment"> * very large and long-lived usages, the hash table entries use</span>
<span class="hljs-comment"> * WeakReferences for keys. However, since reference queues are not</span>
<span class="hljs-comment"> * used, stale entries are guaranteed to be removed only when</span>
<span class="hljs-comment"> * the table starts running out of space.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalMap</span> </span>&#123;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * The entries in this hash map extend WeakReference, using</span>
<span class="hljs-comment">     * its main ref field as the key (which is always a</span>
<span class="hljs-comment">     * ThreadLocal object).  Note that null keys (i.e. entry.get()</span>
<span class="hljs-comment">     * == null) mean that the key is no longer referenced, so the</span>
<span class="hljs-comment">     * entry can be expunged from table.  Such entries are referred to</span>
<span class="hljs-comment">     * as "stale entries" in the code that follows.</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;
        <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span>
        Object value;

        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;
            <span class="hljs-keyword">super</span>(k);
            value = v;
        &#125;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * The initial capacity -- MUST be a power of two.</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INITIAL_CAPACITY = <span class="hljs-number">16</span>;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * The table, resized as necessary.</span>
<span class="hljs-comment">     * table.length MUST always be a power of two.</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> Entry[] table;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * The number of entries in the table.</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * The next size value at which to resize.</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> threshold; <span class="hljs-comment">// Default to 0</span>

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * Set the resize threshold to maintain at worst a 2/3 load factor.</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setThreshold</span><span class="hljs-params">(<span class="hljs-keyword">int</span> len)</span> </span>&#123;
        threshold = len * <span class="hljs-number">2</span> / <span class="hljs-number">3</span>;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * Increment i modulo len.</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> len)</span> </span>&#123;
        <span class="hljs-keyword">return</span> ((i + <span class="hljs-number">1</span> &lt; len) ? i + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * Decrement i modulo len.</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">prevIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> len)</span> </span>&#123;
        <span class="hljs-keyword">return</span> ((i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) ? i - <span class="hljs-number">1</span> : len - <span class="hljs-number">1</span>);
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * Construct a new map initially containing (firstKey, firstValue).</span>
<span class="hljs-comment">     * ThreadLocalMaps are constructed lazily, so we only create</span>
<span class="hljs-comment">     * one when we have at least one entry to put in it.</span>
<span class="hljs-comment">     */</span>
    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;
        table = <span class="hljs-keyword">new</span> Entry[INITIAL_CAPACITY];
        <span class="hljs-keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);
        table[i] = <span class="hljs-keyword">new</span> Entry(firstKey, firstValue);
        size = <span class="hljs-number">1</span>;
        setThreshold(INITIAL_CAPACITY);
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * Construct a new map including all Inheritable ThreadLocals</span>
<span class="hljs-comment">     * from given parent map. Called only by createInheritedMap.</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> parentMap the map associated with parent thread.</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ThreadLocalMap</span><span class="hljs-params">(ThreadLocalMap parentMap)</span> </span>&#123;
        Entry[] parentTable = parentMap.table;
        <span class="hljs-keyword">int</span> len = parentTable.length;
        setThreshold(len);
        table = <span class="hljs-keyword">new</span> Entry[len];

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) &#123;
            Entry e = parentTable[j];
            <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)
                ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();
                <span class="hljs-keyword">if</span> (key != <span class="hljs-keyword">null</span>) &#123;
                    Object value = key.childValue(e.value);
                    Entry c = <span class="hljs-keyword">new</span> Entry(key, value);
                    <span class="hljs-keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);
                    <span class="hljs-keyword">while</span> (table[h] != <span class="hljs-keyword">null</span>)
                        h = nextIndex(h, len);
                    table[h] = c;
                    size++;
                &#125;
            &#125;
        &#125;
    &#125;</code></pre>











<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p>
<h3 id="线程池创建"><a href="#线程池创建" class="headerlink" title="线程池创建"></a>线程池创建</h3><p>可以通过 ThreadPoolExecutor 创建一个线程池。</p>
<pre><code class="hljs java"><span class="hljs-keyword">new</span>  ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, handler);</code></pre>



<ul>
<li>corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，<strong>即使其他空闲的基本线程能够执行新任务也会创建线程</strong>，等到<strong>需要执行的任务数大于线程池基本大小</strong>时就不再创建。如果调用了线程池的 prestartAllCoreThreads 方法，线程池会提前创建并启动所有基本线程；</li>
<li>runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列：<ul>
<li>ArrayBlockingQueue：基于数组结构的有界阻塞队列，按 FIFO 原则对元素排序；</li>
<li>LinkedBlockingQueue：基于链表结构的阻塞队列，按 FIFO 原则对元素排序，吞吐量通常高于 ArrayBlockingQueue。静态工厂方法 Executors.newFixedThreadPool() 使用了这个队列；</li>
<li>SynchronousQueue：不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 LinkedBlockingQueue，静态工厂方法 Executors.newCachedThreadPool 使用了这个队列；</li>
<li>PriorityBlockingQueue：具有优先级的无界阻塞队列；</li>
</ul>
</li>
<li>maximumPoolSize（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果；</li>
<li>ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字；</li>
<li>RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是 AbortPolicy，表示无法处理新任务时抛出异常。以下是 JDK1.5 提供的四种策略：<ul>
<li>AbortPolicy：直接抛出异常；</li>
<li>CallerRunsPolicy：只用调用者所在线程来运行任务；</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务；</li>
<li>DiscardPolicy：不处理，丢弃掉；</li>
<li>也可以根据应用场景需要来实现 RejectedExecutionHandler 接口自定义策略。如记录日志或持久化不能处理的任务；</li>
</ul>
</li>
<li>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率；</li>
<li>TimeUnit（线程活动保持时间的单位）：可选的单位有天，小时，分钟，毫秒，微秒 (千分之一毫秒) 和毫微秒 (千分之一微秒)；</li>
</ul>
<h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><p>可以通过 execute() 和 submit() 方法向线程池提交任务。</p>
<ul>
<li><p>execute() 用于提交不需要返回值的任务，无法判断任务是否被线程池执行成功；</p>
<pre><code class="hljs java">threadsPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                <span class="hljs-comment">// TODO Auto-generated method stub</span>
            &#125;
        &#125;);</code></pre>


</li>
</ul>
<ul>
<li><p>submit() 方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get() 方法获取返回值，get() 方法会阻塞当前线程直到任务完成，而 get(long timeout，TimeUnit unit) 方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完；</p>
<pre><code class="hljs java">Future&lt;Object&gt; future = executor.submit(harReturnValuetask);
<span class="hljs-keyword">try</span> &#123;
     Object s = future.get();
&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
    <span class="hljs-comment">// 处理中断异常 </span>
&#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;
    <span class="hljs-comment">// 处理无法执行任务异常 </span>
&#125; <span class="hljs-keyword">finally</span> &#123;
    <span class="hljs-comment">// 关闭线程池 </span>
    executor.shutdown();
&#125;</code></pre>



</li>
</ul>
<h3 id="线程池关闭"><a href="#线程池关闭" class="headerlink" title="线程池关闭"></a>线程池关闭</h3><p>可以通过调用线程池的 shutdown 或 shutdownNow 方法来关闭线程池，它们的原理是遍历线程池中的工作线程，然后逐个调用线程的 interrupt 方法来中断线程，所以无法响应中断的任务可能永远无法终止。</p>
<ul>
<li>shutdownNow 首先将线程池的状态设置成 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表；</li>
<li>shutdown 只是将线程池的状态设置成 SHUTDOWN 状态，然后中断所有没有正在执行任务的线程；</li>
</ul>
<p>只要调用了这两个关闭方法的其中一个，isShutdown 方法就会返回 true。当所有的任务都已关闭后, 才表示线程池关闭成功，这时调用 isTerminaed 方法会返回 true。至于调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定。通常调用 shutdown 来关闭线程池，如果任务不一定要执行完，则可以调用 shutdownNow。</p>
<h3 id="线程池工作流程"><a href="#线程池工作流程" class="headerlink" title="线程池工作流程"></a>线程池工作流程</h3><p>线程池的主要工作流程如下图所示：</p>
<p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg" srcset="/img/loading.gif" alt=""></p>
<p>当提交一个新任务到线程池时，线程池的处理流程如下：</p>
<ol>
<li>首先线程池判断<strong>基本线程池</strong>是否已满？没满，创建一个工作线程来执行任务，否则：</li>
<li>其次线程池判断<strong>工作队列</strong>是否已满？没满，则将新提交的任务存储在工作队列里，否则：</li>
<li>最后线程池判断<strong>整个线程池</strong>是否已满？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务；</li>
</ol>
<p>源码分析部分以及下面的线程池配置部分可以参见方腾飞老师<a href="https://www.infoq.cn/article/java-threadPool" target="_blank" rel="noopener">JAVA 线程池的分析和使用</a>的博客，以及 <a href="https://snailclimb.gitee.io/javaguide/#/docs/java/Multithread/JavaConcurrencyAdvancedCommonInterviewQuestions?id=_41-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8%e7%ba%bf%e7%a8%8b%e6%b1%a0%ef%bc%9f" target="_blank" rel="noopener">JavaGuide的线程池总结</a>。</p>
<h3 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h3><p>合理的配置线程池，需要从以下几个角度分析任务特性：</p>
<ol>
<li>任务的性质：CPU 密集型任务，IO 密集型任务和混合型任务。</li>
<li>任务的优先级：高，中和低。</li>
<li>任务的执行时间：长，中和短。</li>
<li>任务的依赖性：是否依赖其他系统资源，如数据库连接。</li>
</ol>
<h1 id="Java-并发包"><a href="#Java-并发包" class="headerlink" title="Java 并发包"></a>Java 并发包</h1><p>Java 提供了不同层面的线程安全支持。在传统集合框架内部，除了 <strong>Vector、Stack、Hashtable</strong> 等同步容器，还提供了<strong>同步包装器</strong>（Synchronized Wrapper），可以调用 Collections 工具类提供的包装方法，获取一个同步的包装容器（如 Collections.synchronizedMap），但是它们都是利用<strong>粗粒度的同步方式</strong>，<strong>高并发下性能较低</strong>。</p>
<p>鉴于Java 集合框架的典型容器类绝大多数都不是线程安全的且性能较低，Java 提供了并发包，为高度并发需求提供了更加全面的工具支持。</p>
<ul>
<li>各种并发容器，如 ConcurrentHashMap、CopyOnWriteArrayList；</li>
<li>各种线程安全队列（Queue/Deque），如 ArrayBlockingQueue、SynchronousQueue；</li>
<li>各种有序容器的线程安全版本等；</li>
</ul>
<p>线程安全的实现方式有简单的 <strong>synchronize</strong> 方式，也有更加精细化的，比如<strong>基于分离锁实现的 ConcurrentHashMap</strong> 等并发实现等。具体选择要看开发的场景需求。</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p><strong>Java 1.6</strong> 版本的ConcurrentHashMap：</p>
<p>ConcurrentHashMap 由 Segment 数组结构和 HashEntry 数组结构组成。Segment 是一种可重入锁 ReentrantLock，在 ConcurrentHashMap 里扮演锁的角色，<strong>HashEntry 则用于存储键值对数据</strong>。<strong>一个 ConcurrentHashMap 里包含一个 Segment 数组</strong>，Segment 的结构和 HashMap 类似，是一种数组和链表结构， <strong>一个 Segment 里包含一个 HashEntry 数组</strong>，每个 HashEntry 是一个链表结构的元素， 每个 Segment 守护者一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁。结构如下图所示：</p>
<p><img src="ConcurrentHashMap.jpg" srcset="/img/loading.gif" alt=""></p>
<p><strong>Java 8</strong> 和之后的版本中，ConcurrentHashMap：</p>
<ul>
<li>总体结构上，它的内部存储和 HashMap 结构非常相似，同样是大的桶（bucket）数组，内部也是的链表结构，同步的粒度要更细致一些（锁的颗粒度，是加在链表头上的）；</li>
<li>内部仍然有 Segment 定义，但仅仅是为了保证序列化时的兼容性，不再有任何结构上的用处；</li>
<li>因为不再使用 Segment，初始化操作大大简化，修改为 lazy-load 形式，这样可以有效避免初始开销；</li>
<li>数据存储利用 volatile 来保证可见性；</li>
<li>使用 CAS 等操作，在特定场景进行无锁并发操作；</li>
<li>使用 Unsafe、LongAdder 之类底层手段，进行极端情况的优化。</li>
</ul>
<h2 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h2><p>队列是非常重要的数据结构，日常开发中很多线程间数据传递都要依赖于它，Executor 框架提供的各种线程池，同样无法离开队列。</p>
<p>实现一个线程安全的队列有两种实现方式：一种是使用阻塞算法，另一种是使用非阻塞算法。使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现，而非阻塞的实现方式则可以使用循环 CAS 的方式来实现。线程安全队列 ConcurrentLinkedQueue 是使用非阻塞的方式来实现的。</p>
<h3 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h3><h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><p>对于 ConcurrentLinkedQueue 的方法实现可以参见<a href="https://juejin.im/post/5aeeae756fb9a07ab11112af#heading-0" target="_blank" rel="noopener">并发容器之 ConcurrentLinkedQueue</a> 这篇文章。</p>
<ul>
<li><p>Concurrent 类型基于 <strong>lock-free</strong>，在常见的多线程访问场景，一般可以<strong>提供较高吞吐量</strong>；</p>
</li>
<li><p><strong>Concurrent</strong> 类型没有类似 <strong>CopyOnWrite</strong> 之类容器相对较重的<strong>修改开销</strong>；</p>
</li>
<li><p>Concurrent 往往提供了<strong>较低的遍历一致性</strong>。可以这样理解所谓的弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历；</p>
</li>
<li><p>同步容器 ”<strong>fail-fast</strong>”：检测到容器在遍历过程中发生了修改，则抛出 ConcurrentModificationException，不再继续遍历；</p>
</li>
<li><p>弱一致性的另外一个体现是，<strong>size 等操作准确性是有限的</strong>，未必是 100% 准确；</p>
</li>
<li><p>与此同时，<strong>读取的性能</strong>具有一定的不确定性；</p>
</li>
</ul>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<p>对于阻塞队列，更加详细的介绍和分析参见 <a href="https://www.infoq.cn/article/java-blocking-queue" target="_blank" rel="noopener">Java 中的阻塞队列</a> 。</p>
<h2 id="CopyOnWrite"><a href="#CopyOnWrite" class="headerlink" title="CopyOnWrite"></a>CopyOnWrite</h2><p>CopyOnWrite 的原理是：任何修改操作，如 add、set、remove，都会拷贝原数组，修改后替换原来的数组，通过这种防御性的方式，实现另类的线程安全。适合<strong>读多写少的操作</strong>，不然修改的开销是比较高的。</p>
<p>这样做的好处在于，可以在并发的场景下对容器进行”读操作”而不需要”加锁”，从而达到读写分离的目的。从JDK 1.5 开始 Java 并发包里提供了两个使用 CopyOnWrite 机制实现的并发容器 ，分别是CopyOnWriteArrayList和CopyOnWriteArraySet 。CopyOnWriteArraySet 是通过包装了 CopyOnWriteArrayList 来实现的。</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>CopyOnWriteArrayList 经常被用于“读多写少”的并发场景，因为 CopyOnWriteArrayList 无需任何同步措施，增强了读的性能。Java 中遍历非线程安全的 List（如：ArrayList和 LinkedList）的时候，若中途有别的线程对List容器进行修改，会抛出ConcurrentModificationException异常。CopyOnWriteArrayList由于其”读写分离”，遍历和修改操作分别作用在不同的List容器，所以在使用迭代器遍历的时候，不会抛出异常。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>CopyOnWriteArrayList每次执行写操作都会将原容器进行拷贝了一份，数据量大的时候，内存会存在较大的压力，可能会引起频繁Full GC（ZGC没有使用Full GC）；<ul>
<li>比如对象占用的内存200M左右，再写入100M数据进去，内存就会多占用300M；</li>
</ul>
</li>
<li>CopyOnWriteArrayList 由于实现的原因，写和读分别作用在不同新老容器上，写操作执行过程中，读不会阻塞，但读取到的却是老容器的数据；</li>
</ul>
<h4 id="操作分析"><a href="#操作分析" class="headerlink" title="操作分析"></a>操作分析</h4><p>CopyOnWriteArrayList 的源码分析可以参见<a href="https://redspider.gitbook.io/concurrent/di-san-pian-jdk-gong-ju-pian/16#16-2-copyonwritearraylist" target="_blank" rel="noopener">代码分析</a>。</p>
<ul>
<li>CopyOnWriteArrayList 的 add 操作是先把原容器进行copy，然后在新的副本上进行“写操作”，最后再切换引用，在此过程中是加了锁的；</li>
<li>remove 操作的逻辑是将要删除元素之外的其他元素拷贝到新的副本中，然后切换引用，再将原容器的引用指向新的副本中，因为 remove 操作也是写操作，所以也是要加锁的；</li>
<li>get 操作是“读操作”，没有加锁，直接读取；</li>
</ul>
<h2 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h2><p> Java 并发包提供了<strong>比 synchronized 更加高级的各种同步结构</strong>，包括 CountDownLatch、CyclicBarrier、Semaphore 等，可以实现更加丰富的多线程操作，比如利用 Semaphore 作为资源控制器，限制同时进行工作的线程数量；</p>
<ul>
<li><p>Semaphore，Java 版本的<strong>信号量的实现</strong>。</p>
</li>
<li><p>CountDownLatch，也叫做闭锁，<strong>允许一个或多个线程等待某些操作完成后再执行</strong>；</p>
</li>
<li><p>CyclicBarrier，一种辅助性的同步结构，<strong>允许多个线程等待到达某个屏障</strong>；</p>
</li>
</ul>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Java 提供了经典信号量（Semaphore）的实现，它通过控制一定数量的允许（permit）的方式，来达到限制通用资源访问的目的。类比如下场景：在车站、机场等出租车时，当很多空出租车就位时，为防止过度拥挤，调度员指挥排队等待坐车的队伍一次进来 5 个人上车，等这 5 个人坐车出发，再放进去下一批，这和 Semaphore 的工作原理有些类似。Semaphore 可以理解为<strong>计数器</strong>，其<strong>基本逻辑基于 acquire/release</strong>，没有太复杂的同步逻辑。</p>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p><a href="https://www.jianshu.com/p/03f5d1b02bb8" target="_blank" rel="noopener">参考：白话Java并发工具类</a></p>
<p>在多线程协作完成业务功能时，有时候需要等待其他多个线程完成任务之后，主线程才能继续往下执行业务功能，在这种的业务场景下，通常可以使用Thread类的join方法，让主线程等待被join的线程执行完之后，主线程才能继续往下执行。当然，使用线程间消息通信机制也可以完成。java并发工具类中提供了类似“倒计时”这样的工具类，可以十分方便的完成这种业务场景。</p>
<p>CountDownLatch内部会维护一个初始值为线程数量的计数器，主线程执行await方法，如果计数器大于0，则阻塞等待。当一个线程完成任务后，计数器值减1。当计数器为0时，表示所有的线程已经完成任务，等待的主线程被唤醒继续执行。</p>
<h4 id="CountDownLatch主要方法"><a href="#CountDownLatch主要方法" class="headerlink" title="CountDownLatch主要方法"></a>CountDownLatch主要方法</h4><ul>
<li>await() throws InterruptedException：调用该方法的线程等到构造方法传入的N减到0的时候，才能继续往下执行；</li>
<li>await(long timeout, TimeUnit unit)：与上面的await方法功能一致，加上时间限制，调用该方法的线程等到指定的timeout时间后，不管N是否减至为0，都会继续往下执行；</li>
<li>countDown()：使CountDownLatch初始值N减1；</li>
<li>long getCount()：获取当前CountDownLatch维护的值；</li>
</ul>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>CyclicBarrier也是一种多线程并发控制的实用工具，和CountDownLatch一样具有等待计数的功能。CyclicBarrier在使用一次后，下面依然有效，可以继续当做计数器使用，这是与CountDownLatch的区别之一。</p>
<h3 id="CountDownLatch-与-CyclicBarrier-异同"><a href="#CountDownLatch-与-CyclicBarrier-异同" class="headerlink" title="CountDownLatch 与 CyclicBarrier 异同"></a>CountDownLatch 与 CyclicBarrier 异同</h3><ul>
<li>CountDownLatch 是不可以重置的，所以<strong>无法重用</strong>；而 CyclicBarrier 则没有这种限制，<strong>可以重用</strong>；</li>
<li>CountDownLatch 的基本操作组合是 <strong>countDown/await</strong>。调用 await 的线程阻塞等待 countDown 足够的次数，不管是在一个线程还是多个线程里 countDown，只要次数足够即可。<strong>CountDownLatch 操作的是事件</strong>；</li>
<li>CyclicBarrier 的基本操作组合，则就是 <strong>await</strong>，当所有的伙伴（parties）<strong>都调用了 await</strong>，才会继续进行任务，并<strong>自动进行重置</strong>。注意，正常情况下，CyclicBarrier 的重置都是自动发生的，如果调用 reset 方法，但还有线程在等待，就会导致等待线程被打扰，抛出 BrokenBarrierException 异常。<strong>CyclicBarrier 侧重点是线程，而不是调用事件</strong>，它的典型应用场景是<strong>用来等待并发线程结束</strong>。</li>
</ul>
<h3 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h3><p>Java 并发类库还提供了Phaser，功能与 CountDownLatch 很接近，但是它<strong>允许线程动态地注册到 Phaser 上面</strong>，而 CountDownLatch 显然是不能动态设置的。Phaser 的设计初衷是，实现多个线程类似步骤、阶段场景的协调，线程注册等待屏障条件触发，进而协调彼此间行动。</p>
<h1 id="CAS-与原子操作"><a href="#CAS-与原子操作" class="headerlink" title="CAS 与原子操作"></a>CAS 与原子操作</h1><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁是一种特定的程序状态，实体之间由于循环依赖导致彼此一直处于等待之中，没有任何个体可以继续前进。死锁不仅仅是在线程之间会发生，存在资源独占的进程之间同样也可能出现死锁。通常来说，大多关注多线程场景中的死锁。两个或多个线程之间，由于互相持有对方需要的锁，而永久处于阻塞的状态。</p>
<p>定位死锁最常见的方式就是利用 jstack 等工具获取线程栈，然后定位互相之间的依赖关系，进而找到死锁。如果是比较明显的死锁，往往 jstack 等就能直接定位，类似 JConsole 甚至可以在图形界面进行有限的死锁检测。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLockSample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;
  <span class="hljs-keyword">private</span> String first;
  <span class="hljs-keyword">private</span> String second;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DeadLockSample</span><span class="hljs-params">(String name, String first, String second)</span> </span>&#123;
      <span class="hljs-keyword">super</span>(name);
      <span class="hljs-keyword">this</span>.first = first;
      <span class="hljs-keyword">this</span>.second = second;
  &#125;

  <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-keyword">synchronized</span> (first) &#123;
          System.out.println(<span class="hljs-keyword">this</span>.getName() + <span class="hljs-string">" obtained: "</span> + first);
          <span class="hljs-keyword">try</span> &#123;
              Thread.sleep(<span class="hljs-number">1000L</span>);
              <span class="hljs-keyword">synchronized</span> (second) &#123;
                  System.out.println(<span class="hljs-keyword">this</span>.getName() + <span class="hljs-string">" obtained: "</span> + second);
              &#125;
          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
              <span class="hljs-comment">// Do nothing</span>
          &#125;
      &#125;
  &#125;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
      String lockA = <span class="hljs-string">"lockA"</span>;
      String lockB = <span class="hljs-string">"lockB"</span>;
      DeadLockSample t1 = <span class="hljs-keyword">new</span> DeadLockSample(<span class="hljs-string">"Thread1"</span>, lockA, lockB);
      DeadLockSample t2 = <span class="hljs-keyword">new</span> DeadLockSample(<span class="hljs-string">"Thread2"</span>, lockB, lockA);
      t1.start();
      t2.start();
      t1.join();
      t2.join();
  &#125;
&#125;</code></pre>



<h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h2><p>锁可以从不同的角度分类。其中，乐观锁和悲观锁是一种分类方式。</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁就是常说的锁。悲观锁总是认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁又称为“无锁”。乐观锁总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。而一旦多个线程发生冲突，乐观锁通常使用 CAS 来保证线程执行的安全性。由于无锁操作中没有锁的存在，因此不可能出现死锁的情况。</p>
<p>悲观锁多用于”<strong>写多读少</strong>“的环境，避免频繁失败和重试影响性能。乐观锁多用于“<strong>读多写少</strong>“的环境，避免频繁加锁影响性能。</p>
<h2 id="CAS-定义"><a href="#CAS-定义" class="headerlink" title="CAS 定义"></a>CAS 定义</h2><p><strong>比较并交换(compare and swap, CAS)</strong>，是原子操作的一种，可用于在多线程编程中<strong>实现不被打断的数据交换操作</strong>，从而<strong>避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题</strong>。 该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。</p>
<ul>
<li><strong>记录下</strong>某块内存中的旧值；</li>
<li>对旧值<strong>进行一系列的操作</strong>后得到新值；</li>
<li>通过CAS操作将新值与旧值进行交换：<ul>
<li>如果这块内存的值在这期间内没被修改过，则旧值会与内存中的数据相同，这时CAS操作将会成功执行，使内存中的数据变为新值；</li>
<li>如果内存中的值在这期间内被修改过，则一般来说旧值会与内存中的数据不同，这时CAS操作将会失败，新值将不会被写入内存。</li>
</ul>
</li>
</ul>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cas</span><span class="hljs-params">(<span class="hljs-keyword">long</span> *addr, <span class="hljs-keyword">long</span> old, <span class="hljs-keyword">long</span> <span class="hljs-keyword">new</span>)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-comment">/* Executes atomically. */</span>
    <span class="hljs-keyword">if</span>(*addr != old)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    *addr = <span class="hljs-keyword">new</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
&#125;</code></pre>



<h3 id="Java-实现CAS的原理"><a href="#Java-实现CAS的原理" class="headerlink" title="Java 实现CAS的原理"></a>Java 实现CAS的原理</h3><p>CAS 是一种原子操作。在 Java 中，如果一个方法是native的，那 Java 就不负责具体实现它，而是交给底层的JVM使用 C 或者 C++ 实现。在 Java 中，Unsafe 类里面是一些native方法，其中有几个关于 CAS。这些方法都是都是public native的。</p>
<pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapObject</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset,Object expected, Object x)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapInt</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset,<span class="hljs-keyword">int</span> expected,<span class="hljs-keyword">int</span> x)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapLong</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset,<span class="hljs-keyword">long</span> expected,<span class="hljs-keyword">long</span> x)</span></span>;</code></pre>



<p>Unsafe 中对 CAS 的实现使用 C++，它的具体实现和操作系统、CPU都有关系。</p>
<p>Linux的 x86 下主要通过cmpxchgl这个指令在 CPU 级完成CAS操作，但在多处理器情况下必须使用lock指令加锁来完成。</p>
<p>Unsafe类里面还有其它方法用于不同的用途。比如支持线程挂起和恢复的park和unpark， LockSupport类底层就是调用了这两个方法。还有支持反射操作的 allocateInstance() 方法。</p>
<h3 id="CAS-实现原子操作的三个问题"><a href="#CAS-实现原子操作的三个问题" class="headerlink" title="CAS 实现原子操作的三个问题"></a>CAS 实现原子操作的三个问题</h3><h4 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h4><p>ABA问题，就是一个值原来是A，变成了B，又变回了A。这个时候使用CAS是检查不出变化的，但实际上却被更新了两次。</p>
<p>ABA问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。JDK 1.5 开始，JDK 的 atomic 包里提供了一个类AtomicStampedReference 类来解决ABA问题。这个类的 compareAndSet 方法的作用是：</p>
<ul>
<li>首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志；</li>
<li>如果二者都相等，才使用 CAS 设置为新的值和标志。</li>
</ul>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(V   expectedReference,</span></span>
<span class="hljs-function"><span class="hljs-params">                             V   newReference,</span></span>
<span class="hljs-function"><span class="hljs-params">                             <span class="hljs-keyword">int</span> expectedStamp,</span></span>
<span class="hljs-function"><span class="hljs-params">                             <span class="hljs-keyword">int</span> newStamp)</span> </span>&#123;
    Pair&lt;V&gt; current = pair;
    <span class="hljs-keyword">return</span>
        expectedReference == current.reference &amp;&amp;
        expectedStamp == current.stamp &amp;&amp;
        ((newReference == current.reference &amp;&amp;
          newStamp == current.stamp) ||
         casPair(current, Pair.of(newReference, newStamp)));
&#125;</code></pre>



<h4 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h4><p>CAS多与自旋结合。如果 CAS 自旋长时间不成功，CPU 资源的开销很大。</p>
<p>解决思路是让 JVM 支持处理器提供的 <strong>pause 指令</strong>。pause 指令能让自旋失败时 CPU 睡眠一小段时间再继续自旋，从而使得读操作的频率低很多，为解决内存顺序冲突而导致的CPU流水线重排的代价也会小很多。</p>
<h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>竞争锁的失败的线程，并不会真实的在操作系统层面挂起等待，JVM 会让线程做几个空循环（基于预测在不久的将来就能获得），经过若干次循环后，如果可以获得锁，那么进入临界区，如果还不能获得锁，才会真实的将线程在操作系统层面进行挂起。</p>
<p>自旋锁适用场景：自旋锁可以减少线程的阻塞，对于锁竞争不激烈，且占用锁时间非常短的代码块来说，性能有较大的提升，因为自旋的消耗会小于线程阻塞挂起操作的消耗。反之，如果锁的竞争激烈，或者持锁的线程需要长时间占用锁执行同步块，就不适合使用自旋锁，因为自旋锁在获取锁前一直都是占用 CPU 做无用功，线程自旋的消耗大于线程阻塞挂起操作的消耗，造成 CPU 的浪费。</p>
<h5 id="适应自旋锁"><a href="#适应自旋锁" class="headerlink" title="适应自旋锁"></a>适应自旋锁</h5><p>JDK 1.6 引入了更聪明的自旋锁，即自适应自旋锁。自适应意味着自旋的次数不再是固定的，它由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</p>
<p>有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</p>
<h4 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h4><p>CAS可以保证单个共享变量的原子操作，对于多个共享变量，CAS无法保证原子性。</p>
<ul>
<li><p>JDK 1.5 开始提供了 AtomicReference 类，保证对象之间的原子性。所以可以把多个（共享）变量封装进一个对象，然后通过 AtomicReference 类保证引用对象之间的原子性。</p>
</li>
<li><p>使用锁：锁内的临界区代码可以保证只有当前线程能操作；</p>
</li>
</ul>
<h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><p><strong>synchronized 和 volatile 的区别</strong></p>
<ul>
<li>synchronized 关键字解决的是<strong>多个线程之间访问资源的同步性</strong>；</li>
<li><strong>volatile 关键字</strong>是<strong>线程同步</strong>的<strong>轻量级</strong>实现，因为它不会引起线程上下文的切换和调度，所以比 synchronized 的<strong>使用和执行成本会更低</strong>，<strong>性能</strong>比 synchronized 好；</li>
<li>volatile 只能用于<strong>变量</strong>，synchronized 关键字可以修饰<strong>方法以及代码块</strong>；</li>
<li>多线程访问 volatile 关键字<strong>不会发生阻塞</strong>，synchronized 关键字<strong>可能会发生阻塞</strong>；</li>
<li>volatile 关键字能保证<strong>数据的可见性</strong>，但<strong>不能保证数据的原子性</strong>，synchronized 关键字两者都能保证。</li>
</ul>
<p><strong>sleep() 和 wait() 方法异同</strong></p>
<ul>
<li>都可以暂停线程的执行；</li>
<li>最主要的区别在于：<strong>sleep() 方法没有释放锁，而 wait() 方法释放了锁</strong>； </li>
<li>wait() 通常被用于<strong>线程间交互/通信</strong>，sleep() 通常被用于<strong>暂停执行</strong>；</li>
<li>wait() 方法被调用后，线程<strong>不会自动苏醒</strong>，需要别的线程调用同一个对象上的 <strong>notify() 或者 notifyAll() 方法</strong>；sleep() 方法执行完成后，线程会<strong>自动苏醒</strong>。或者可以使用 <strong>wait(long timeout) 超时后线程会自动苏醒</strong>；</li>
</ul>
<p><strong>start() 方法会执行 run()，为什么不直接调用 run() 方法</strong></p>
<ul>
<li>new 一个 Thread，线程进入了新建状态；</li>
<li>调用 start() 方法，会启动一个线程并使线程进入了<strong>就绪状态</strong>，当分配到时间片后就可以开始运行；<ul>
<li>start() 会执行线程的相应<strong>准备工作</strong>，然后自动执行 run() 方法的内容，这是真正的多线程工作；</li>
</ul>
</li>
<li>直接执行 run() 方法，会将 run() 其当成 main 线程下的一个<strong>普通方法</strong>去执行，并不会在某个线程中执行它，所以这并<strong>不是多线程工作</strong>；</li>
</ul>
<p><strong>总结： 调用 start() 方法方可启动线程并使线程进入就绪状态，而 run() 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</strong></p>
<p><strong>AtomicInteger 底层实现原理</strong></p>
<p>AtomicIntger 是对 int 类型的一个封装，提供原子性的访问和更新操作，其原子性操作的实现是基于 CAS（compare-and-swap）技术。</p>
<p><strong>在静态方法和非静态方法上加 synchronized的区别</strong></p>
<ul>
<li><p>synchronized修饰非静态方法，实际上是对调用该方法的对象加锁，俗称“对象锁”；</p>
<ul>
<li><p>情况1：同一个对象在两个线程中分别访问该对象的两个同步方法</p>
<ul>
<li>结果：会产生互斥；</li>
<li>解释：因为锁针对的是对象，当对象调用一个synchronized方法时，其他同步方法需要等待其执行结束并释放锁后才能执行。 </li>
</ul>
</li>
<li><p>情况2：不同对象在两个线程中调用同一个同步方法；</p>
<ul>
<li>结果：不会产生互斥；</li>
<li>解释：因为是两个对象，锁针对的是对象，并不是方法，所以可以并发执行，不会互斥。形象的来说就是因为我们每个线程在调用方法的时候都是new 一个对象，那么就会出现两个空间，两把钥匙， </li>
</ul>
</li>
</ul>
</li>
<li><p>synchronized修饰静态方法，实际上是对该类对象加锁，俗称“类锁”</p>
<ul>
<li><p>情况1：用类直接在两个线程中调用两个不同的同步方法</p>
<ul>
<li><p>结果：会产生互斥；</p>
</li>
<li><p>解释：因为对静态对象加锁实际上对类（.class）加锁，类对象只有一个，可以理解为任何时候都只有一个空间，里面有N个房间，一把锁，因此房间（同步方法）之间一定是互斥的；</p>
<p>注：上述情况和用单例模式声明一个对象来调用非静态方法的情况是一样的，因为永远就只有这一个对象。所以访问同步方法之间一定是互斥的。 </p>
</li>
</ul>
</li>
<li><p>情况2：用一个类的静态对象在两个线程中调用静态方法或非静态方法；</p>
<ul>
<li>结果：会产生互斥；</li>
<li>解释：因为是一个对象调用，同上。</li>
</ul>
</li>
<li><p>情况3：一个对象在两个线程中分别调用一个静态同步方法和一个非静态同步方法</p>
<ul>
<li>结果：不会产生互斥；</li>
<li>解释：因为虽然是一个对象调用，但是两个方法的锁类型不同，调用的静态方法实际上是类对象在调用，即这两个方法产生的并不是同一个对象锁，因此不会互斥，会并发执行；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>JDK1.8 源码</p>
<p>Java 并发编程实战</p>
<p><a href="https://betterzero.net/2020/07/22/Java%20%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/%3Chttps://time.geekbang.org/column/intro/100006701%3E/">极客时间 - Java精讲</a></p>
<p><a href="https://www.infoq.cn/profile/1277812/publish" target="_blank" rel="noopener">方腾飞InfoQ并发系列文章</a></p>
<p><a href="https://redspider.gitbook.io/concurrent/readme" target="_blank" rel="noopener">深入浅出Java多线程</a></p>
<p><a href="http://www.51gjie.com/java/717.html" target="_blank" rel="noopener">javaschool</a></p>
<p><a href="https://blog.csdn.net/chenssy/article/details/54883355" target="_blank" rel="noopener">深入分析synchronized的实现原理</a></p>
<p><a href="https://xiaomi-info.github.io/2020/03/24/synchronized/" target="_blank" rel="noopener">synchronized 实现原理 - 小米技术团队</a></p>
<p><a href="https://www.cnblogs.com/javaminer/p/3889023.html" target="_blank" rel="noopener">JVM内部细节之一：synchronized关键字及实现细节（轻量级锁Lightweight Locking）</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1497826" target="_blank" rel="noopener">一次Java线程池误用引发的线上血案和总结</a> </p>
<p><a href="https://blog.csdn.net/u014209205/article/details/80598209" target="_blank" rel="noopener">JAVA Future类详解</a></p>
<p><a href="https://www.infoq.cn/article/ftf-java-volatile/" target="_blank" rel="noopener">聊聊并发（一）—深入分析 Volatile 的实现原理</a></p>
<p><a href="https://blog.csdn.net/a525390802/article/details/80509457" target="_blank" rel="noopener">JVM之内存模型JMM中本地内存的理解</a></p>
<p><a href="https://juejin.im/post/6844903586984361992#heading-1" target="_blank" rel="noopener">ThreadLocal就是这么简单</a></p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Java/">Java</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/07/22/JVM%20%E5%9F%BA%E7%A1%80/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JVM 基础</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/07/22/Java%20%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/">
                        <span class="hidden-mobile">Java 常用集合</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    
  <!-- 备案信息 -->
  <div class="beian">
    <a href="http://beian.miit.gov.cn/" target="_blank"
       rel="nofollow noopener"></a>
    
  </div>


    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 2,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  














</body>
</html>
