<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="Edgecloudsim Java Algorithm">
  <meta name="author" content="">
  <meta name="keywords" content="">
  <title>计算机网络基础 - 九流人</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 60vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>九流人</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bg/astronaut.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
                计算机网络基础
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-07-22 18:19">
      2020年7月22日 晚上
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      17.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      187
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：2020年9月10日 凌晨
                
              </p>
            
            <article class="markdown-body">
              <p>本文介绍计算机网络基础。</p>
<a id="more"></a>



<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文主要在 <a href="https://krahets.gitee.io/" target="_blank" rel="noopener">Krahets’s Blog</a> 的 <a href="https://krahets.gitee.io/views/computer-network/2019-09-18-post-computer-network.html" target="_blank" rel="noopener">计算机网络学习笔记</a> 基础上，增加了应用层的部分内容，结合自己的理解，形成的一个版本。</p>
<h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><h2 id="具有五层协议的体系结构"><a href="#具有五层协议的体系结构" class="headerlink" title="具有五层协议的体系结构"></a>具有五层协议的体系结构</h2><ul>
<li>OSI 七层协议体系概念清楚，理论也较完整，但它既复杂又不实用；</li>
<li>五层协议体系结构综合 OSI 和 TCP/IP 优点，简洁又能将概念阐释清楚。</li>
</ul>
<p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.jpg" srcset="/img/loading.gif" alt=""></p>
<ul>
<li><p><strong>应用层</strong></p>
<ul>
<li><strong>任务：</strong> 通过应用进程间的交互来完成特定网络应用。应用层定义的是应用进程间通信和交互的规则；</li>
<li><strong>协议：</strong> 域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等；</li>
<li><strong>数据单元：</strong> 应用层交互的数据单元称为<strong>报文(message)</strong>。</li>
</ul>
</li>
<li><p><strong>运输层</strong></p>
<ul>
<li><strong>任务</strong>：负责向<strong>两台主机中进程间</strong>的通信提供<strong>通用数据传输</strong>服务。运输层有复用和分用的功能，<strong>复用</strong>就是多个应用层进程可同时使用下面运输层的服务，<strong>分用</strong>是运输层把收到的信息分别交付到上面应用层的相应进程；</li>
<li><strong>协议</strong>：<ul>
<li><strong>传输控制协议 TCP</strong> (Transmission Control Protocol) — 提供面向连接、可靠的数据传输服务，其数据传输单位是 <strong>报文段</strong>；</li>
<li><strong>用户数据报协议 UDP</strong> (User Datagram Protocol) — 提供无连接、尽最大努力的数据传输服务（不保证数据传输可靠性），其数据传输单位是<strong>用户数据报</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>网络层</strong> </p>
<ul>
<li><strong>任务：</strong> 负责为分组交换网上<strong>不同主机</strong>提供通信服务。互联网是由大量<strong>异构网络</strong>通过<strong>路由器</strong>相互连接起来的；</li>
<li><strong>协议：</strong> 无连接的网际协议 IP(Internet Protocol)；</li>
<li><strong>数据单元：</strong> 分组或 IP 数据报。</li>
</ul>
</li>
<li><p><strong>数据链路层</strong> (data link layer)</p>
<ul>
<li><strong>任务：</strong> 两台主机之间的数据传输，总是在一段段的链路上传送的。链路层将网络层交下来的数据报<strong>组装成帧</strong>，并在两个相邻节点间传输。每一帧包括数据和必要的控制信息（同步信息、地址信息、<strong>差错控制</strong>等）；</li>
<li><strong>数据单元：</strong> 帧。</li>
</ul>
</li>
</ul>
<ol>
<li><p><strong>物理层</strong></p>
<ul>
<li><p><strong>任务</strong>：发送方发送 1 或 0 ，接收方应当接收到对应数字。因此物理层要考虑用多大电压代表 1 和 0；物理层还要确定连接电缆的插头应当有多少根引脚以及其连接方式；</p>
<blockquote>
<p><strong>注意：</strong> 传递信息所利用的物理媒体，如双绞线、同轴电缆、光缆、无线信道等，并不在物理层协议内，而是在物理层下面。</p>
</blockquote>
</li>
<li><p><strong>数据单元：</strong> 比特。</p>
</li>
</ul>
</li>
</ol>
<p><img src="%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%90%84%E5%B1%82%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E9%80%92%E8%BF%87%E7%A8%8B.jpg" srcset="/img/loading.gif" alt=""></p>
<h2 id="TCP-IP-体系结构"><a href="#TCP-IP-体系结构" class="headerlink" title="TCP/IP 体系结构"></a>TCP/IP 体系结构</h2><ul>
<li><p>实际上，现在的互联网使用的 TCP/IP 体系结构有时已经演变成下图所示那样，即某些应用程序可以<strong>直接使用 IP 层</strong>，或甚至<strong>直接使用最下面的网络接口层</strong>；</p>
<p><img src="TCPIP%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p><strong>TCP/IP 协议</strong> 可以为各式<strong>各样的应用程序</strong>提供服务，同时也允许 IP 协议在<strong>各式各样的网络</strong>构成的互联网上运行。</p>
<p><img src="%E6%B2%99%E6%BC%8F%E8%AE%A1%E6%97%B6%E5%99%A8%E5%BD%A2%E7%8A%B6%E7%9A%84TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F%E7%A4%BA%E6%84%8F.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
</ul>
<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h2><p>封装成帧、透明传输、差错检测</p>
<h3 id="封装成帧："><a href="#封装成帧：" class="headerlink" title="封装成帧："></a>封装成帧：</h3><ul>
<li>在一段数据分别添加首部和尾部，作用是<strong>帧定界</strong>，以便接收方定位数据边界；</li>
<li>每种链路层协议规定了帧的数据部分长度上限——*<em>最大长度单元 MTU *</em>。</li>
</ul>
<p><img src="%E7%94%A8%E5%B8%A7%E9%A6%96%E9%83%A8%E5%92%8C%E5%B8%A7%E5%B0%BE%E9%83%A8%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7.jpg" srcset="/img/loading.gif" alt=""></p>
<h3 id="透明传输："><a href="#透明传输：" class="headerlink" title="透明传输："></a>透明传输：</h3><blockquote>
<p>表示无论什么比特组合的数据，都能按照原样没有差错的通过这个数据链路层正确传输。</p>
</blockquote>
<ul>
<li>当数据是非 ASCII 码文件时，数据链路层可能会在数据中 <strong>错误地找到帧的边界</strong> SOH/EOT ，此时不满足透明传输；</li>
</ul>
<p><img src="%E6%95%B0%E6%8D%AE%E9%83%A8%E5%88%86%E6%81%B0%E5%A5%BD%E5%87%BA%E7%8E%B0%E4%B8%8EEOT%E4%B8%80%E6%A0%B7%E7%9A%84%E4%BB%A3%E7%A0%81.jpg" srcset="/img/loading.gif" alt=""></p>
<ul>
<li><strong>字节填充法：</strong> 在数据中出现 SOH/EOT/ESC 前加入一个转义字符 ESC ，接收端把数据送往网络层之前删除 ESC 转义字符。这样就可以解决错误帧边界问题。</li>
</ul>
<p><img src="%E7%94%A8%E5%AD%97%E8%8A%82%E5%A1%AB%E5%85%85%E6%B3%95%E8%A7%A3%E5%86%B3%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93%E9%97%AE%E9%A2%98.jpg" srcset="/img/loading.gif" alt=""></p>
<h3 id="差错检测："><a href="#差错检测：" class="headerlink" title="差错检测："></a>差错检测：</h3><blockquote>
<p>分为比特差错和传输差错。</p>
</blockquote>
<ul>
<li><strong>循环冗余检验 CRC ——比特差错</strong>：在长度为k的数据 M 后加 n 位冗余码，一共发 (k+n) 位；</li>
<li><strong>计算方法</strong>：在M后添加 n 个 0 ，得到的 (k+n) 位数除以双方事先商定的 (n+1) 位除数 P ，得到余数 R ，作为冗余码拼接在数据 M 后发送出去。如果传输过程中无差错，经过 CRC 检验后的余数R肯定是 0；<ul>
<li><strong>FCS 和 CRC 区别</strong>：CRC是一种检错方法，而 FCS 是添加在数据后面的冗余码。检错方法可以选择 CRC 之外的方法。</li>
</ul>
</li>
</ul>
<p><img src="%E8%AF%B4%E6%98%8E%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A3%80%E9%AA%8C%E5%8E%9F%E7%90%86%E7%9A%84%E4%BE%8B%E5%AD%90.jpg" srcset="/img/loading.gif" alt=""></p>
<ul>
<li><strong>帧编号、确认、重传机制——传输差错</strong> ：可靠传输指的是数据链路层发送端发送什么，接收端就接收到什么。<strong>帧丢失、帧重复、帧失序</strong>属于传输差错。<ul>
<li>对于通信质量良好的传输链路，改正传输差错的任务由上层协议（如TCP协议）完成；</li>
<li>对于通信质量较差的传输链路，数据链路层使用确认和重传机制，向上层提供可靠传输服务，可以提升传输效率。</li>
</ul>
</li>
</ul>
<p><img src="%E5%B8%A7%E4%B8%A2%E5%A4%B1%E5%B8%A7%E9%87%8D%E5%A4%8D%E5%B8%A7%E5%A4%B1%E5%BA%8F.jpg" srcset="/img/loading.gif" alt=""></p>
<h2 id="点对点协议-PPP"><a href="#点对点协议-PPP" class="headerlink" title="点对点协议 PPP"></a>点对点协议 PPP</h2><h3 id="PPP-协议特点"><a href="#PPP-协议特点" class="headerlink" title="PPP 协议特点"></a>PPP 协议特点</h3><ul>
<li>简单、封装成帧 + MTU 、透明性、差错检测；</li>
<li>支持多种网络层协议、多种类型链路、自动检测连接状态。</li>
</ul>
<h3 id="PPP-协议组成"><a href="#PPP-协议组成" class="headerlink" title="PPP 协议组成"></a>PPP 协议组成</h3><ul>
<li><p>将IP数据报封装到串行链路的方法；</p>
</li>
<li><p>用来建立、配置和测试数据链路链接的<strong>链路控制协议 LCP</strong>；</p>
</li>
<li><p>一套<strong>网络控制协议 NCP</strong>。</p>
</li>
</ul>
<h3 id="PPP-协议帧格式"><a href="#PPP-协议帧格式" class="headerlink" title="PPP 协议帧格式"></a>PPP 协议帧格式</h3><ul>
<li><strong>各字段意义：</strong><ul>
<li><strong>标志字段 F</strong>：首部和尾部字段都为 0x7E ，标志一个帧的开始或结束，标志字段是 PPP 帧定界符；</li>
<li><strong>地址字段 A 和控制字段 C</strong>：规定为 0xFF 和 0x03 ，至今没有实际定义；</li>
<li><strong>协议字段</strong>：0x0021 对应 IP 数据报，0xC021 对应链路控制协议 LCP 数据，0x8021 对应网络层控制数据。</li>
</ul>
</li>
</ul>
<p><img src="PPP%E5%B8%A7%E7%9A%84%E6%A0%BC%E5%BC%8F.jpg" srcset="/img/loading.gif" alt=""></p>
<ol>
<li><strong>零比特填充：</strong><ul>
<li><strong>发送端</strong>：发现有 5 个连续 1 ，就立即填入一个 0 ，这样可以保证信息字段中不会出现 6 个连续 1；</li>
<li><strong>接收端</strong>：每当发现 5 个连续 1 时，就把这 5 个连续 1 后一个 0 删除，还原成原来的信息比特流，保证了透明传输。</li>
</ul>
</li>
</ol>
<p><img src="%E9%9B%B6%E6%AF%94%E7%89%B9%E7%9A%84%E5%A1%AB%E5%85%85%E4%B8%8E%E5%88%A0%E9%99%A4.jpg" srcset="/img/loading.gif" alt=""></p>
<h3 id="PPP协议工作状态"><a href="#PPP协议工作状态" class="headerlink" title="PPP协议工作状态"></a>PPP协议工作状态</h3><ol>
<li>PPP链路起始终止状态永远是<strong>链路静止</strong>状态；</li>
<li>PC通过调制调节器呼叫路由器，建立物理层连接后，PPP就进入<strong>链路建立</strong>状态；</li>
<li>LCP开始协商一些配置选项，包括链路最大帧长，不使用的PPP帧中的地址和控制字段；协商结束后就进入<strong>鉴别</strong>状态；</li>
<li>经过口令鉴别协议 PAP 或更复杂的口令握手鉴别协议 CHAP，若鉴别成功，则进入<strong>网络层协议</strong>状态；</li>
<li>PPP 链路两端的网络控制协议 NCP 根绝网络层不同协议互相交换网络层特定的网络控制分组。若在 PPP 链路上运行的是 IP 协议，则要使用 <strong>IP 控制协议 IPCP</strong> 。网络层配置完毕后，进入可数据通信的<strong>链路打开</strong>状态；</li>
<li>数据传输结束后，链路一端发出<strong>终止请求</strong>，在收到对方发来的<strong>终止确认</strong>后，转到<strong>链路终止</strong>状态。如果链路出现故障，也会从链路打开转到链路终止状态。当调制调节器载波终止后，回到<strong>链路静止</strong>状态。</li>
</ol>
<p><img src="PPP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%8A%B6%E6%80%81%E5%9B%BE.jpg" srcset="/img/loading.gif" alt=""></p>
<h2 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h2><h3 id="以太网的-MAC-层"><a href="#以太网的-MAC-层" class="headerlink" title="以太网的 MAC 层"></a>以太网的 MAC 层</h3><ul>
<li><p><strong>MAC 层的硬件地址</strong></p>
<ul>
<li>又称物理地址或 MAC 地址（因为这种地址用在 MAC 帧中）；</li>
<li>指局域网上每一台计算机中固化在适配器的 ROM 中的 48 位地址。</li>
</ul>
</li>
<li><p><strong>适配器过滤功能：</strong> 适配器从网络上收到一个 MAC 帧，先用硬件检查帧中的目的地址，若是本站的则收下，然后再做其他处理，否则就丢弃。</p>
<ul>
<li><strong>单播：</strong> 收到的帧的 MAC 地址与本站地址相同；</li>
<li><strong>广播：</strong> 发送给本局域网上所有站点的帧（全 1 地址）；</li>
<li><strong>多播：</strong> 发送给本局域网上一部分站点的帧。</li>
</ul>
</li>
</ul>
<h3 id="MAC帧的格式"><a href="#MAC帧的格式" class="headerlink" title="MAC帧的格式"></a>MAC帧的格式</h3><table>
<thead>
<tr>
<th align="center">位置</th>
<th align="center">名称</th>
<th align="center">长度</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">头部</td>
<td align="center">目的地址</td>
<td align="center">6 字节</td>
<td align="center">48 位长地址</td>
</tr>
<tr>
<td align="center">头部</td>
<td align="center">源地址</td>
<td align="center">6 字节</td>
<td align="center">48 位长地址</td>
</tr>
<tr>
<td align="center">头部</td>
<td align="center">类型字段</td>
<td align="center">2 字节</td>
<td align="center">标志上一层使用的是什么协议</td>
</tr>
<tr>
<td align="center">尾部</td>
<td align="center">帧检验序列 FCS</td>
<td align="center">4 字节</td>
<td align="center">使用 CRC 检验</td>
</tr>
</tbody></table>
<p><img src="%E4%BB%A5%E5%A4%AA%E7%BD%91V2%E7%9A%84MAC%E5%B8%A7%E6%A0%BC%E5%BC%8F.jpg" srcset="/img/loading.gif" alt=""></p>
<ul>
<li>实际传送比 MAC 帧还<strong>多 8 个字节</strong>。这是因为当一个站刚开始接受 MAC 帧时，适配器时钟尚未与比特流同步，则导致MAC帧最前面若干位无法接收，结果使 MAC 帧失效。<ul>
<li><strong>前 7 个字节 —前同步码：</strong> 使接收端适配器调整时钟频率，使它和发送端时钟同步，实现“位同步”（比特同步）；</li>
<li><strong>后 1 个字节 —帧开始定界符：</strong> 定义为 10101011。</li>
</ul>
</li>
</ul>
<h2 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h2><h3 id="在物理层扩展以太网"><a href="#在物理层扩展以太网" class="headerlink" title="在物理层扩展以太网"></a>在物理层扩展以太网</h3><ul>
<li>使用多个<strong>集线器</strong>，连接成覆盖更大范围的多级星型结构的以太网。</li>
</ul>
<p><img src="%E7%94%A8%E5%A4%9A%E4%B8%AA%E9%9B%86%E7%BA%BF%E5%99%A8%E8%BF%9E%E6%8E%A5%E6%88%90%E6%9B%B4%E5%A4%A7%E7%9A%84%E4%BB%A5%E5%A4%AA%E7%BD%91.jpg" srcset="/img/loading.gif" alt=""></p>
<ul>
<li>主机和集线器之间<strong>扩展距离</strong>的一种简单方法就是使用<strong>光纤</strong>。<ul>
<li>光纤作用是执行<strong>电信号</strong>和<strong>光信号</strong>转换；</li>
<li>光纤时延很小，带宽很宽。</li>
</ul>
</li>
</ul>
<p><img src="%E4%B8%BB%E6%9C%BA%E4%BD%BF%E7%94%A8%E5%85%89%E7%BA%A4%E5%92%8C%E4%B8%80%E5%AF%B9%E5%85%89%E7%BA%A4%E8%B0%83%E5%88%B6%E8%A7%A3%E8%B0%83%E5%99%A8%E8%BF%9E%E6%8E%A5%E5%88%B0%E9%9B%86%E7%BA%BF%E5%99%A8.jpg" srcset="/img/loading.gif" alt=""></p>
<h3 id="在数据链路层扩展以太网"><a href="#在数据链路层扩展以太网" class="headerlink" title="在数据链路层扩展以太网"></a>在数据链路层扩展以太网</h3><blockquote>
<p>交换式集线器1990年问世，常称为以太网<strong>交换机</strong>，工作在数据链路层。</p>
</blockquote>
<ul>
<li><p>以太网交换机特点：</p>
<ul>
<li>实质上就是一个多接口<strong>网桥</strong>；</li>
<li>相互通信的主机都是<strong>独占</strong>传输媒体，无碰撞地传输数据；（多个用户独占而不是和其他网络用户共享传输媒体带宽，对于 10Mbit/s 的共享式以太网，10 个接口的交换机总容量为 100Mbit/s）；</li>
<li>内部的<strong>帧交换表</strong>（又称<strong>地址表</strong>）使通过<strong>自学习算法</strong>自动地逐渐建立起来的。</li>
</ul>
</li>
<li><p>以太网交换机的<strong>自学习</strong>功能：</p>
<ul>
<li><p>接收到帧时，将帧的<strong>源地址—接口</strong>记录在<strong>交换表</strong>中；</p>
</li>
<li><p>地址表中找不到对应目的地址时，则<strong>广播</strong>此帧，只有对应主机会收下此帧，其余主机会丢弃（过滤）；</p>
</li>
<li><p>经过多次互相发送帧，最终交换表将记录所有主机<strong>源地址—接口</strong>。</p>
<p><img src="%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BA%A4%E6%8D%A2%E8%A1%A8.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p>使用交换机组网时，往往会增加一些冗余链路。可能会形成<strong>环</strong>导致帧在网络的某个环路中<strong>无限兜圈子</strong>；</p>
</li>
<li><p>为了解决此问题，IEEE 的 802.1D 标准制定了<strong>生成树协议 STP **。可以在不改变网络实际拓扑结构下，在逻辑上切断某些链路，使得所有主机间的路径是</strong>无环路的树状结构**。 </p>
<p><img src="%E5%9C%A8%E4%B8%A4%E4%B8%AA%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%B9%8B%E9%97%B4%E5%85%9C%E5%9C%88%E5%AD%90%E7%9A%84%E5%B8%A7.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
</ul>
</li>
</ul>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h2><blockquote>
<p>网络层应该向运输层提供怎样的服务<strong>面向连接</strong>还是<strong>无连接</strong>曾引起长期争论。争论焦点：可靠交付应当由谁负责？网络还是端系统？</p>
</blockquote>
<ol>
<li><strong>思路一：</strong> 计算机应该仿照打电话使用的面向连接的通信方式。先建立连接，预留双方通信所需的一切网络资源，然后双方沿着已建立的虚电路发送分组；</li>
<li><strong>思路二：</strong> 与电话不同的是，计算机网络的端系统是有智能的计算机，有很强的差错处理能力，因此网络层无需建立链接；</li>
<li><strong>互联网采用的设计：</strong> 网络层只向上提供<strong>简单灵活、无连接、尽最大努力交付</strong>的数据报服务。<ul>
<li>网络层不提供服务质量承诺，有可能出现数据出错、丢失、重复和失序；</li>
<li>如果需要可靠传输，则由主机中的运输层负责（包括差错处理、流量控制等）；</li>
<li><strong>优点：</strong> 网络造价大大降低，运行方式灵活，能够适应多种应用。</li>
</ul>
</li>
</ol>
<p><img src="%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1.jpg" srcset="/img/loading.gif" alt=""></p>
<h2 id="网际协议-IP（IPv4）"><a href="#网际协议-IP（IPv4）" class="headerlink" title="网际协议 IP（IPv4）"></a>网际协议 IP（IPv4）</h2><ul>
<li>与 IP 协议配套使用的 3 个协议：<ul>
<li>地址解析协议 ARP</li>
<li>网际控制报文协议 ICMP</li>
<li>网际组管理协议 IGMP</li>
</ul>
</li>
</ul>
<p><img src="%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AEIP%E5%8F%8A%E5%85%B6%E9%85%8D%E5%A5%97%E5%8D%8F%E8%AE%AE.jpg" srcset="/img/loading.gif" alt=""></p>
<h3 id="分类的-IP-地址"><a href="#分类的-IP-地址" class="headerlink" title="分类的 IP 地址"></a>分类的 IP 地址</h3><ul>
<li><p><strong>IP 地址编址方法</strong>共经过 3 个历史阶段：</p>
<ol>
<li>分类的IP地址（1981 年）</li>
<li>子网的划分（1985 年）</li>
<li>构成超网（1993 年）</li>
</ol>
</li>
<li><p><strong>两级 IP 地址：</strong></p>
<ol>
<li>第一个字段是<strong>网络号</strong>，标志主机（或路由器）连接到的网络；</li>
<li>第二个字段是<strong>主机号</strong>，标志该主机（或路由器）。</li>
</ol>
<p><img src="IP%E5%9C%B0%E5%9D%80.jpg" srcset="/img/loading.gif" alt=""></p>
<ul>
<li>一个 IP 地址在<strong>整个互联网范围是唯一</strong>的。</li>
</ul>
</li>
<li><p><strong>各类 IP 地址：</strong></p>
<ul>
<li><strong>A/B/C 类地址</strong>网络号字段分别为 1/2/3 字节长，而在网络号最前面有 1-3 位的<strong>类别位</strong>，分别规定为 0/10/110；</li>
<li><strong>D 类地址</strong>用于多播（一对多通信）；</li>
<li><strong>E 类地址</strong>保留为以后用。</li>
</ul>
<p><img src="IP%E5%9C%B0%E5%9D%80%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8F%B7%E5%AD%97%E6%AE%B5%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%8F%B7%E5%AD%97%E6%AE%B5.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p><strong>常用的三种类别 IP 地址：</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">网络号字段</th>
<th align="center">首固定位</th>
<th align="center">可指派网络号数量</th>
<th align="center">保留地址</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A类</td>
<td align="center">占 1 字节</td>
<td align="center">0</td>
<td align="center">2^7 - 2</td>
<td align="center">00000000 本网络；01111111 软件环回测试</td>
</tr>
<tr>
<td align="center">B类</td>
<td align="center">占 2 字节</td>
<td align="center">10</td>
<td align="center">2^14 - 1</td>
<td align="center">128.0.0.0 不指派</td>
</tr>
<tr>
<td align="center">C类</td>
<td align="center">占 3 字节</td>
<td align="center">110</td>
<td align="center">2^21 - 1</td>
<td align="center">192.0.0.0 不指派</td>
</tr>
</tbody></table>
<ul>
<li>点分十进制记法：<ul>
<li>每 8 位插入一个 ‘.’ ，方便书写；</li>
</ul>
</li>
</ul>
<p><img src="%E9%87%87%E7%94%A8%E7%82%B9%E5%88%86%E5%8D%81%E8%BF%9B%E5%88%B6%E6%B3%95%E8%83%BD%E5%A4%9F%E6%8F%90%E9%AB%98%E5%8F%AF%E8%AF%BB%E6%80%A7.jpg" srcset="/img/loading.gif" alt=""></p>
<h3 id="IP-地址与硬件地址"><a href="#IP-地址与硬件地址" class="headerlink" title="IP 地址与硬件地址"></a>IP 地址与硬件地址</h3><ul>
<li><p><strong>硬件地址与 IP 地址区别：</strong> 物理地址是数据链路层和物理层使用的地址， IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。</p>
<ul>
<li>在 IP 层抽象的互联网上，只能看到 IP 数据报。经过路由多次转发的 IP 数据报首部中的源地址和目的地址始终分别为 IP1 和 IP2 。路由器只根据目的地址进行路由选择；</li>
<li>在局域网的链路层，只能看见 MAC 帧。在不同的硬件和网络上传送时， MAC 帧首部的源地址和目的地址（硬件地址）会发生变化。</li>
</ul>
<p><img src="IP%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8C%BA%E5%88%AB.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
</ul>
<h3 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议 ARP"></a>地址解析协议 ARP</h3><ul>
<li><p><strong>APR 协议作用：</strong> 已经知道一个机器的 <strong>IP 地址</strong>，需要找出对应的<strong>硬件地址</strong>。</p>
<ul>
<li><strong>RARP 协议</strong>：现在的 DHCP 协议包含逆地址解析协议功能，即从<strong>硬件地址</strong>找出其 <strong>IP 地址</strong>。</li>
</ul>
</li>
<li><p><strong>ARP 协议工作原理：</strong> 网络层使用 IP 地址，但实际网络链路上传送数据帧时，最终必须使用该网络的硬件地址。ARP 解决方法是在<strong>主机 ARP 高速缓存</strong> 中存放一个从 IP 地址到硬件地址的映射表，并实时动态更新（新增或超时删除）。</p>
<ul>
<li>当主机 A 要向主机 B 发送 IP 数据报时，就在其 ARP 高速缓存中查看有无主机 B 的 IP 地址，如有就查找并写入 MAC 帧，并传输。</li>
<li>有可能查不到主机 B 的 IP 地址，可能主机 B 刚入网，可能主机 A 刚加电（高速缓存为空）。在这种情况下，主机 A 就自动运行 ARP，通过广播请求分组找出主机 B 的硬件地址。</li>
</ul>
</li>
<li><p><strong>ARP 协议工作流程：</strong></p>
<ol>
<li>主机 A 在本局域网上发送一个 ARP 请求分组，在本局域网上所有主机上运行的 ARP 进程都收到此请求分组。</li>
<li>主机 B 收下这个 ARP 请求，并向主机 A 发送响应分组（普通的单播，发送给主机 A ）。同时，把请求分组里 A 的 IP 地址到硬件地址的映射写入主机 B 的 ARP 高速缓存中。</li>
<li>主机 A 收到主机 B 的响应分组后，就在 ARP 高速缓存中写入主机 B 的 IP 地址到硬件地址的映射。</li>
</ol>
<p><img src="%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AEARP%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p><strong>ARP生存时间：</strong> 超过生存时间（例如 10 ~ 20 分钟）的项目从高速缓存中删掉。这样如果 B 更换了设备， A 无法找到原主机 B ，但过了一段时间， A 的 ARP 高速缓存中已经删除了 B 原先硬件地址，于是 A 重新广播发送 ARP请求分组，找到新的 B 硬件地址。</p>
</li>
</ul>
<h3 id="IP-数据报的格式"><a href="#IP-数据报的格式" class="headerlink" title="IP 数据报的格式"></a>IP 数据报的格式</h3><p><img src="IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E6%A0%BC%E5%BC%8F.png" srcset="/img/loading.gif" alt=""></p>
<ol>
<li><p><strong>首部固定字段</strong></p>
<ol>
<li><p><strong>版本</strong>： 占 4 位；指 IP 协议版本。通信双方使用的 IP 协议版本需一致。</p>
</li>
<li><p><strong>首部长度</strong>： 占 4 位；单位是 32 位字（4 字节）。</p>
</li>
<li><p><strong>区分服务</strong>： 占 8 位；只有在使用区分服务时才使用，一般情况不使用。</p>
</li>
<li><p><strong>总长度</strong>：占 16 位；指首部和数据长度之和；单位为字节，因此数据报最大长度为 2^{16}-1=65536216−1=65536 字节。</p>
<ul>
<li>数据链路层规定了<strong>数据帧中数据字段的最大长度 MTU</strong> ，最常用的以太网规定 MTU = 1500 字节，若长度超过 MTU 值，就必须把数据报分片处理。</li>
<li>虽然尽可能长的 IP 数据报会使传输效率变高（首部长度占比小），但数据报短路由器转发速度也更快。</li>
</ul>
</li>
<li><p><strong>标识</strong>：占 16 位。 每产生一个 IP 数据报，计数器+1。</p>
<ul>
<li>这个标识并不是序号（网络层不负责按序接收）；</li>
<li>在由于长度超过 MTU 而被分片时，标识字段值被复制到所有分片的标识字段，使各数据报片最后能正确地组装成原来的数据报。</li>
</ul>
</li>
<li><p><strong>标志</strong>：占 3 位，目前仅前 2 位有意义。</p>
<ul>
<li>最低位记为 MF (More Fragment) ，MF = 1 表示后面“还有分片”数据报，MF = 0 表示这是若干数据报片中的最后一个。</li>
<li>中间一位记为 DF (Don’t Fragment) ， DF = 1 表示不能分片，DF = 0 才允许分片。</li>
</ul>
</li>
<li><p><strong>片偏移</strong>：占 13 位；表示数据报在分片后，某片在原分组中的相对位置；单位是 8 字节。每个分片的长度一定是 8 字节（64 位）的整数倍。 </p>
<p><img src="%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E5%88%86%E7%89%87%E4%B8%BE%E4%BE%8B.jpg" srcset="/img/loading.gif" alt=""> </p>
<p><img src="IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E9%A6%96%E9%83%A8%E4%B8%AD%E4%B8%8E%E5%88%86%E7%89%87%E6%9C%89%E5%85%B3%E7%9A%84%E5%AD%97%E6%AE%B5.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p><strong>生存时间（TTL）</strong>：占 8 位；表示数据报在网络中的寿命。防止数据报在互联网中无限制兜圈子。</p>
<ul>
<li>最初设计 TTL 以秒为单位，消耗时间小于 1s 则将 TTL 减 1 。</li>
<li>目前路由器处理数据报时间一般远远小于 1s ，后来 TTL 字段功能改为<strong>“跳数限制”</strong>，路由器每次转发数据之前把 TTL 减 1 ，当 TTL = 0 就丢失这个数据报。</li>
<li>数据报能在互联网中经过路由器的最大数值是 255(2^8 - 128−1)。若设置 TTL = 1 ，则表示此数据报只能在本局域网中传送。</li>
</ul>
</li>
<li><p><strong>协议</strong>： 占 8 位；表示此数据报中携带的数据使用何种协议，以便接收方主机 IP 层直到应将数据上交给哪个协议处理。</p>
<p><img src="%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8D%8F%E8%AE%AE%E5%92%8C%E7%9B%B8%E5%BA%94%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%AD%97%E6%AE%B5%E5%80%BC.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p><strong>首部校验和</strong>：占 16 位；只检验数据报的首部，不包括数据部分（减少计算量）。</p>
<ul>
<li><p>检验和不采用复杂的 CRC 检验，而换做以下简单方法：</p>
<ol>
<li><p>先把 IP 数据报划分为许多 16 位字的序列，并把检验和字段置零；</p>
</li>
<li><p>用反码算术运算把所有 16 位字相加，将和的反码写入检验和字段；</p>
<blockquote>
<p><strong>反码算术运算：</strong> 若最高位相加产生进位，则最后得到的结果再加 1 。</p>
</blockquote>
</li>
<li><p>接收方收到数据报后，将首部所有的 16 位字使用<strong>反码算数运算</strong>相加，将得到的<strong>和取反码</strong>，若首部未发生任何变化，则结果必为 0 ；若结果不为 0 ，则认为首部出现差错，将数据报丢弃。</p>
<p><img src="IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E9%A6%96%E9%83%A8%E6%A3%80%E9%AA%8C%E5%92%8C%E7%9A%84%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>源地址：</strong> 占 32 位；</p>
</li>
<li><p><strong>目的地址：</strong> 占 32 位。</p>
</li>
</ol>
</li>
<li><p><strong>首部可变部分</strong></p>
<ul>
<li>IP 数据报首部的可变部分就是一个<strong>选项字段</strong>，用来支持<strong>排错、测量、安全措施</strong>等。</li>
<li>长度 1 - 40 字节，取决于选择的项目。</li>
<li>可变部分是用来增加 IP 数据报的功能，实际上这些选项很少被使用。很多路由器都不考虑 IP 首部的选项字段，因此新的 IP 版本 <strong>IPv6 就将 IP 数据报的首部长度做成固定的</strong>。</li>
</ul>
</li>
</ol>
<h3 id="IP-层转发分组流程"><a href="#IP-层转发分组流程" class="headerlink" title="IP 层转发分组流程"></a>IP 层转发分组流程</h3><ul>
<li><p><strong>路由表</strong>：（目的网络地址， 下一跳地址）；</p>
<ul>
<li>整个网络拓扑简化为一条链路，强调了在互联网转发分组时，是<strong>从一个路由器转发到下一个路由器</strong>。</li>
</ul>
<p><img src="%E8%B7%AF%E7%94%B1%E8%A1%A8%E4%B8%BE%E4%BE%8B.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p><strong>特定主机路由：</strong> 对特定的目的主机指明一个路由；</p>
<ul>
<li>可使网络管理人员更方便地控制网络和测试网络；</li>
<li>可在考虑某种安全问题时采用这种特定主机路由；</li>
<li>网络连接或路由表排错时，特定路由十分有用。</li>
</ul>
</li>
<li><p><strong>默认路由：</strong> 减少路由表占用的空间和搜索路由表所用时间；</p>
<ul>
<li>在一个网络只有很少的对外连接时很有用。</li>
</ul>
<p><img src="%E8%B7%AF%E7%94%B1%E5%99%A8R1%E5%85%85%E5%BD%93%E7%BD%91%E7%BB%9CN1%E7%9A%84%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1%E5%99%A8.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p><strong>分组转发算法：</strong></p>
<ol>
<li>从数据报首部提取目的主机 IP 地址 D，得出目的网络地址为 N；</li>
<li>当 N 就是与此路由器直接相连的某个网络地址，则<strong>直接交付</strong>（包括把目的主机地址转换为具体的硬件地址，把数据封装为 MAC 帧）；</li>
<li>若路由表中有目的地址为 D 的<strong>特定主机路由</strong>，则把数据报传送给路由表中所指明的<strong>下一跳路由器</strong>；否则执行 4；</li>
<li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的<strong>下一跳路由器</strong>；否则执行 5；</li>
<li>若路由表中有一个默认路由，则把数据报传送给路由表中指明的<strong>默认路由器</strong>；否则执行 6；</li>
<li>报告转发分组<strong>出错</strong>。</li>
</ol>
</li>
</ul>
<h2 id="划分子网和构造超网"><a href="#划分子网和构造超网" class="headerlink" title="划分子网和构造超网"></a>划分子网和构造超网</h2><h3 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h3><ol>
<li><p><strong>两级 IP 地址 → 三级 IP 地址</strong></p>
<ul>
<li><p><strong>两级 IP 地址不合理：</strong></p>
<ol>
<li><strong>IP 地址空间利用率有时很低：</strong> 有的单位申请到一个 B 类地址网络，但所连主机不多，造成 IP地址的浪费；</li>
<li><strong>网络号使路由表变得太大：</strong> 互联网中的网络号越多，路由器路由表的项目也就越多，使查找路由时耗费更多时间；</li>
<li><strong>两级 IP 地址不够灵活：</strong> 必须事先到互联网管理机构申请新的网络号，才能开通新的网络。</li>
</ol>
</li>
<li><p><strong>子网寻址 &amp; 子网路由选择：</strong></p>
<ul>
<li>单位可将所属<strong>物理网络</strong>划分为若干<strong>子网</strong>，对外<strong>仍然表现为一个网络</strong>；</li>
<li><strong>三级 IP 地址</strong> :: = { &lt;网络号&gt;， &lt;子网号&gt;， &lt;主机号&gt; }。</li>
</ul>
<p><img src="%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
</ul>
</li>
<li><p><strong>子网掩码</strong></p>
</li>
</ol>
<blockquote>
<p>假定有一个数据报已经到达了路由器，那么此路由器如何把它转发到子网 145.13.3.0 呢？</p>
</blockquote>
<ul>
<li><p>IP 数据报上没有子网的划分信息，因此需要<strong>子网掩码</strong>；</p>
<ul>
<li>无论是否划分子网，只要将 IP 地址和子网掩码进行逐位<strong>与运算</strong>，就可以立即得到<strong>网络地址</strong>。</li>
</ul>
<p><img src="IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%90%84%E5%AD%97%E6%AE%B5%E5%92%8C%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p>如果一个网络不划分子网，则使用<strong>默认子网掩码</strong>；</p>
<ul>
<li>A 类地址默认子网掩码为 255.0.0.0；</li>
<li>B 类地址默认子网掩码为 255.255.0.0；</li>
<li>C 类地址默认子网掩码为 255.255.255.0</li>
</ul>
<p><img src="A%E7%B1%BBB%E7%B1%BB%E5%92%8CC%E7%B1%BBIP%E5%9C%B0%E5%9D%80%E7%9A%84%E9%BB%98%E8%AE%A4%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
</ul>
<h3 id="使用子网时分组的转发"><a href="#使用子网时分组的转发" class="headerlink" title="使用子网时分组的转发"></a>使用子网时分组的转发</h3><ul>
<li>使用子网划分后，路由表必须包括<strong>三项内容</strong>：目的网络地址、子网掩码、下一跳地址；</li>
<li>在划分子网的情况下，<strong>路由器转发分组算法：</strong><ol>
<li>获取数据报的目标 IP 地址 D；</li>
<li>对路由器每个直接相连网络的子网掩码和 D 与运算，若有匹配的网络地址，则<strong>直接交付</strong>；</li>
<li>若<strong>路由表</strong>中有目的地址为 D 的<strong>特定主机路由</strong>，则把数据报传送给路由表中指明的下一跳路由器；</li>
<li>对<strong>路由表</strong>中每一行的子网掩码与D与运算，结果为N。若N与某行目的网络地址匹配，则传送给对应的下一跳路由器；</li>
<li>若<strong>路由表</strong>中有一个<strong>默认路由</strong>，则将数据报传送给指明的默认路由器；</li>
<li>报告转发分组出错。</li>
</ol>
</li>
</ul>
<p><img src="%E4%B8%BB%E6%9C%BAH1%E5%90%91H2%E5%8F%91%E9%80%81%E5%88%86%E7%BB%84.jpg" srcset="/img/loading.gif" alt=""></p>
<h2 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a>网际控制报文协议 ICMP</h2><h3 id="ICMP-报文种类"><a href="#ICMP-报文种类" class="headerlink" title="ICMP 报文种类"></a>ICMP 报文种类</h3><ul>
<li><p>ICMP 差错报告报文和 ICMP 询问报文</p>
<p><img src="%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84ICMP%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
</ul>
<h3 id="ICMP-应用举例"><a href="#ICMP-应用举例" class="headerlink" title="ICMP 应用举例"></a>ICMP 应用举例</h3><ul>
<li><strong>分组网间探测 PING (Packet Internet Groper)</strong>：使用了 ICMP 的回送请求和回送回答报文。</li>
</ul>
<h2 id="动态选路协议"><a href="#动态选路协议" class="headerlink" title="动态选路协议"></a>动态选路协议</h2><h3 id="自治系统内选路协议"><a href="#自治系统内选路协议" class="headerlink" title="自治系统内选路协议"></a>自治系统内选路协议</h3><p>内部网关协议 IGP（Interior Gateway Protocol）。每个自治系统可以选择该自治系统中各个路由器之间的选路协议。常用的有1）<a href="https://baike.baidu.com/item/RIP%E5%8D%8F%E8%AE%AE/5994476?fr=aladdin" target="_blank" rel="noopener">RIP</a>（Routing Infromation Protocol)，使用UDP封装；2）<a href="https://baike.baidu.com/item/%E7%BB%84%E6%92%AD%E6%89%A9%E5%B1%95OSPF/288964?fromtitle=OSPF&fromid=1166620&fr=aladdin" target="_blank" rel="noopener">OSPF</a>（Open Shortest Path First，开放式最短路径优先）。</p>
<h4 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h4><p>RIP 是一种内部网关协议，是一种动态路由选择协议，用于自治系统（AS）内的路由信息的传递。RIP 协议基于距离矢量算法（Distance Vector Algorithms），使用“跳数”（metric）来衡量到达目标地址的路由距离。这种协议的路由器只关心自己周围的世界，只与自己相邻的路由器交换信息，范围限制在15跳（15度）之内。RIP应用于 OSI 网络七层模型的应用层。各厂家定义的管理距离（AD，即优先级）：华为定义的优先级是100，思科定义的优先级是120。</p>
<ul>
<li>仅和相邻路由器交换信息；<ul>
<li>如果两个路由器之间的通信不需要经过另一个路由器，那么这两个路由器就是相邻的。RIP协议规定不相邻的路由器不交换信息。</li>
</ul>
</li>
<li>路由器交换的信息是当前本路由器所知道的全部信息，即自己的路由表；<ul>
<li>交换的信息是：我到本自治制系统中所有网路的（最短）距离，以及到每个网络应该经过的下一跳路由器。</li>
</ul>
</li>
<li>按固定的时间间隔交换路由信息。<ul>
<li>例如，默认的路由更新周期是 30 秒。路由器根据收到的路由信息更新路由表。当网路拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。</li>
</ul>
</li>
</ul>
<h4 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h4><p>OSPF 是一个内部网关协议，用于在单一自治系统内决策路由。是对链路状态路由协议的一种实现，隶属内部网关协议（IGP），运作于自治系统内部。著名的迪克斯加算法被用来计算最短路径树。OSPF 支持负载均衡和基于服务类型的选路，也支持多种路由形式，如特定主机路由和子网路由等。</p>
<ul>
<li>向本自治系统中所有路由器发送消息，使用 IP 封装；</li>
<li>发送的信息是与本路由器相邻的所有路由器的链路状态；</li>
<li>只有当链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息；</li>
<li>OSPF 对不同的链路可根据 IP 分组的不同服务类型而设置成不同的代价；</li>
<li>多路径间的负载均衡。到同一个网络目的有多条相同代价的路径，可将通信量分配给这几条路径；</li>
<li>所有在 OSPF 路由器之间交换的分组都具有鉴别的功能，因而保证了仅在可信赖的路由器之间交换链路状态信息；</li>
<li>OSPF 支持可变长的子网划分和无分类的编址 CIDR；</li>
<li>OSPF 让每一个链路状态都带上一个32位的序号，序号越大状态越新。</li>
</ul>
<h3 id="自治系统间选路协议"><a href="#自治系统间选路协议" class="headerlink" title="自治系统间选路协议"></a>自治系统间选路协议</h3><p>外部网关协议 EGP （Exterier Gateway Protocol）。用于不同自治系统之间的路由器。当前使用的是边界网关协议 BGP（Border Gateway Protocol），使用TCP封装。</p>
<h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h2 id="运输层协议概述"><a href="#运输层协议概述" class="headerlink" title="运输层协议概述"></a>运输层协议概述</h2><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><ul>
<li><p><strong>通信端点：</strong> 从<strong>网络层</strong>来说，通信的两端是<strong>两台主机</strong>；而从<strong>运输层</strong>的角度看，通信的真正端点不是主机而是<strong>主机的进程</strong>；</p>
</li>
<li><p><strong>逻辑通信：</strong> 数据好像是水平方向直接传送数据，但事实上是沿着下图虚线方向（经过多个层次）传送的；</p>
<ul>
<li><strong>网络层</strong>为主机间提供逻辑通信，<strong>运输层</strong>则为应用进程间提供端到端的逻辑通信。</li>
</ul>
<p><img src="%E8%BF%90%E8%BE%93%E5%B1%82%E4%B8%BA%E7%9B%B8%E4%BA%92%E9%80%9A%E4%BF%A1%E7%9A%84%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E6%8F%90%E4%BE%9B%E4%BA%86%E9%80%BB%E8%BE%91%E9%80%9A%E4%BF%A1.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
</ul>
<h3 id="运输层的两个主要协议"><a href="#运输层的两个主要协议" class="headerlink" title="运输层的两个主要协议"></a>运输层的两个主要协议</h3><ul>
<li><p><strong>用户数据报协议 UDP</strong> 和 <strong>传输控制协议 TCP</strong>；</p>
<p><img src="TCPIP%E4%BD%93%E7%B3%BB%E4%B8%AD%E7%9A%84%E8%BF%90%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p>下表给出了一些应用和应用层协议主要使用的<strong>运输层协议</strong>。</p>
<p><img src="%E4%BD%BF%E7%94%A8UDP%E5%92%8CTCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%90%84%E7%A7%8D%E5%BA%94%E7%94%A8%E5%92%8C%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
</ul>
<h3 id="运输层的端口"><a href="#运输层的端口" class="headerlink" title="运输层的端口"></a>运输层的端口</h3><ul>
<li><p><strong>复用与分用：</strong> 应用层所有应用进程都可以通过运输层传输到 IP 层，称为<strong>复用</strong>；运输层从 IP 层收到发送给各应用进程的数据后，必须分别交付给指明的各应用进程，称为<strong>分用</strong>；</p>
</li>
<li><p><strong>端口(port)：</strong> 只要把报文交送到目的主机的某个合适的端口，剩下的工作就由 TCP 或 UDP 来完成；</p>
<blockquote>
<p>此协议端口是软件端口，和路由器或交换机上的硬件端口是完全不同的概念。</p>
</blockquote>
<ul>
<li>服务端使用的端口号：<ul>
<li><strong>系统端口号</strong>（熟知端口号）： 数值为 0 ~ 1023 ；</li>
<li><strong>登记端口号：</strong> 数值为 1024 ~ 49151 ；</li>
</ul>
</li>
<li><strong>客户端</strong>使用的端口号（<strong>短暂端口号</strong>）：数值为 49152 ~ 65536 。</li>
</ul>
</li>
</ul>
<p><img src="%E5%B8%B8%E7%94%A8%E7%9A%84%E7%86%9F%E7%9F%A5%E7%AB%AF%E5%8F%A3%E5%8F%B7.jpg" srcset="/img/loading.gif" alt=""></p>
<h2 id="用户数据报协议-UDP"><a href="#用户数据报协议-UDP" class="headerlink" title="用户数据报协议 UDP"></a>用户数据报协议 UDP</h2><h3 id="UDP-概述"><a href="#UDP-概述" class="headerlink" title="UDP 概述"></a>UDP 概述</h3><ol>
<li><strong>无连接</strong>：减少了开销和发送前时延；</li>
<li><strong>尽最大努力交付</strong>：不保证可靠交付；</li>
<li><strong>面向报文</strong>：对应用层交下来的报文既不合并，也不拆分，保留这些报文的边界。</li>
<li><strong>没有拥塞控制</strong>：网络拥塞不会使源主机发送速率降低，允许在网络拥塞时丢失一些数据，却不允许数据有太大的时延。</li>
<li><strong>支持一对一、一对多、多对一、多对多的交互通信</strong></li>
<li><strong>首部开销小：</strong> 首部长度只有 8 字节，比 TCP 的 20 字节短。</li>
</ol>
<h3 id="UDP-首部格式"><a href="#UDP-首部格式" class="headerlink" title="UDP 首部格式"></a>UDP 首部格式</h3><ul>
<li><p>由 4 个字段组成，每个字段 2 字节，共 8 字节：</p>
<p><img src="UDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E5%92%8C%E4%BC%AA%E9%A6%96%E9%83%A8.jpg" srcset="/img/loading.gif" alt=""></p>
<ul>
<li><p><strong>源端口</strong>： 需要对方回信时选用，不需要时可全 0 ；</p>
</li>
<li><p><strong>目的端口</strong>： 终点交付报文时必须使用；</p>
</li>
<li><p><strong>长度</strong>： 用户数据报长度，仅有首部时最小长度为 8；</p>
</li>
<li><p><strong>检验和</strong>：检测 UDP 用户数据报传输中是否有错，有错就丢弃。</p>
<ul>
<li><p><strong>伪首部</strong>：计算检验和时，要在用户数据报前增加 12 个字节的<strong>伪首部</strong>；伪首部既不向下传送也不向上递交；</p>
</li>
<li><p><strong>UDP 检验和方法</strong>：和 IP 数据报方法相似；</p>
</li>
<li><p><strong>UDP 检验范围</strong>：把首部和数据部分一起都检验（IP 数据报检验只检验 IP 数据报首部）。</p>
<blockquote>
<p>同时检验了：源端口、目的端口、数据部分、源 IP 地址、目的 IP 地址。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="传输控制协议-TCP"><a href="#传输控制协议-TCP" class="headerlink" title="传输控制协议 TCP"></a>传输控制协议 TCP</h2><h3 id="TCP-协议概述"><a href="#TCP-协议概述" class="headerlink" title="TCP 协议概述"></a>TCP 协议概述</h3><ul>
<li><p><strong>面向连接：</strong> 传输前需建立连接，传输完成需释放连接；TCP 连接是一条<strong>逻辑连接</strong>；</p>
</li>
<li><p><strong>点对点：</strong> 每一条 TCP 连接只能有两个端点；</p>
</li>
<li><p><strong>提供可靠交付：</strong> 无差错、不丢失、不重复、不失序；</p>
</li>
<li><p><strong>全双工通信：</strong> 设有发送缓存和接收缓存，允许双方随时发送数据；</p>
</li>
<li><p><strong>面向字节流：</strong> TCP 把应用进程交下来的数据看作一连串的无结构字节流。</p>
<ul>
<li>多个字节加上 TCP 首部，构成 TCP 报文段。</li>
</ul>
</li>
</ul>
<p><img src="TCP%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E6%B5%81%E7%9A%84%E6%A6%82%E5%BF%B5.jpg" srcset="/img/loading.gif" alt=""></p>
<h3 id="TCP-的连接"><a href="#TCP-的连接" class="headerlink" title="TCP 的连接"></a>TCP 的连接</h3><ul>
<li><strong>连接端点：</strong> 套接字(socket)或插口。套接字由端口号拼接到 IP 地址构成。</li>
</ul>
<p><img src="TCP%E7%9A%84%E8%BF%9E%E6%8E%A5.jpg" srcset="/img/loading.gif" alt=""></p>
<h2 id="TCP-报文段首部格式"><a href="#TCP-报文段首部格式" class="headerlink" title="TCP 报文段首部格式"></a>TCP 报文段首部格式</h2><ul>
<li>TCP 虽然是<strong>面向字节流</strong>的，但传送的数据单元却是<strong>报文段</strong>。一个报文段分为首部和数据两部分；</li>
<li>TCP 报文段首部前 20 字节固定，后面有 4n 字节可根据需要加选项；</li>
</ul>
<ol>
<li><p><strong>源端口和目的端口：</strong> 各占 2 字节；TCP 的分用功能通过端口实现；</p>
</li>
<li><p><strong>序号</strong>：占 4 字节（序号范围 [0, 2^32 - 1]。TCP 传送的<strong>字节流</strong>中每一个字节都<strong>按顺序编号</strong>；序号字段代表本报文段发送数据的<strong>第一个字节的序号</strong>，例如一报文段序号301，最后一个字节序号400，那么下一个报文段的数据序号应当从401开始；</p>
</li>
<li><p><strong>确认号</strong>：占 4 字节；代表期望收到对方下一个报文段第一个数据字节的序号；例如 B 正确收到一个报文段，序号字段是 501，数据长度是 200 字节，则 B 期望收到下一个数据序号是 701 ，即将发送给 A 的确认报文段中的确认号置为 701；</p>
<blockquote>
<p>若确认号 = N，代表直到序号 N-1 的所有数据都已正确收到。</p>
</blockquote>
</li>
<li><p><strong>数据偏移</strong>：占 4 位；单位 4 字节；指出 TCP 报文段<strong>数据起始处</strong>距离 TCP 报文段起始处的距离；能表示的最大十进制数字为 15，因此数据偏移最大值是 60 字节，也是 TCP 首部的最大长度；</p>
</li>
<li><p><strong>保留</strong>： 占 6 位，保留今后使用，应设置为 0；</p>
</li>
<li><p><strong>紧急 URG (urgent)</strong>：当 URG = 1 时，表明紧急指针字段有效。发送方 TCP 把紧急数据插入到本报文段数据的<strong>最前面</strong>；</p>
</li>
<li><p><strong>确认 ACK (acknowledgment)</strong>：仅当 ACK = 1 时<strong>确认号</strong>字段有效。TCP 规定，在连接建立后所有传送的报文段应将 ACK 置 1；</p>
</li>
<li><p><strong>推送 PSH (push)</strong>：当两个应用进程交互式通信时，一段应用进程希望键入一个命令后立即收到对方响应；推送操作很少使用；</p>
</li>
<li><p><strong>复位 RST (reset)</strong>：RST = 1 代表 TCP 出现严重差错（例如主机崩溃），必须释放连接； RST 还用来拒绝一个非法的报文段或拒绝打开一个连接；</p>
</li>
<li><p><strong>同步 SYN (synchronization)</strong>：连接建立时用来同步序号。当 SYN = 1 而 ACK = 0 时，表明这是一个<strong>连接请求</strong>报文段。SYN = 1 和 ACK = 1 就表示<strong>连接接受</strong>；</p>
</li>
<li><p><strong>终止 FIN (finish)</strong>：用来释放一个连接。当 FIN = 1 时，表明发送方数据已经发送完毕，并要求<strong>释放连接</strong>；</p>
</li>
<li><p><strong>窗口</strong>：占 2 字节；指发送本报文段的一方的接收窗口（窗口大小是由接收方定的，作为发送方设置其发送窗口的依据）；</p>
<blockquote>
<p>窗口字段明确指出了现在允许对方发送的数据量。窗口值是动态变化的。</p>
</blockquote>
</li>
<li><p><strong>检验和</strong>：占 2 字节；检验范围包括<strong>首部和数据</strong>两部分。计算检验和前需要在 TCP 报文段前面加上 12 字节的伪首部，格式与 UDP 伪首部一样，但应把第 4 个字段中的 17 改为 6 （TCP 协议号为 6 ），把第 5 个字段中 UDP 长度改为 TCP 长度；</p>
</li>
<li><p><strong>紧急指针</strong>：占 2 字节；仅在 URG = 1 时才有意义，指出本报文段中紧急数据的字节数（紧急数据后都是普通数据），紧急指针指出了紧急数据的末尾所在报文段中的位置；</p>
<ul>
<li>窗口为 0 时也可发紧急数据。</li>
</ul>
</li>
<li><p><strong>选项</strong>：长度可变，最长 40 字节。无选项时， TCP 首部长度为 20 字节。</p>
</li>
</ol>
<h2 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h2><h3 id="停止等待-ARQ-协议"><a href="#停止等待-ARQ-协议" class="headerlink" title="停止等待 ARQ 协议"></a>停止等待 ARQ 协议</h3><p>停止等待协议（stop-and-wait）是最简单但也是最基础的<a href="https://baike.baidu.com/item/数据链路层/4329290" target="_blank" rel="noopener">数据链路层</a>协议。很多有关协议的基本概念都可以从这个协议中学习到。停止等待就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。停止等待协议用于通信系统中，两个相连的设备相互发送信息时使用，以确保信息不因丢包或包乱序而丢失，是最简单的自动重传请求方法。</p>
<p>实用的CRC 检验器都是用硬件完成的。CRC 检验器能够自动丢弃检测到的出错帧。因此所谓的“丢弃出错帧”，对上层软件或用户来说都是感觉不到的。发送端对出错的数据帧进行重传是自动进行的，因而这种差错控制体制常简称为ARQ(Automatic Repeat reQuest)，即自动请求重传。</p>
<ol>
<li><p><strong>无差错情况</strong>：无差错情况最简单，A 发送 + B 确认，交替进行；</p>
<p><img src="ARQ%E6%97%A0%E5%B7%AE%E9%94%99%E6%83%85%E5%86%B5.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p><strong>出现差错</strong>（超时重传）：B 接收 M1 时检测出了差错，就丢弃 M1，其他什么也不做（不通知 A 收到差错）。A 只要超过一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面的分组，称为<strong>超时重传</strong>；</p>
<ul>
<li>应注意以下三点：<ol>
<li>A 发送完一个分组后，必须暂时保留已发送<strong>分组的副本</strong>，以供超时重传使用；</li>
<li>分组和确认分组都必须有<strong>编号</strong>，用来确认哪个分组收到、哪个没有收到；</li>
<li><strong>超时计时器</strong>设置的重传时间应比数据在分组传输的<strong>平均往返时间</strong>长一些；</li>
</ol>
</li>
</ul>
<p><img src="ARQ%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p><strong>确认丢失</strong>：B 发送的对 M1 的确认丢失了，导致 A 没有收到确认并重传了 M1 ；</p>
<ol>
<li>B 丢弃这个重复的分组 M1 ，不向上层交付；</li>
<li>B 向 A 再次发送确认（不能认为已经发送过一次就不再发送，因为 A 并没有收到确认）。</li>
</ol>
<p><img src="ARQ%E7%A1%AE%E8%AE%A4%E4%B8%A2%E5%A4%B1.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p><strong>确认迟到：</strong> B 发送的对 M1 的确认迟到了，导致 A 重传了 M1 并收到了两次 M1 的确认；</p>
<ol>
<li>A 将收到的重复确认直接丢弃；</li>
<li>B 将收到的重复分组直接丢弃，并重传确认分组。（因为并不能确定是确认丢失还是确认迟到导致的收到了重复分组）</li>
</ol>
<p><img src="ARQ%E7%A1%AE%E8%AE%A4%E8%BF%9F%E5%88%B0.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
</ol>
<h4 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h4><ul>
<li><p>停止等待协议优点是简单，缺点是信道利用率低。</p>
<p><img src="ARQ%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87%E5%A4%AA%E4%BD%8E.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p>为了提高传输效率，可以采用<strong>流水线传输</strong>，发送方可连续发送多个分组。连续发送使用的是<strong>连续 ARQ 协议</strong>和<strong>滑动窗口协议</strong>。</p>
<p><img src="%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%BC%A0%E8%BE%93%E5%8F%AF%E6%8F%90%E9%AB%98%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
</ul>
<h3 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h3><ul>
<li><p><strong>发送窗口</strong>：位于发送窗口内的 5 个分组都可以连续发送出去，而不需等待对方的确认，这样信道利用率就提高了；</p>
<p><img src="%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p><strong>累计确认</strong>：接收方不必对收到的分组逐个确认，而是在收到几个分组后，对<strong>按序到达的最后一个分组</strong>发送确认，表示此分组前的所有分组都正确收到。</p>
<ul>
<li><strong>缺点：</strong> 无法反映此分组的后面分组的情况（可能后面分组全部正确）。</li>
</ul>
</li>
</ul>
<h2 id="TCP-可靠传输实现"><a href="#TCP-可靠传输实现" class="headerlink" title="TCP 可靠传输实现"></a>TCP 可靠传输实现</h2><h3 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h3><ul>
<li><p>假定 A 收到来自 B 的确认报文段，其中窗口是 20 字节，确认号是 31 （表明 B 期望收到的下一个序号是 31）。根据这两个数据， A 构造出自己的发送窗口；</p>
<p><img src="%E6%A0%B9%E6%8D%AE%E7%AA%97%E5%8F%A3%E5%80%BC%E6%9E%84%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p>发送窗口由<strong>前沿</strong>和<strong>后沿</strong>共同确定。发送窗口通常<strong>不断向前移动</strong>，也有<strong>可能不动</strong>（一是没有收到新的确认；二是收到了新的确认但对方通知窗口缩小了，因此只有后沿缩小，前沿正好不动）；</p>
</li>
<li><p>描述一个发送窗口的状态需要<strong>三个指针</strong>：P1, P2, P3 指针指向字节序号。</p>
<ol>
<li>小于 P1 是已经发送并<strong>收到确认</strong>的部分</li>
<li>P1 - P2 是已经发送但<strong>未收到确认</strong>的部分</li>
<li>P2 - P3 是<strong>窗口内允许发送</strong>但<strong>尚未发送</strong>的部分</li>
<li>大于 P3 是<strong>窗口外不允许发送</strong>的部分</li>
</ol>
<p><img src="A%E5%8F%91%E9%80%81%E4%BA%8611%E4%B8%AA%E5%AD%97%E8%8A%82%E7%9A%84%E6%95%B0%E6%8D%AE.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
</ul>
<h3 id="超时重传时间选择"><a href="#超时重传时间选择" class="headerlink" title="超时重传时间选择"></a>超时重传时间选择</h3><ul>
<li><p><strong>重传时间选择</strong>是 TCP 最复杂的问题之一：</p>
<ul>
<li><strong>设置太短：</strong> 引起很多报文段不必要的重传；</li>
<li><strong>设置太长：</strong> 网络空闲时间增大，降低传输效率。</li>
</ul>
</li>
<li><p>TCP 采用<strong>加权平均往返时间 RTTs</strong>：</p>
<ul>
<li>报文段收到确认与发出的时间差为往返时间；</li>
<li>RFC 6298 建议标准推荐的 α 值为 0.125 。（ α 接近 0 表示受新的往返时间样本影响小；接近 1 表示受新的样本影响大）。</li>
</ul>
<p><img src="%E6%96%B0%E7%9A%84RTTs.png" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p><strong>超时重传时间 RTO</strong>：</p>
<ul>
<li>应略大于上面公式得出的 RTT_S ，RFC 6298 建议使用下式计算：</li>
</ul>
<p><img src="RTO.png" srcset="/img/loading.gif" alt=""></p>
<ul>
<li>其中RTT_D是RTT的偏差加权平均值，RFC 6298 建议使用下式计算：<ul>
<li>β 的推荐值是 0.25 。</li>
</ul>
</li>
</ul>
<p><img src="%E6%96%B0%E7%9A%84RTTD.png" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p><strong>忽略重传样本：</strong></p>
<ul>
<li>发送出一个报文段，设定的重传时间到了还没有收到确认，因此重传，经过一段时间后收到了确认。<strong>无法判断的问题：</strong> 此确认是对第一次报文段的确认，还是第二次报文段的确认？</li>
</ul>
<p><img src="%E6%94%B6%E5%88%B0%E7%9A%84%E7%A1%AE%E8%AE%A4%E6%98%AF%E5%AF%B9%E5%93%AA%E4%B8%80%E4%B8%AA%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E7%A1%AE%E8%AE%A4.png" srcset="/img/loading.gif" alt=""></p>
<ul>
<li><strong>修正的 Karn 算法：</strong> 报文段每重传一次，就把 RTO 增大为原来的 2 倍，当不再发生重传时，再根据上面的公式计算 RTO 。实践证明，这种策略较为合理。</li>
</ul>
</li>
</ul>
<h3 id="选择确认-SACK"><a href="#选择确认-SACK" class="headerlink" title="选择确认 SACK"></a>选择确认 SACK</h3><ul>
<li><p>假设收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据，那么时候能设法只传送缺少的数据而不重传已经正确到达接收方的数据？选择确认 SACK 就是一种可行的处理方法；</p>
<p><img src="%E6%8E%A5%E6%94%B6%E5%88%B0%E7%9A%84%E5%AD%97%E8%8A%82%E6%B5%81%E5%BA%8F%E5%8F%B7%E4%B8%8D%E8%BF%9E%E7%BB%AD.png" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p>如果要使用选择确认 SACK ，那么在建立 TCP 连接时，就要在首部<strong>选项</strong>中加“允许 SACK”选项。</p>
<ul>
<li>首部选项长度最多 40 字节，指定一个边界需要用掉 4 字节（因为<strong>序号</strong>是 4 字节），因此选项中最多可以指明 4 个字节块的边界信息（8个边界共用掉 32 字节，还有 2 字节分别用来指明 SACK 选项和这个选项要占用多少字节）。</li>
</ul>
</li>
</ul>
<h2 id="TCP-保证有序性"><a href="#TCP-保证有序性" class="headerlink" title="TCP 保证有序性"></a>TCP 保证有序性</h2><p>TCP提供了最可靠的数据传输，它给发送的每个数据包做顺序化，这看起来比较烦琐，然而，如果 TCP 没有这些机制，可能会造成更多的麻烦。例如数据包的重传、失序甚至数据包的丢失。</p>
<p>TCP 给每个数据包分配一个序列号，发送主机在特定的时间间隔内，等待接收主机对这个序列号的数据包进行确认，如果发送主机在特定时间内没有收到接收主机的确认，则发送主机会重传此数据包。接收主机利用序列号对接收的数据进行确认，以便检测对方发送的数据是否有丢失或者乱序等，接收主机一旦收到已经顺序化的数据，它就将这些数据按正确的顺序重组成数据流并传递到高层进行处理。</p>
<ul>
<li>为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；</li>
</ul>
<ul>
<li>并为每个已发送的数据包启动一个超时定时器；</li>
</ul>
<ul>
<li>若在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区；</li>
</ul>
<ul>
<li>否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。</li>
</ul>
<p>接收方收到数据包后，先进行 CRC 循环冗余校验（Cyclic Redundancy Check）校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可放在数据包中捎带过去。</p>
<h2 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h2><ul>
<li>流利用滑动窗口可以实现流量控制。流量控制是让对方发送速率不要太快，要让接收方来得及接收；</li>
</ul>
<p><img src="%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%AE%9E%E7%8E%B0TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.jpg" srcset="/img/loading.gif" alt=""></p>
<ul>
<li><strong>持续计时器：</strong> 当 rwnd = 0 时即不允许发送方再发送数据；过段时间 B 向 A 发送了 rwnd = 400 的报文段，但在传输过程丢失了，此时 A 仍然不发送数据，A, B 构成互相等待的局面。解决方案是 TCP 连接一方收到对方的零窗口通知，就启动<strong>持续计时器</strong>，若时间到期就发送一个<strong>零窗口探测报文段</strong>，对方则会确认这个探测报文段，死锁的僵局就被打破了。</li>
</ul>
<h2 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h2><h3 id="拥塞控制的一般原理"><a href="#拥塞控制的一般原理" class="headerlink" title="拥塞控制的一般原理"></a>拥塞控制的一般原理</h3><ul>
<li><p><strong>拥塞定义：</strong> 若网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就会变坏，称为拥塞；</p>
<p><img src="%E5%AF%B9%E8%B5%84%E6%BA%90%E7%9A%84%E9%9C%80%E6%B1%82%E5%A4%A7%E4%BA%8E%E5%8F%AF%E7%94%A8%E8%B5%84%E6%BA%90.png" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p><strong>拥塞控制：</strong> 防止过多的数据注入到网络中，使网络中路由器或链路不至过载。</p>
<ul>
<li>拥塞控制是一个<strong>全局性过程</strong>；流量控制往往指<strong>点对点通信量的控制</strong>；</li>
<li>拥塞控制很难设计，因为是一个<strong>动态问题</strong>。</li>
</ul>
<p><img src="%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%89%80%E8%B5%B7%E7%9A%84%E4%BD%9C%E7%94%A8.png" srcset="/img/loading.gif" alt=""></p>
</li>
</ul>
<h3 id="TCP-的拥塞控制方法"><a href="#TCP-的拥塞控制方法" class="headerlink" title="TCP 的拥塞控制方法"></a>TCP 的拥塞控制方法</h3><ul>
<li><p>发送方窗口的上限值应取<strong>接收方窗口 rwnd 和拥塞窗口 cwnd 两个变量中的较小值</strong>：</p>
<p><img src="%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3%E7%9A%84%E4%B8%8A%E9%99%90%E5%80%BC.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p><strong>拥塞控制流程图：</strong></p>
</li>
</ul>
<p><img src="TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" srcset="/img/loading.gif" alt=""></p>
<ol>
<li><p><strong>慢开始</strong>：当主机开始发送数据时，由于不清楚网络负载情况，因此<strong>由小到大逐渐增大发送窗口</strong>。</p>
<ul>
<li>开始时设置 cwnd = 1 ；每经过一个传输轮次，拥塞窗口 cwnd 就加倍。（一个传输轮次所经历的时间其实就是往返时间 RTT ）。</li>
</ul>
<p><img src="%E6%85%A2%E5%BC%80%E5%A7%8B.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p><strong>拥塞避免</strong>：让拥塞窗口 cwnd 缓慢增大，即没经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1 ，而不是像慢开始阶段那样加倍增长，使网络比较不容易出现拥塞。</p>
<ul>
<li><strong>当 cwnd &lt; ssthresh 时</strong>，使用慢开始算法；<strong>当 cwnd &gt; ssthresh 时</strong>，使用拥塞避免算法。</li>
<li>网络出现超时，发送方判断网络拥塞，于是调整门限值 <strong>ssthresh = cwnd / 2，cwnd = 1</strong>，并进入慢开始阶段；当逐渐增大到 <strong>ssthresh = cwnd</strong> 时，进入拥塞避免阶段。</li>
</ul>
<p><img src="%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p><strong>快重传</strong>：让发送方尽早<strong>知道个别报文段的丢失</strong>，以至于不需超时重传。使用快重传可以使整个网络吞吐量提升 20% 。</p>
<ul>
<li>快重传要求接收方不要等待自己发送数据时才捎带确认，而是<strong>立即发送确认</strong>；即使收到了失序的报文段也要立即发出对已收到的报文段的<strong>重复确认</strong>。</li>
<li>如下图所示，发送方只要<strong>一连收到 3 个重复确认</strong>，就知道接收方没有收到 M3 ，而<strong>立即重传 M3</strong> 。</li>
</ul>
<p><img src="%E5%BF%AB%E9%87%8D%E4%BC%A0.jpg" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p><strong>快恢复：</strong> 当接收到连续 3 个重复确认时，知道只是丢失了个别报文段，于是不启动慢开始，而是执行快恢复。</p>
<ul>
<li>发送方调整门限值 <strong>ssthresh = cwnd / 2</strong>；同时设置 <strong>cwnd = ssthresh</strong> ，立即进入<strong>拥塞避免</strong>。</li>
</ul>
</li>
</ol>
<h2 id="TCP-的运输连接管理"><a href="#TCP-的运输连接管理" class="headerlink" title="TCP 的运输连接管理"></a>TCP 的运输连接管理</h2><h3 id="TCP-连接建立-—-三报文握手"><a href="#TCP-连接建立-—-三报文握手" class="headerlink" title="TCP 连接建立 — 三报文握手"></a>TCP 连接建立 — 三报文握手</h3><ul>
<li><strong>三报文握手解决的问题：</strong> 假设 A 发出的第一个连接请求报文段没有丢失，而是在网络某处长时间滞留了，本来这是一个失效的连接请求；但后续 B 收到了它，误认为是 A 的连接请求，就向 A 发出确认报文段。若不采用三报文握手，此时一个已经失效的连接已经被建立，网络资源被白白浪费了。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">握手次数</th>
<th align="center">A 确认</th>
<th align="center">B 确认</th>
</tr>
</thead>
<tbody><tr>
<td align="center">第一次</td>
<td align="center"></td>
<td align="center">A 发送正常，B 接收正常</td>
</tr>
<tr>
<td align="center">第二次</td>
<td align="center">A 发送正常， B 接收正常；A接收正常，B发送正常</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">第三次</td>
<td align="center"></td>
<td align="center">A 发送正常， B 接收正常；A接收正常，B发送正常</td>
</tr>
</tbody></table>
<p><img src="%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" srcset="/img/loading.gif" alt=""></p>
<h3 id="TCP-连接释放-—-四报文握手"><a href="#TCP-连接释放-—-四报文握手" class="headerlink" title="TCP 连接释放 — 四报文握手"></a>TCP 连接释放 — 四报文握手</h3><ol>
<li>A 发送 TCP 连接释放报文，进入 <strong>FIN-WAIT-1</strong> 状态，<strong>等待 B 的确认</strong>；</li>
<li>B 收到报文段后立即发出确认，并进入 <strong>CLOSE-WAIT</strong> 状态；此时 A 到 B 的单向连接已经被释放， TCP 连接处于<strong>半关闭状态</strong>；B 继续向 A 传输未完成的数据。</li>
<li>A 收到 B 的确认后，进入 <strong>FIN-WAIT-2</strong> 状态，<strong>等待 B 的连接释放报文段</strong>；</li>
<li>若 B 已经将所有数据向 A 发送完毕，则向 A 发送 TCP 连接释放报文，并进入 <strong>LAST-ACK</strong> 状态，<strong>等待 A 的确认</strong>；</li>
<li>A 收到 B 的连接释放报文段后，立即发出确认，然后进入TIME-WAIT状态，必须经过时间等待计时器设置的时间 2MSL(4 min) 后，A 才进入 CLOSED 状态，这是因为：<ul>
<li><strong>第一：</strong> 由于 A 到 B 的确认报文段有可能丢失，B 可能回超时重传释放连接报文段，而 A 就能在 2MSL 时间内收到这个重传的连接释放报文段，并重传确认且重新启动 2MSL 计时器。</li>
<li><strong>第二：</strong> 防止<strong>“已失效的连接请求报文段”</strong>出现在本连接中， A 等待 2MSL 就可以使本链接持续时间内所产生的所有报文段在网络中小时。</li>
</ul>
</li>
</ol>
<p><img src="%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg" srcset="/img/loading.gif" alt=""></p>
<ul>
<li><strong>TCP 保活计时器：</strong> 服务器每收到一次客户端的数据后，就重新设置保活计时器（通常为 <strong>2h</strong>），若保活计时器期限内没有收到客户的数据，服务器就每隔 <strong>75s</strong> 发出一个探测报文段，若连续 <strong>10</strong> 个探测报文端后客户仍无响应，则<strong>直接关闭连接</strong>。</li>
</ul>
<h3 id="TCP-有限状态机"><a href="#TCP-有限状态机" class="headerlink" title="TCP 有限状态机"></a>TCP 有限状态机</h3><ul>
<li>为了更清晰地看出 TCP 连接各种状态之间的关系，下图给出了 TCP 的有限状态机。图中每一个方框即 TCP 可能<strong>具有的状态</strong>；状态之间的箭头表示<strong>可能发生的状态变迁</strong>；箭头旁边的文字表明引起这种<strong>变迁的原因</strong>：<ul>
<li>粗实线箭头表示<strong>对客户进程正常变迁</strong>；</li>
<li>粗虚线箭头表示<strong>对服务器进程的正常变迁</strong>；</li>
<li>细线箭头表示<strong>异常变迁</strong>。</li>
</ul>
</li>
</ul>
<p><img src="TCP%E7%9A%84%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA.jpg" srcset="/img/loading.gif" alt=""></p>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="各协议与HTTP协议之间的关系"><a href="#各协议与HTTP协议之间的关系" class="headerlink" title="各协议与HTTP协议之间的关系"></a>各协议与HTTP协议之间的关系</h2><p><img src="%E5%90%84%E5%8D%8F%E8%AE%AE%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" srcset="/img/loading.gif" alt=""></p>
<h2 id="HTTP-的长连接和短连接"><a href="#HTTP-的长连接和短连接" class="headerlink" title="HTTP 的长连接和短连接"></a>HTTP 的长连接和短连接</h2><ul>
<li>HTTP/1.0默认使用短链接，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束中断连接。每遇到新Web资源（如JS、CSS、图像等），就要新建立一个HTTP会话，这样浪费额外资源；</li>
<li>HTTP/1.1开始默认使用长连接，保持连接特性。当打开一个网页后，客户端和服务期间用于传输HTTP数据的TCP连接不会关闭；</li>
<li>HTTP协议长连接和短链接，实质上是TCP协议的长连接和短链接。</li>
</ul>
<h2 id="HTTP-协议包括哪些请求"><a href="#HTTP-协议包括哪些请求" class="headerlink" title="HTTP 协议包括哪些请求"></a>HTTP 协议包括哪些请求</h2><ul>
<li><strong>GET：</strong> 对服务器资源的简单请求；</li>
<li><strong>POST:</strong> 用于发送包含用户提交数据的请求；</li>
<li><strong>HEAD：</strong> 类似GET请求，不过只返回报头，没有具体内容；</li>
<li><strong>DELETE：</strong> 发出一个删除指定文档的请求；</li>
<li><strong>TRACE：</strong> 发送一个请求副本，跟踪其处理进程；</li>
<li><strong>OPTIONS：</strong> 返回可用的方法，检查服务器支持的方法；</li>
<li><strong>CONNECT:</strong> 用于ssl隧道基于代理的请求。</li>
</ul>
<h2 id="HTTP1-0-和-HTTP1-1-的区别"><a href="#HTTP1-0-和-HTTP1-1-的区别" class="headerlink" title="HTTP1.0 和 HTTP1.1 的区别"></a>HTTP1.0 和 HTTP1.1 的区别</h2><p>HTTP1.0 最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而 HTTP1.1 则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时 HTTP1.1 也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p>
<ul>
<li><p><strong>长连接</strong> : <strong>在HTTP/1.0中，默认使用的是短连接</strong>，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。<strong>HTTP 1.1起，默认使用长连接</strong> ,默认开启Connection： keep-alive。 <strong>HTTP/1.1的持续连接有非流水线方式和流水线方式</strong> 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求；</p>
</li>
<li><p><strong>错误状态响应码</strong>：在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除；</p>
</li>
<li><p><strong>缓存处理</strong>：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略；</p>
</li>
<li><p><strong>带宽优化及网络连接的使用</strong> :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p>
</li>
</ul>
<h2 id="HTTP-和-HTTPs"><a href="#HTTP-和-HTTPs" class="headerlink" title="HTTP 和 HTTPs"></a>HTTP 和 HTTPs</h2><ul>
<li><p><strong>端口</strong> ：HTTP 的 URL 由 “http://” 起始且默认使用80端口，HTTPS 的URL由 “https://” 起始且默认使用端口443；</p>
</li>
<li><p><strong>安全性和资源消耗</strong>：HTTP协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</p>
<ul>
<li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li>
<li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li>
</ul>
</li>
</ul>
<h2 id="HTTPS-工作流程"><a href="#HTTPS-工作流程" class="headerlink" title="HTTPS 工作流程"></a>HTTPS 工作流程</h2><p><img src="https%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg" srcset="/img/loading.gif" alt=""></p>
<h3 id="图示注解"><a href="#图示注解" class="headerlink" title="图示注解"></a>图示注解</h3><ul>
<li>key：服务器上的私钥文件，用于对发送给客户端数据的加密，以及对从客户端接收到数据的解密；</li>
<li>csr：证书签名请求文件（公钥），用于提交给证书颁发机构（CA）对证书签名；</li>
<li>crt：由证书颁发机构（CA）签名后的证书，或者是开发者自签名的证书，包含证书持有人的信息，持有人的公钥，以及签署者的签名等信息；</li>
<li>keystore：包含证书的文件，可以自己去导入证书；</li>
<li>PEM 文件格式存储证书和密钥，用于导出，导入证书时候的证书的格式，有证书开头，结尾的格式。</li>
</ul>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li>客户端向服务器发起 HTTPS 请求，连接到服务器的443端口；</li>
<li>服务器端有一个密钥对，即公钥和私钥，用来进行非对称加密。服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人；</li>
<li>服务器将自己的公钥发送给客户端；</li>
<li>客户端收到服务器端的证书之后，会对证书进行检查，验证其合法性，如果发现发现证书有问题，那么HTTPS传输就无法继续。严格的说，这里是<strong>验证服务器发送的数字证书的合法性</strong>。如果公钥合法，客户端会生成一个<strong>随机值，这个随机值是用于进行对称加密的密钥</strong>，该密钥称为 client key，即<strong>客户端密钥</strong>，这样在概念上和服务器端的密钥容易进行区分。至此，HTTPS 中的第一次请求结束；</li>
<li>客户端会发起 HTTPS 中的第二个请求，将加密之后的<strong>客户端密钥</strong>发送给服务器；</li>
<li>服务器接收到客户端发来的密文之后，会用自己的<strong>私钥对其进行非对称解密，解密之后的明文就是客户端密钥</strong>，然后用<strong>客户端密钥对数据进行对称加密</strong>，这样数据就变成了密文；</li>
<li>然后服务器将加密后的密文发送给客户端；</li>
<li>客户端收到服务器发送来的密文，用<strong>客户端密钥对其进行对称解密，得到服务器发送的数据</strong>。这样HTTPS 中的第二个请求结束，整个HTTPS传输完成。</li>
</ol>
<p>注：可以参考 <a href="https://blog.csdn.net/qq_33840251/article/details/91358884" target="_blank" rel="noopener">HTTPS工作流程</a> 文章。</p>
<h1 id="自测题"><a href="#自测题" class="headerlink" title="自测题"></a>自测题</h1><h3 id="计算机网络体系结构-1"><a href="#计算机网络体系结构-1" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><ul>
<li><strong>OSI七层模型：</strong> 应用层、（表示层、会话层）、传输层、网络层、（数据链路层、物理层）。</li>
<li><strong>TCP/IP四层模型：</strong> 应用层、传输层、网络层、网络接口层。</li>
<li><strong>五层体系结构：</strong> 应用层、传输层（段）、网络层（包）、数据链路层（帧）、物理层（比特流）。</li>
</ul>
<h3 id="TCP3握4挥"><a href="#TCP3握4挥" class="headerlink" title="TCP3握4挥"></a>TCP3握4挥</h3><ul>
<li>3次握手：<ul>
<li>客户端A发送SYN报文，服务端B接收到后若确认连接，则返回确认连接报文段，A收到报文段后（A连接已建立），还需要向B发送连接报文段，B接收到后连接建立。</li>
<li>为了防止客户端A已失效的链接请求发送到服务端B时，引起的服务端B资源浪费。如A发出的连接请求由于种种原因延迟了，失效了，但过了一段时间B收到了，若只用2次握手，B此时决定建立连接。但此连接是已失效的，B在等待A数据过程中，浪费了资源。</li>
</ul>
</li>
<li>4次挥手：<ul>
<li>客户端发送FIN连接释放报文后，服务端接收到这个报文立即回复ACK=1报文，此时客户端到服务端的单向连接已断开，而服务端进入close-wait状态，是为了等待所有数据都发送到客户端，再发送FIN连接释放报文。</li>
<li>客户端接收到FIN释放报文后回复ACK=1报文，不会直接进入CLOSED状态，而是进入Time_Wait状态，需等待一个时间计时器设置的时间2MSL = 2*2mins = 4mins，这样做是为了确认最后A向B发送的报文能够到达，并等待本连接产生的所有报文段在网络中消失。</li>
</ul>
</li>
</ul>
<h4 id="TCP半连接队列与全连接队列"><a href="#TCP半连接队列与全连接队列" class="headerlink" title="TCP半连接队列与全连接队列"></a>TCP半连接队列与全连接队列</h4><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p>
<ul>
<li>半连接队列，也称 SYN 队列；</li>
<li>全连接队列，也称 accepet 队列。</li>
</ul>
<p>服务端收到客户端发起的 SYN 请求后，内核会把该连接存储到半连接队列，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。</p>
<p>不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，内核会直接丢弃，或返回 RST 包。</p>
<h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><ul>
<li><strong>用户数据报协议UDP:</strong> 无连接；尽最大可能交付；无拥塞控制；支持一对一、一对多、多对一、多对多；应用:视频通信、实时通信；</li>
<li><strong>传输控制协议TCP:</strong> 面向连接；提供可靠交付；有流量控制、拥塞控制；提供全双工通信，面向字节流；每条TCP连接只能一对一。</li>
</ul>
<h3 id="交换机与路由器的区别"><a href="#交换机与路由器的区别" class="headerlink" title="交换机与路由器的区别"></a>交换机与路由器的区别</h3><ul>
<li><strong>交换机：</strong> 有下面两层协议；根据MAC地址确定目的地址；交换机只负责分配网络数据，每个用户使用不同IP；不可以处理TCP/IP协议；交换机一般用于端口扩展，让局域网可以接进来更多电脑；</li>
<li><strong>路由器：</strong> 有下面三层协议；根据IP地址确定目的地址；路由器有虚拟拨号，给局域网用户自动分配IP，对外只表现一个IP；可以处理TCP/IP协议；路由器做网间连接，用来连接不同的网络。</li>
</ul>
<h3 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h3><ul>
<li>流量控制是为了控制发送方的发送速率，保证接收方来得及接收；</li>
<li>接收方发送的确认报文中的窗口字段可用来控制发送方的窗口大小，从而影响发送方的发送速率。将窗口字段设置为0，则发送方不能发送数据。</li>
</ul>
<h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><ul>
<li><p>四种算法：慢开始、拥塞避免、快重传、快恢复。</p>
<ul>
<li><strong>慢开始：</strong> cwnd = 1, cwnd = 2 * cwnd。</li>
<li><strong>拥塞避免：</strong> 当cwnd &gt;= ssthresh时进入，cwnd = cwnd + 1；如果出现超时，则ssthresh = cwnd / 2，然后重新执行慢开始。</li>
<li><strong>快重传：</strong> 发送方收到三个重复确认，可以知道此确认的下一个报文段丢失，执行快重传，例如连续收到三个M2，则M3丢失，立即重传M3。</li>
<li><strong>快恢复：</strong> 慢开始和快恢复的快慢指的是cwnd的设定值。慢开始将cwnd设定为1，快恢复将cwnd设置为ssthresh，注意此时直接进入拥塞避免。</li>
</ul>
</li>
</ul>
<h3 id="ARP工作原理"><a href="#ARP工作原理" class="headerlink" title="ARP工作原理"></a>ARP工作原理</h3><p>将IP地址通过广播，根据目标IP地址解析到MAC地址。</p>
<h3 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h3><ul>
<li>客户机请求IP；（客户机发DHCPDISCOVER广播包）</li>
<li>服务器响应；（服务器发DHCPOFFER广播包）</li>
<li>客户机选择IP；（客户机发DHCPREQUEST广播包）</li>
<li>服务器确定租约。（服务器发DHCPACK/DHCPNAK广播包）</li>
</ul>
<h3 id="数据链路层提供的服务"><a href="#数据链路层提供的服务" class="headerlink" title="数据链路层提供的服务"></a>数据链路层提供的服务</h3><ul>
<li>差错检验（不纠错），检测到错误丢掉该帧。</li>
</ul>
<h3 id="运输层与网络层的区别"><a href="#运输层与网络层的区别" class="headerlink" title="运输层与网络层的区别"></a>运输层与网络层的区别</h3><ul>
<li>运输层提供进程间的通用数据传输服务，包括两种协议：TCP完整性服务，UDP及时性服务；</li>
<li>网络层提供主机间数据传输服务，负责选择IP地址最佳路径，路由器查看数据包目标IP地址，根据路由表为数据包选择路径。</li>
</ul>
<h3 id="静态路由和动态路由的区别"><a href="#静态路由和动态路由的区别" class="headerlink" title="静态路由和动态路由的区别"></a>静态路由和动态路由的区别</h3><ul>
<li><strong>静态路由：</strong> 路由表类目人工添加；</li>
<li><strong>动态路由：</strong> 路由表类目动态生成。</li>
</ul>
<h3 id="子网掩码作用"><a href="#子网掩码作用" class="headerlink" title="子网掩码作用"></a>子网掩码作用</h3><ul>
<li>测量多个 IP 是否在同一网段的工具；</li>
<li>例如 IP -192.168.1.199，子网掩码-255.255.255.0，则可以得到此IP地址的网络号为192.168.1，主机号为199。</li>
</ul>
<h3 id="浏览器输入url工作流程"><a href="#浏览器输入url工作流程" class="headerlink" title="浏览器输入url工作流程"></a>浏览器输入url工作流程</h3><p><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5url%E5%9C%B0%E5%9D%80%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg" srcset="/img/loading.gif" alt=""></p>
<blockquote>
<p>上图有一个错误，是OSPF（Open Shortest Path Fitst，ospf）不是OPSF。开放最短路径优先协议，是由Internet工程任务组开发的路由选择协议。</p>
</blockquote>
<p>总体来说分为以下几个过程:</p>
<ol>
<li>DNS解析</li>
<li>TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<h3 id="Session-与-Cookie"><a href="#Session-与-Cookie" class="headerlink" title="Session 与 Cookie"></a>Session 与 Cookie</h3><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>HTTP 是一种不保存状态，即无状态协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那如何保存用户状态呢？Session 机制可以解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库（比如是使用内存数据库 redis 保存）。既然 Session 存放在服务器端，那么如何实现 Session 跟踪呢？大部分情况下都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。Cookie 被禁用的话，最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。</p>
<h4 id="Session-与-Cookie的区别"><a href="#Session-与-Cookie的区别" class="headerlink" title="Session 与 Cookie的区别"></a>Session 与 Cookie的区别</h4><p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>
<p><strong>Cookie 一般用来保存用户信息</strong>。1）比如在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动填一些基本的信息；2）一般的网站都会有保持登录，也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可（为了安全考虑，重新登录一般要将 Token 重写）；3）登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>
<p>Cookie 数据保存在客户端（浏览器端），Session 数据保存在服务器端。</p>
<p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
<h3 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h3><ul>
<li>GET用于信息获取，是安全和幂等的，安全代表其不会增删改服务器上的内容，幂等代表多次相同操作返回相同；</li>
<li>POST请求可能修改服务器上资源；</li>
<li>GET请求数据附在URL后面，而POST在HTTP包体内；</li>
<li>POST安全性比GET高</li>
</ul>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p><img src="%E7%8A%B6%E6%80%81%E7%A0%81.jpg" srcset="/img/loading.gif" alt=""></p>
<ul>
<li>1XX：请求正在处理（Informational）；</li>
<li>2XX：请求成功（Success）；<ul>
<li>200 请求正常处理；</li>
<li>204 请求处理成功 但是没有任何资源返回给客户端(一般用于只需客户端向服务端发送消息)；</li>
<li>206 对资源的某一部分请求 响应报文中包含由 Content-Range 指定范围的实体内容。</li>
</ul>
</li>
<li>3XX：重定向（Redirection），需要进行附加操作以完成请求；<ul>
<li>301永久重定向 如果把资源对应的URI保存为书签，则此时书签会根据 Localtion 首部字段提示的URI重新保存；</li>
<li>302 临时重定向 临时地从旧地址A跳转到地址B；</li>
<li>303 和301，302类似 当使用 post 方法访问一个资源时，把客户端以get的方式重定向到对应的URI，返回303状态码；</li>
<li>304 资源已经找到，但是不满足条件，所以不把资源返回给客户端。常用于协商缓存。</li>
</ul>
</li>
<li>4XX：客户端错误（Client Error）；<ul>
<li>400 请求报文内有语法错误；</li>
<li>401 该状态码表示发送的请求需要通过 HTTP 认证，初次收到 401响应浏览器弹出认证的对话窗口。若收到第二次 401状态码，则说明第一次验证失败；</li>
<li>403 请求资源的访问被服务器拒绝，一般是未获得文件系统的访问权限，访问权限出现问题；</li>
<li>404 服务器上找不到请求资源 或路径错误；</li>
<li>405 请求方法被服务端识别，但是服务端禁止使用该方法。可以用 OPTIONS 来查看服务器允许哪些访问方法。</li>
</ul>
</li>
<li>5XX：服务器错误（Server Error）；<ul>
<li>500 服务器端在执行请求时出错，一般是因为 web 应用出现 bug；</li>
<li>502 代理服务器或网关从上游服务器中收到无效响应；</li>
<li>503 服务器暂时处于超负载或停机维护，目前无法处理请求。</li>
</ul>
</li>
</ul>
<h4 id="301-和-302-的异同"><a href="#301-和-302-的异同" class="headerlink" title="301 和 302 的异同"></a>301 和 302 的异同</h4><ul>
<li>共同点：301 和 302 状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的 URL 地址，这个地址可以从响应的 Location 首部中获取。用户看到的效果就是他输入的地址 A 瞬间变成了另一个地址 B；</li>
<li>不同点：301 表示旧地址 A 的资源已经被永久地移除了（该资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址。302表示旧地址 A 的资源还在（仍然可以访问），这个重定向只是临时地从旧地址 A 跳转到地址 B，搜索引擎会抓取新的内容而保存旧的网址。SEO：302 好于 301。</li>
</ul>
<h4 id="重定向原因"><a href="#重定向原因" class="headerlink" title="重定向原因"></a>重定向原因</h4><ul>
<li><p>网站调整（如改变网页目录结构）；</p>
</li>
<li><p>网页被移到一个新地址；</p>
</li>
<li><p>网页扩展名改变（如应用需要把.php 改成 .Html 或 .shtml）。这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个 404 页面错误信息，访问流量丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点。</p>
</li>
</ul>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">计算机网络基础</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/07/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">操作系统基础</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/07/22/MySQL-%E5%9F%BA%E7%A1%80/">
                        <span class="hidden-mobile">MySQL 基础</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    
  <!-- 备案信息 -->
  <div class="beian">
    <a href="http://beian.miit.gov.cn/" target="_blank"
       rel="nofollow noopener"></a>
    
  </div>


    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 2,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  














</body>
</html>
