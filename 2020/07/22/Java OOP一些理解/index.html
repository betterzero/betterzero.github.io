<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="Edgecloudsim Java Algorithm">
  <meta name="author" content="">
  <meta name="keywords" content="">
  <title>Java OOP一些理解 - 九流人</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 60vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>九流人</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
                Java OOP一些理解
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-07-22 18:10">
      2020年7月22日 晚上
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      48
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：2020年7月25日 凌晨
                
              </p>
            
            <article class="markdown-body">
              <p>文章介绍面向对象编程的基础概念，主要关于其特性、优势，以及 OOP 的使用方法与误区。</p>
<a id="more"></a>



<h1 id="面向过程编程及面向过程编程语言"><a href="#面向过程编程及面向过程编程语言" class="headerlink" title="面向过程编程及面向过程编程语言"></a>面向过程编程及面向过程编程语言</h1><p>面向过程编程<strong>以过程（或方法）作为组织代码的基本单元</strong>。它最主要的特点就是<strong>数据和方法相分离</strong>。面向过程编程语言最大的特点就是不支持丰富的<strong>面向对象编程特性</strong>，比如继承、多态、封装。</p>
<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>面向对象编程<strong>以类为组织代码的基本单元</strong>，一般来说，它具有以下优势。</p>
<ul>
<li>对于<strong>大规模复杂的程序的开发</strong>，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程更能应对这种复杂类型的程序开发；</li>
<li>面向对象编程具有更加<strong>丰富的特性</strong>，如封装、抽象、继承、多态。代码易扩展、易复用、易维护；</li>
</ul>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="访问权限控制"><a href="#访问权限控制" class="headerlink" title="访问权限控制"></a>访问权限控制</h3><p>封装主要关于<strong>信息隐藏、数据保护</strong>。编程语言需要提供<strong>访问权限控制</strong>这样的语法机制来支持。Java 使用访问控制符来保护对<strong>类、变量、方法和构造方法</strong>的访问。Java 支持 4 种不同的访问权限：</p>
<ul>
<li><strong>private</strong> : 访问权限限制的最窄的修饰符。同一类内可见。使用对象：变量、方法。 <strong>不能修饰类（外部类）</strong></li>
<li><strong>default</strong> (默认）: 通常称为“默认访问权限“或者“包访问权限”，不使用任何修饰符。同一包内可见。使用对象：类、接口、变量、方法。</li>
<li><strong>protected</strong> : 介于public 和 private 之间的一种访问修饰符。同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>不能修饰类（外部类）</strong>。</li>
<li><strong>public</strong> : 访问限制最宽的修饰符。允许跨包访问，所有类可见。使用对象：类、接口、变量、方法</li>
</ul>
<h3 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h3><p>如果对类中属性的访问不做限制，任何代码都可以访问、修改类中的属性，虽然看起来更加灵活，但是<strong>过度灵活也意味着不可控</strong>。属性可以随意被修改，修改逻辑可能散落在代码中的各个角落，影响代码的<strong>可读性、可维护性</strong>。</p>
<p>通过有限的方法，暴露必要的操作，能<strong>提高类的易用性</strong>。如果把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就要对业务细节有足够的了解。这对于调用者来说也是一种负担。如果将属性<strong>封装</strong>起来，只暴露必要的<strong>方法</strong>给调用者使用，调用者就不需要了解太多的业务细节，可以降低使用成本，减少用错的概率。</p>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p><strong>抽象关注的是如何隐藏方法的具体实现</strong>，让调用者只需要关心方法提供了哪些功能，不需要知道实现细节。</p>
<p>面向对象编程常常借助编程语言提供的<strong>接口</strong>或者<strong>抽象类</strong>这两种语法机制实现抽象这一特性。</p>
<p><strong>抽象有时候会被排除在面向对象特性之外</strong>。因为抽象是一个非常通用的设计思想，不单单用在面向对象编程中，也可以用来指导架构设计等。这个特性也并不需要编程语言提供特殊的语法机制来支持，只需要提供“函数”这一语法机制，就可以实现抽象特性。</p>
<h3 id="抽象的意义"><a href="#抽象的意义" class="headerlink" title="抽象的意义"></a>抽象的意义</h3><p>面对复杂的系统，人脑能承受的信息是有限的，所以要忽略一些非关键的实现细节。抽象作为一种<strong>只关注功能点不关注实现</strong>的设计思路，可以过滤掉非必要的信息。</p>
<p>抽象作为一个非常宽泛的<strong>设计思想</strong>，在代码设计中起到重要的指导作用。很多设计原则都体现了抽象这种设计思想，比如<strong>基于接口而非实现编程</strong>、<strong>开闭原则</strong>（对扩展开放、对修改关闭）、<strong>代码解耦</strong>（降低代码的耦合性）等。</p>
<p>换一个角度考虑，定义类的方法的时候，不要暴露太多的实现细节，以保证在修改方法的实现的时候，不用再修改其定义。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承用来表示<strong>类之间的 is-a 关系</strong>，比如猫是一种哺乳动物。继承可以分为两种模式，<strong>单继承和多继承</strong>。</p>
<p>Java 使用 <strong>extends</strong> 关键字来实现继承，C++ 使用冒号（class B : public A），Python 使用 paraentheses()。有些编程语言只支持单继承，不支持多重继承，比如 Java。有些编程语言两种方式都支持，比如 C++、Python。</p>
<h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><p>多重继承存在钻石问题，即菱形继承。假设类 B 和类 C 继承自类 A，都重写了类 A 中的同一个方法，而类 D 同时继承了类 B 和类 C，那么此时类 D 会继承 B、C 的方法，那对于 B、C 重写的 A 中的方法，类 D 继承哪一个就无法确定。</p>
<p>Java支持多接口实现，因为接口中的方法是抽象的，即便一个类实现了多个接口，且这些接口中存在同名方法，但在实现接口的时候，这个同名方法需要由这个实现类自己来实现，所以避免了二义性的问题。</p>
<h3 id="继承的意义"><a href="#继承的意义" class="headerlink" title="继承的意义"></a>继承的意义</h3><p>继承最大的优点是<strong>代码复用</strong>。假如两个类有一些相同的属性和方法，就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。两个子类可以重用父类中的代码。不过，通过其他方式，比如利用<strong>组合关系</strong>而不是<strong>继承关系</strong>，也可以达到代码复用的目的。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是同一个行为具有多个不同表现形式或形态的能力，同一个接口，使用不同的实例而执行不同操作。<strong>子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现</strong>。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="继承-方法重写"><a href="#继承-方法重写" class="headerlink" title="继承 + 方法重写"></a>继承 + 方法重写</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicArray</span> </span>&#123;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;
  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> capacity = DEFAULT_CAPACITY;
  <span class="hljs-keyword">protected</span> Integer[] elements = <span class="hljs-keyword">new</span> Integer[DEFAULT_CAPACITY];
  
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.size; &#125;
  <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123; <span class="hljs-keyword">return</span> elements[index];&#125;
  
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Integer e)</span> </span>&#123;
    ensureCapacity();
    elements[size++] = e;
  &#125;
  
  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacity</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">// 如果数组满了就扩容...</span>
  &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortedDynamicArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DynamicArray</span> </span>&#123;
  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Integer e)</span> </span>&#123;
    ensureCapacity();
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">for</span> (i = size-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; --i) &#123; <span class="hljs-comment">//保证数组中的数据有序</span>
      <span class="hljs-keyword">if</span> (elements[i] &gt; e) &#123;
        elements[i+<span class="hljs-number">1</span>] = elements[i];
      &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">break</span>;
      &#125;
    &#125;
    elements[i+<span class="hljs-number">1</span>] = e;
    ++size;
  &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(DynamicArray dynamicArray)</span> </span>&#123;
    dynamicArray.add(<span class="hljs-number">5</span>);
    dynamicArray.add(<span class="hljs-number">1</span>);
    dynamicArray.add(<span class="hljs-number">3</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dynamicArray.size(); ++i) &#123;
      System.out.println(dynamicArray.get(i));
    &#125;
  &#125;
  
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;
    DynamicArray dynamicArray = <span class="hljs-keyword">new</span> SortedDynamicArray();
    test(dynamicArray); <span class="hljs-comment">// 打印结果：1、3、5</span>
  &#125;
&#125;</code></pre>



<p>多态需要<strong>编程语言提供特殊的语法机制</strong>来实现。在上面的例子中，用到了三个语法机制来实现多态。</p>
<ul>
<li><strong>父类对象可以引用子类对象</strong>。可以将 SortedDynamicArray 传递给 DynamicArray。</li>
<li><strong>继承</strong>。SortedDynamicArray 继承了 DynamicArray，才能将 SortedDyamicArray 传递给 DynamicArray；</li>
<li><strong>子类可以重写（override）父类中的方法</strong>。SortedDyamicArray 重写了 DynamicArray 中的 add() 方法。</li>
</ul>
<p>这三种语法机制配合在一起，实现了在 test() 方法中，子类 SortedDyamicArray 替换父类 DynamicArray，执行子类 SortedDyamicArray 的 add() 方法，实现了多态特性。</p>
<p>对于多态的实现方式，除了利用<strong>继承加方法重写</strong>这种方式外，还有其他两种比较常见的的实现方式，一个是利用<strong>接口类语法</strong>，另一个是利用 <strong>duck-typing 语法</strong>。不过，并不是每种编程语言都支持接口类或者 duck-typing 这两种语法机制，比如 C++ 不支持接口类语法，而 duck-typing 只有一些动态语言才支持，比如 Python、JavaScript 等。</p>
<h4 id="接口类语法"><a href="#接口类语法" class="headerlink" title="接口类语法"></a>接口类语法</h4><p>Iterator 是一个接口类，定义了一个可以遍历集合数据的迭代器。Array 和 LinkedList 都实现了接口类 Iterator。通过<strong>传递不同类型的实现类（Array、LinkedList）到 print(Iterator iterator) 函数中，支持动态的调用不同的 next()、hasNext() 实现</strong>。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span> </span>&#123;
  <span class="hljs-function">String <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;
  <span class="hljs-function">String <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;
  <span class="hljs-function">String <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Array</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span> </span>&#123;
  <span class="hljs-keyword">private</span> String[] data;
  
  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123; ... &#125;
  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123; ... &#125;
  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123; ... &#125;
  <span class="hljs-comment">// 省略其它方法...</span>
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span> </span>&#123;
  <span class="hljs-keyword">private</span> LinkedListNode head;
  
  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123; ... &#125;
  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123; ... &#125;
  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123; ... &#125;
  <span class="hljs-comment">// 省略其它方法... </span>
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Iterator iterator)</span> </span>&#123;
    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;
      System.out.println(iterator.next());
    &#125;
  &#125;
  
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    Iterator arrayIterator = <span class="hljs-keyword">new</span> Array();
    print(arrayIterator);
    
    Iterator linkedListIterator = <span class="hljs-keyword">new</span> LinkedList();
    print(linkedListIterator);
  &#125;
&#125;</code></pre>



<p>Java 通过<strong>继承实现多态特性</strong>，必须要求两个<strong>类之间有继承关系</strong>。通过<strong>接口实现多态特性</strong>，<strong>类必须实现对应的接口</strong>。</p>
<h3 id="多态的意义"><a href="#多态的意义" class="headerlink" title="多态的意义"></a>多态的意义</h3><p>多态特性能<strong>提高代码的可扩展性和复用性</strong>。利用多态，一个 print() 函数可以实现遍历打印不同类型集合的数据。当需要再增加一种要遍历打印的类型的时候，比如 HashMap，只需让 HashMap 实现 Iterator 接口，重新实现自己的 hasNext()、next() 等方法就可以了，不需要改动 print() 函数的代码，提高了代码的可扩展性。</p>
<p>多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等。</p>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="违反OOP风格的代码设计"><a href="#违反OOP风格的代码设计" class="headerlink" title="违反OOP风格的代码设计"></a>违反OOP风格的代码设计</h2><h3 id="滥用-getter、setter-方法"><a href="#滥用-getter、setter-方法" class="headerlink" title="滥用 getter、setter 方法"></a>滥用 getter、setter 方法</h3><ul>
<li>设计实现类的时候，除非真的需要，否则尽量不要给属性定义 setter 方法；</li>
<li>尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器，也要防范集合内部数据被修改的风险。</li>
</ul>
<h3 id="Constants-类、Utils-类的设计问题"><a href="#Constants-类、Utils-类的设计问题" class="headerlink" title="Constants 类、Utils 类的设计问题"></a>Constants 类、Utils 类的设计问题</h3><ul>
<li>对于这两种类的设计，尽量能做到职责单一，定义一些细化的小类，比如 RedisConstants、FileUtils，而不是定义一个大而全的 Constants 类、Utils 类；</li>
<li>如果能将这些类中的属性和方法，划分归并到其他业务类中，能极大地提高类的内聚性和代码的可复用性。</li>
</ul>
<h2 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h2><p>面向对象编程中，抽象类和接口是两个经常使用的语法概念，是面向对象四大特性以及很多设计模式、设计思想、设计原则编程实现的基础，例如：</p>
<ul>
<li>使用<strong>接口来实现面向对象的抽象特性、多态特性</strong>和<strong>基于接口而非实现</strong>的设计原则；</li>
<li>使用<strong>抽象类来实现面向对象的继承特性和模板设计模式</strong>等。</li>
</ul>
<p>继承关系是 is-a 的关系，接口表示 has-a 关系，表示<strong>具有某些功能</strong>。接口，有一个更形象的叫法：<strong>协议</strong>。</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li>抽象类<strong>不允许被实例化</strong>，只能被<strong>继承</strong>；</li>
<li>抽象类可以包含属性和方法。抽象类中的成员变量可以是各种类型的，接口中的成员变量只能是 <strong>public static final</strong> 类型的；<ul>
<li>抽象类中的方法可以有方法体；</li>
<li>也可以不包含方法体。不包含代码实现的方法叫作<strong>抽象方法</strong>；</li>
</ul>
</li>
<li>子类继承抽象类，<strong>必须实现抽象类中的所有抽象方法</strong>。</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li><p>接口是隐式抽象的，声明接口时不必使用<strong>abstract</strong>关键字；</p>
</li>
<li><p>接口没有构造方法，接口不能实例化；</p>
</li>
<li><p>接口支持多继承；</p>
</li>
<li><p>接口中<strong>没有成员变量</strong>，<strong>只有方法声明，没有方法实现</strong>，实现接口的类<strong>必须实现接口中的所有方法</strong>；</p>
<ul>
<li>接口不包含任何<strong>非常量成员</strong>，任何 field 都是隐含着 public static final 的意义；</li>
</ul>
</li>
<li><p>接口没有<strong>非静态方法实现</strong>，要么是隐式的抽象方法（声明时不需要<strong>abstract</strong>关键字），要么是静态方法；</p>
<ul>
<li>JDK 1.8版本及以上，接口里可以有静态方法和方法体了，只有静态方法可以在接口中实现</li>
</ul>
</li>
</ul>
<h3 id="抽象类-OR-接口"><a href="#抽象类-OR-接口" class="headerlink" title="抽象类 OR 接口"></a>抽象类 OR 接口</h3><ul>
<li><strong>抽象类是一种自下而上的设计思路</strong>，先有子类的代码重复，然后抽象成上层的父类（抽象类）；</li>
<li>如果表示 <strong>is-a</strong> 的关系，为了解决<strong>代码复用</strong>的问题，使用<strong>抽象类</strong>；</li>
<li>接口是一种<strong>自上而下的设计思路</strong>，一般是先设计接口，再考虑具体的实现；</li>
<li>如果表示 <strong>has-a</strong> 关系，为了解决<strong>抽象</strong>而非代码复用的问题，使用<strong>接口</strong>；</li>
</ul>
<h2 id="基于接口而非实现编程"><a href="#基于接口而非实现编程" class="headerlink" title="基于接口而非实现编程"></a>基于接口而非实现编程</h2><p>“基于接口而非实现编程”，也可以表达为“<strong>基于抽象而非实现编程</strong>”。软件开发时一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。</p>
<p>本质上看，<strong>“接口”是一组“协议”或者“约定”，是功能提供者给使用者的一个“功能列表”</strong>。“接口”在不同的应用场景下会有不同的解读，比如服务端与客户端之间的“接口”，类库提供的“接口”，甚至是一组通信的协议都可以叫作“接口”。落实到具体的编码，“基于接口而非实现编程”原则中的“接口”，可以理解为编程语言中的<strong>接口或者抽象类</strong>。</p>
<p>这条原则能有效地提高代码质量。可以<strong>将接口和实现相分离，封装不稳定的实现，暴露稳定的接口</strong>。上游系统面向接口而非实现编程，<strong>不依赖不稳定的实现细节</strong>，当实现发生变化时，上游系统的代码基本上不需要改动，以此<strong>降低耦合性，提高扩展性</strong>。</p>
<h3 id="应用原则"><a href="#应用原则" class="headerlink" title="应用原则"></a>应用原则</h3><p>编写代码时遵从基于接口而非实现编程的原则：</p>
<ul>
<li><strong>函数的命名不能暴露任何实现细节</strong>；</li>
<li><strong>封装具体的实现细节</strong>；</li>
<li><strong>为实现类定义抽象的接口</strong>。具体的实现类依赖统一的接口定义，使用者依赖接口而非具体的实现类来编程。</li>
</ul>
<p>越不稳定的系统，越要在代码的扩展性、维护性上下功夫。不过，如果业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，没有必要为其设计接口，也没有必要基于接口编程，那么直接使用实现类就可以了。</p>
<h2 id="组合优于继承"><a href="#组合优于继承" class="headerlink" title="组合优于继承"></a>组合优于继承</h2><h3 id="继承的缺点"><a href="#继承的缺点" class="headerlink" title="继承的缺点"></a>继承的缺点</h3><p>继承层次越来越深，会使得继承关系会越来越复杂，引发以下问题：</p>
<ul>
<li>代码的可读性变差。因为要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码，一直追溯到最顶层父类的代码；</li>
<li>破坏了类的封装特性，降低可维护性。父类的实现细节暴露给子类，子类的实现依赖父类的实现，两者高度耦合。父类代码的修改会影响所有子类的逻辑。</li>
</ul>
<h3 id="组合的优势"><a href="#组合的优势" class="headerlink" title="组合的优势"></a>组合的优势</h3><p>可以利用组合（composition）、接口、委托（delegation）三个技术，解决继承存在的问题。</p>
<p>注：<strong>组合</strong>，java代码复用的一种方法。<strong>使用多个已有的对象组合为一个功能更加复杂强大的新对象</strong>。体现的是<strong>整体与部分、拥有的关系</strong>。因为在对象之间，各自的内部细节是不可见的，所以也说这种方式的代码复用是黑盒的。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyable</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span>；</span>
<span class="hljs-function">&#125;</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> class FlyAbility implements Flyable </span>&#123;
  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//... &#125;</span>
&#125;
<span class="hljs-comment">//省略Tweetable/TweetAbility/EggLayable/EggLayAbility</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ostrich</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Tweetable</span>, <span class="hljs-title">EggLayable</span> </span>&#123;<span class="hljs-comment">//鸵鸟</span>
  <span class="hljs-keyword">private</span> TweetAbility tweetAbility = <span class="hljs-keyword">new</span> TweetAbility(); <span class="hljs-comment">//组合</span>
  <span class="hljs-keyword">private</span> EggLayAbility eggLayAbility = <span class="hljs-keyword">new</span> EggLayAbility(); <span class="hljs-comment">//组合</span>
  <span class="hljs-comment">//... 省略其他属性和方法...</span>
  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tweet</span><span class="hljs-params">()</span> </span>&#123;
    tweetAbility.tweet(); <span class="hljs-comment">// 委托</span>
  &#125;
  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">layEgg</span><span class="hljs-params">()</span> </span>&#123;
    eggLayAbility.layEgg(); <span class="hljs-comment">// 委托</span>
  &#125;
&#125;</code></pre>



<p>继承主要有三个作用：<strong>表示 is-a 关系，支持多态特性，代码复用</strong>。这三个作用都可以通过其他技术来达成。</p>
<ul>
<li>is-a 关系可以通过<strong>组合</strong>和<strong>接口的 has-a</strong> 关系来替代；</li>
<li>多态特性可以利用接口来实现；</li>
<li>代码复用可以通过组合和委托来实现。</li>
</ul>
<p>理论上讲，通过组合、接口、委托三种技术，可以替代继承。在项目中可以不用或者少用继承关系，特别是一些复杂的继承关系。</p>
<h3 id="组合-OR-继承"><a href="#组合-OR-继承" class="headerlink" title="组合 OR 继承"></a>组合 OR 继承</h3><p>继承改写成组合意味着要做更细粒度的类的拆分，定义更多的类和接口。类和接口的增多会增加代码的复杂程度和维护成本。实际的项目开发要根据具体的情况，具体地选择该用继承还是组合。</p>
<p>如果类之间的继承结构稳定，继承层次比较浅，继承关系不复杂，可以使用继承。反之，就尽量使用组合。</p>
<p>一些设计模式会固定使用继承或者组合。装饰者模式、策略模式、组合模式等都使用了组合关系，而模板模式使用了继承关系。</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Java/">Java</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/OOP/">OOP</a>
                    
                      <a class="hover-with-bg" href="/tags/Encapsulation/">Encapsulation</a>
                    
                      <a class="hover-with-bg" href="/tags/Inheritance/">Inheritance</a>
                    
                      <a class="hover-with-bg" href="/tags/Polymorphism/">Polymorphism</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/07/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java多线程基础</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/07/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/">
                        <span class="hidden-mobile">动态规划专题</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    
  <!-- 备案信息 -->
  <div class="beian">
    <a href="http://beian.miit.gov.cn/" target="_blank"
       rel="nofollow noopener"></a>
    
  </div>


    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 2,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  














</body>
</html>
