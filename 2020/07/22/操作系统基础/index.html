<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="Edgecloudsim Java Algorithm">
  <meta name="author" content="">
  <meta name="keywords" content="">
  <title>操作系统基础 - 九流人</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 60vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>九流人</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bg/astronaut.PNG') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
                操作系统基础
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-07-22 18:19">
      2020年7月22日 晚上
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      15.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      160
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：2020年8月3日 凌晨
                
              </p>
            
            <article class="markdown-body">
              <p>文章介绍计算机操作系统基础。</p>
<a id="more"></a>



<h1 id="概念基础"><a href="#概念基础" class="headerlink" title="概念基础"></a>概念基础</h1><h2 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h2><p>操作系统是管理系统资源、控制程序执行、改善人机界面、提供各种服务，并合理组织计算机工作流程和为用户方便而有效地使用计算机提供良好运行环境的最基本的系统软件。</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用是一种中介角色，把用户和硬件隔离开来，应用程序只有通过系统调用才可以请求系统服务并使用系统资源。系统调用的作用：</p>
<ul>
<li>内核可以基于权限和规则对资源访问进行裁决，保证系统的安全性；</li>
<li>系统调用对资源进行抽象，提供一致性接口，避免用户在使用资源时发生错误，且使编程效率提高；</li>
</ul>
<p>当 CPU 执行程序中预设的由访管指令实现的系统调用时，会产生异常信号，通过中断机制，处理器的状态由用户态转变为核心态，进入操作系统并执行相应的内核函数，以获得操作系统服务；当系统调用执行完毕时，控制返回至发出系统调用的程序，系统调用是应用程序获得操作系统服务的唯一途径。</p>
<p>内核是一组程序模块，作为可信软件来提供支持进程并发的基本功能和基本操作，通常驻留在内存空间，运行于核心态，具有访问硬件设备和所有主存空间的权限，是仅有的能够执行特权指令的程序。有了内核的支撑，机器功能得到扩展，进程运行环境得到改善，安全性得到保证，系统效率得到提高。</p>
<h2 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h2><p>fork() 是 UNIX 或类UNIX 中的分叉函数，fork 函数将运行着的程序分成2个（几乎）完全一样的进程，每个进程都启动一个从代码的同一位置开始执行的线程。这两个进程中的线程继续执行，就像是两个用户同时启动了该应用程序的两个副本。</p>
<p>fork 系统调用用于创建一个新进程，称为子进程，它与进程（称为系统调用fork的进程）同时运行，此进程称为父进程。创建新的子进程后，两个进程将执行 fork() 系统调用之后的下一条指令。子进程使用相同的PC（程序计数器），相同的CPU寄存器，在父进程中使用的相同打开文件。</p>
<p>由于在复制时复制了父进程的堆栈段，所以两个进程都停留在fork函数中，等待返回。因此fork函数会返回两次，一次是在父进程中返回，另一次是在子进程中返回，这两次的返回值是不一样的。</p>
<pre><code class="hljs c"><span class="hljs-comment">//一次调用两次返回值，是在各自的地址空间返回，意味着现在有两个基本一样的进程在执行, 无参数。</span>
<span class="hljs-function"><span class="hljs-keyword">pid_t</span> <span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;</code></pre>



<p>fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：</p>
<ul>
<li>如果成功创建一个子进程，对于父进程来说返回子进程ID；</li>
<li>如果成功创建一个子进程，对于子进程来说返回值为0；</li>
<li>如果为-1表示创建失败；</li>
</ul>
<p>fork 如何知道一个进程是父进程还是子进程：这涉及到 fork 本身的功能，它的作用是克隆进程，也就是将原先的一个进程再克隆出一个来，克隆出的这个进程就是原进程的子进程，这个子进程和其他的进程没有什么区别，同样拥有自己的独立的地址空间。不同的是子进程是在fork返回之后才开始执行的，就像一把叉子一样，执行 fork 之后，父子进程就分道扬镳了，所以 fork 这个名字就很形象，叉子的意思。</p>
<h3 id="孤儿进程和僵尸进程"><a href="#孤儿进程和僵尸进程" class="headerlink" title="孤儿进程和僵尸进程"></a>孤儿进程和僵尸进程</h3><p>在UNIX/Linux中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程无法预测子进程什么时候结束。当一个 进程完成它的工作终止之后，它的父进程需要调用 wait() 或者 waitpid() 系统调用取得子进程的终止状态。</p>
<h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><p><strong>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程</strong>。孤儿进程将被 init 进程(进程号为1)收养，并由 init 进程对它们完成状态收集工作。孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了 init 进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。<strong>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init，而 init 进程会循环地 wait() 它的已经退出的子进程。</strong>这样，当一个孤儿进程结束其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。<strong>因此孤儿进程并不会有什么危害。</strong></p>
<h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><p><strong>一个进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程</strong>。UNIX 提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息，就可以得到。这种机制就是：在每个进程退出的时候，内核释放该进程所有的资源,包括打开的文件,占用的内存等。但是仍然为其保留一定的信息(包括进程号，退出状态，运行时间等)。直到父进程通过wait / waitpid 来取时才释放。但这样就导致了问题，如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其<strong>进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。</strong></p>
<h1 id="处理器管理"><a href="#处理器管理" class="headerlink" title="处理器管理"></a>处理器管理</h1><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p><strong>中断是指在程序执行过程中，遇到急需处理的事件时，暂时中止现行程序在CPU上的运行，转而执行相应的事件处理程序，待处理完成后在返回断点或调度其他程序执行。</strong>例如，从磁带上读入一组信息，当发现读入操作有误时，将产生读数据中断，操作系统停止当前的工作，并组织磁带退回重读这一组信息，这样就有可能克服错误。</p>
<h3 id="强迫性中断和自愿性中断"><a href="#强迫性中断和自愿性中断" class="headerlink" title="强迫性中断和自愿性中断"></a>强迫性中断和自愿性中断</h3><p>按中断事件的性质和激活方式可将中断分成两类：强迫性中断和自愿性中断。</p>
<ul>
<li>强迫性中断不是正在运行的程序所期待的，是由随机事件或外部请求信息引起的。强迫性中断事件有以下几种：<ul>
<li>机器故障中断：机器执行指令过程中硬件可能出现种种事件，例如，电源故障、通路校验错误、主存出错等；</li>
<li>程序性中断：程序执行过程中可能发生种种例外情况，例如：非操作码错误、定点溢出、除数为0、地址越界；</li>
<li>外部中断：由计算机系统外部发送中断信号，反映外界对本机的种种要求，例如，时钟中断、控制台中断、它机中断等；</li>
<li>输入输出中断：来自通道、控制器、设备的中断能够反应I/O操作情况，例如：设备出错、传输结束、启动失败等；</li>
</ul>
</li>
<li>自愿性中断事件是正在运行的程序所期待的，是由于执行“访管指令”而引起的，它表示运行程序对操作系统由某种需求，一旦机器执行访管指令，就会使CPU状态从用户态转向核心态，停止现行程序的执行而转入内核的相应系统调用例程进行处理。例如：要求操作系统协助启动外部设备工作。</li>
</ul>
<h3 id="硬中断和软中断"><a href="#硬中断和软中断" class="headerlink" title="硬中断和软中断"></a>硬中断和软中断</h3><p>按中断事件的来源和实现手段划分可以将中断划分为硬中断和软中断。</p>
<ul>
<li>硬中断可划分为外中断和内中断：<ul>
<li>外中断又称中断或异步中断，是指来自处理器之外的信号，包括时钟中断、键盘中断、它机中断和设备中断等。外中断又分为可屏蔽中断和不可屏蔽中断，各个中断具有不同的中断优先级，表示事件的紧急程度，在处理高一级中断时，往往会部分或全部屏蔽低级中断；</li>
<li>内中断又称异常或同步中断，是指来自处理器内部的中断信号，通常是由于在程序执行过程中，发现与当前指令关联的、不正常的或错误的事件。</li>
</ul>
</li>
<li>软中断：外中断和内中断（中断和异常）要通过硬件设施来产生中断请求，他们都是硬中断。与其对应的，不必由硬件产生中断源而引发的中断称为软中断。软中断利用硬中断中的概念，采用软件方法对中断机制进行模拟，实现宏观上的异步执行。软中断可分为两种：<ul>
<li>“信号”是一种软中断机制，信号的发送者相当于中断源，而信号的接收者必然是一个进程（相当于CPU）；</li>
<li>“软件中断”是另一种软件中断机制，其第一个典型应用的例子是 Linux 中的 bottom half，它的升级就是Linux中最复杂、最庞大的软中断子系统 softirq 机制；第二个典型应用例子是 Windows 中由内核发出的Dispatch/DPC 和 APC 等中断，用于启动线程调度。延迟过程调用和异步过程调用的执行；</li>
</ul>
</li>
</ul>
<h4 id="硬中断和软中断的类比"><a href="#硬中断和软中断的类比" class="headerlink" title="硬中断和软中断的类比"></a>硬中断和软中断的类比</h4><p>“中断”（硬中断）：用于外部设备对CPU的中断（中断正在运行的任何程序），转向中断处理程序执行；</p>
<p>“异常”（硬中断）：因指令执行不正常而中断CPU（中断正在执行这条指令的程序），转向异常处理程序执行；</p>
<p>“软件中断”（软中断）：用于硬中断服务程序对内核的中断，在上半部分中发出软件中断（即标记下半部分），使得中断下半部分在适当时刻获得处理；</p>
<p>“信号”（软中断）：用于内核或进程对某个进程的中断，向进程通知某个特定事件发生或迫使进程执行信号处理程序。</p>
<h3 id="中断-异常的过程："><a href="#中断-异常的过程：" class="headerlink" title="中断/异常的过程："></a>中断/异常的过程：</h3><ol>
<li>发现中断源：在中断未被屏蔽的前提下，硬件发现中断/异常事件，并由CPU相应中断/异常请求。当发生多个中断源时，将根据预定的优先级先后相应中断请求；</li>
<li>保护现场：暂停当前程序的运行，硬件将中断点的现场信息（PSW）保存至核心栈，使得中断处理程序/异常处理程序在运行时，不会破坏中断程序中的有用信息，以便在中断结束后返回源程序继续运行；</li>
<li>转向中断/异常事件的处理程序：这时处理器状态已从用户态切换至核心态，中断处理程序/异常处理程序开始工作；</li>
<li>恢复现场：当中断处理结束后，恢复PSW，重新返回中断点以便执行后续指令。</li>
</ol>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程定义"><a href="#进程定义" class="headerlink" title="进程定义"></a>进程定义</h3><p>进程是操作系统中最基本、最重要的概念，是在多道程序系统出现后，为了刻画系统内部的动态状况、描述运行程序的活动规律而引进的新概念，所有多道程序设计操作系统都建立在进程的基础上。</p>
<p>从理论的角度看，进程的概念是对当前运行程序的活动规律的抽象；从实现角度看，进程是一种数据结构，用来准确刻画系统动态变化的内在规律，有效地管理和调度在计算机系统主存运行的程序。</p>
<p>引入进程的目的，一是为了刻画系统的动态性，发挥系统的并发性；二是解决共享性，正确地描述程序的执行状态。</p>
<p>所以，进程的定义如下：<strong>进程是可并发执行的程序在某个数据集合上的一次计算活动，也是操作系统进行资源分配和保护的基本单位。</strong></p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>三态模型：</p>
<ul>
<li>运行态：进程占用处理器运行的状态；</li>
<li>就绪态：进行具备运行条件，等待系统分配处理器以便其运行的状态；</li>
<li>等待态：又称阻塞态或睡眠态，指系统不具备运行条件，正在等待某个事件完成的状态；</li>
</ul>
<p>五态模型：</p>
<p>在很多系统中，增加两个进程状态，新建态和终止态</p>
<p>新建态：进程被创建时的状态，进程尚未进入就绪状态。创建进程要通过两个步骤，首先，为进程分配所需的资源，建立必要的管理信息，然后，置此进程为就绪态，等待被执行；</p>
<p>终止态：进程完成任务，到达正常结束点，或因出现无法克服的错误而异常终止，或被操作系统及有终止权限的进程所终止时所处的状态；</p>
<h3 id="处理器调度算法"><a href="#处理器调度算法" class="headerlink" title="处理器调度算法"></a>处理器调度算法</h3><h4 id="先来先服务（FCFS）"><a href="#先来先服务（FCFS）" class="headerlink" title="先来先服务（FCFS）"></a>先来先服务（FCFS）</h4><ul>
<li>按作业进入系统后背作业队列的先后次序来挑选作业，先进入系统的作业将优先被挑选进入主存，创建用户进程，分配所需资源，然后移入就绪队列；</li>
<li>非剥夺式调度算法；</li>
<li>只顾作业的等待时间，未考虑作业要求服务时间的长短，不利于短作业而优待长作业，不利于I/O繁忙型作业而有利于CPU繁忙型作业；</li>
<li>FCFS算法同样适用于进程/线程调度，每次从就绪队列中选择最先进入此队列的进程/线程，它一直运行，直至完成或出现等待事件而被阻塞而让出处理器为止；</li>
</ul>
<p>需要说明的是，在进行处理器调度时，允许作业调度和进程/线程调度分别采用不同的调度算法，而且往往需要采用不同的调度算法处理这两级调度。</p>
<h4 id="最短作业优先（SJF）"><a href="#最短作业优先（SJF）" class="headerlink" title="最短作业优先（SJF）"></a>最短作业优先（SJF）</h4><ul>
<li>以进入系统的作业所要求的CPU运行时间的长短为标准，总是选取预计计算时间最短的作业投入运行；</li>
<li>非剥夺式调度算法；</li>
<li>需要预先直到作业所需的CPU运行时间，很难精确估算；忽视作业的等待时间，进入系统时间早但计算时间长的长作业有可能出现饥饿现象；</li>
<li>SJF也可以用于低级调度，借用作业的估计运行时间作为进程/线程的估计运行时间，调度时从就绪队列中选择一个估计运行时间最短者投入运行。若具有相同的估计运行时间，就对其按照FCFS算法处理；</li>
</ul>
<h4 id="最短剩余时间"><a href="#最短剩余时间" class="headerlink" title="最短剩余时间"></a>最短剩余时间</h4><ul>
<li><p>上面的最短作业优先算法是非剥夺式，可将其改造为剥夺式调度算法；</p>
</li>
<li><p>假设当前某进程/线程正在运行，如果有新进程/线程移入就绪队列，若它的所需的CPU运行时间比当前运行进程/线程所需的剩余CPU时间还短，抢占式最短作业优先算法强行剥夺当前执行者的控制权，调度新进程/线程执行，这叫做最短剩余时间优先算法；</p>
</li>
</ul>
<h4 id="响应比最高优先"><a href="#响应比最高优先" class="headerlink" title="响应比最高优先"></a>响应比最高优先</h4><ul>
<li>响应比最高优先是介于FCFS和SJF算法之间的一种折衷的<strong>非剥夺式算法</strong>，即考虑作业的等待时间，又考虑作业的处理时间，这样既照顾短作业又不会使长作业等待时间过长；</li>
<li>缺点是每次计算各道作业的响应比会导致一定的时间开销，其性能比SJF略差。等待时间与处理时间之和是系统对作业的响时间，它与处理时间的比值称为响应比。</li>
</ul>
<h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><ul>
<li>根据确定的优先级来选取进程/线程，总是选择就绪队列中的优先级最高者投入运行；</li>
<li>系统可以预先规定策略：剥夺式与非剥夺式；</li>
<li>进程/线程的优先级的确定可采用静态式/动态式，基本原则是：正在运行的进程/线程随着占用CPU的时间的增加，逐渐降低其优先级；就绪队列中等待CPU的进程/线程随着等待时间的增加，逐渐提高其优先级，这样可以克服静态优先级饥饿的问题。</li>
</ul>
<h4 id="轮转调度"><a href="#轮转调度" class="headerlink" title="轮转调度"></a>轮转调度</h4><ul>
<li>也称时间片调度算法。调度程序每次把CPU分配给就绪队列队首进程/线程使用规定的时间间隔，称为时间片。就绪队列中每个进程/线程轮流地运行一个时间片，当时间片耗尽，就强迫当前运行的进程/线程让出处理器，转而排列到就绪队列的尾部，等待下一轮调度；</li>
<li>剥夺式调度；</li>
<li>系统耗费在进程/线程切换上的开销比较大，这个开销与时间片取值有关；</li>
</ul>
<h4 id="多级反馈队列调度"><a href="#多级反馈队列调度" class="headerlink" title="多级反馈队列调度"></a>多级反馈队列调度</h4><ul>
<li>操作系统建立一个多个就绪队列，每个队列对应一个优先级，第一个队列的优先级最高，其后的队列的优先级逐渐降低；</li>
<li>较高优先级队列的进程/线程分配给较短的时间片，较低优先级队列的进程/线程分配给较长的时间片，最后一个队列进程/线程按FCFS算法进行调度；</li>
<li>处理器调度每次先从第一个队列选取执行者，同一队列中的进程/线程按照FCFS原则排队，只有在未选到时，才从较低一级的就绪队列中选取，仅当前面所有队列为空时，才会运行最后一个就绪队列中的进程/线程；</li>
</ul>
<h1 id="同步、通信与死锁"><a href="#同步、通信与死锁" class="headerlink" title="同步、通信与死锁"></a>同步、通信与死锁</h1><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程间通信主要包括管道、系统 IPC（包括消息队列、信号量、信号、共享内存等） 、以及套接字 socket。</p>
<ul>
<li><p>管道</p>
<p>管道主要包括无名管道和命名管道：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</p>
<ul>
<li>普通管道 PIPE：<ul>
<li>它是<strong>半双工的</strong>（即数据只能在一个方向上流动），具有固定的读端和写端；</li>
<li>它只能用于<strong>具有亲缘关系的进程之间的通信</strong>（也是父子进程或者兄弟进程之间）；</li>
<li>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中；</li>
</ul>
</li>
<li>命名管道 FIFO：<ul>
<li>FIFO 可以<strong>在无关的进程之间交换数据</strong>；</li>
<li>FIFO 有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</li>
</ul>
</li>
</ul>
</li>
<li><p>系统 IPC</p>
<ul>
<li>消息队列<ul>
<li>消息队列，是消息的链接表，存放在内核中。 一个消息队列由一个标识符（即队列 ID）来标记。<strong>消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点</strong>。具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</li>
<li>特点<ul>
<li>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级；</li>
<li>消息队列独立于发送与接收进程。 进程终止时，消息队列及其内容并不会被删除；</li>
<li>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取；</li>
</ul>
</li>
</ul>
</li>
<li>信号量 semaphore<ul>
<li>信号量（semaphore） 与已经介绍过的 IPC 结构不同，<strong>它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步</strong>，而不是用于存储进程间通信数据；</li>
<li>特点<ul>
<li>信号量用于进程间同步，若要在进程间传递数据需要结合共享内存；</li>
<li>信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作；</li>
<li>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数；</li>
<li>支持信号量组；</li>
</ul>
</li>
</ul>
</li>
<li>信号 signal<ul>
<li>信号是一种比较复杂的通信方式，<strong>用于通知接收进程某个事件已经发生</strong>；</li>
</ul>
</li>
<li>共享内存 Shared Memory<ul>
<li>它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。 这种方式需要依靠某种同步操作，如互斥锁和信号量等</li>
<li>特点<ul>
<li>共享内存是<strong>最快的一种 IPC</strong>，因为进程是直接对内存进行存取；</li>
<li>因为多个进程可以同时操作，所以需要进行同步；</li>
<li>信号量 + 共享内存通常结合在一起使用，信号量用来同步对共享内存的访问；</li>
</ul>
</li>
</ul>
</li>
<li>套接字 SOCKET<ul>
<li>与其他通信机制不同的是， SOCKET 可用于<strong>不同主机之间的进程通信</strong>；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="线程间通信与同步"><a href="#线程间通信与同步" class="headerlink" title="线程间通信与同步"></a>线程间通信与同步</h2><ul>
<li><p>临界区：通过<strong>多线程的串行化来访问公共资源或一段代码</strong>，速度快，适合控制数据访问；</p>
</li>
<li><p>互斥量 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。<strong>因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</strong>；</p>
</li>
<li><p>信号量 Semphare：为控制具有有限数量的用户资源而设计的，它<strong>允许多个线程在同一时刻去访问同一个资源</strong>，但一般需要限制同一时刻访问此资源的最大线程数目；</p>
</li>
<li><p>事件(信号) Wait/Notify：<strong>通过通知操作的方式来保持多线程同步</strong>，还可以方便的实现多线程优先级的比较操作；</p>
</li>
</ul>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程非常类似于线程。但是<strong>协程是协作式多任务的</strong>，而<strong>线程是抢占式多任务的</strong>。这意味着协程提供并发性而非并行性。</p>
<p>协程超过线程的好处是它们可以用于硬性实时的语境（<strong>在协程之间的切换不需要涉及任何系统调用或任何阻塞调用</strong>），这里不需要用来守卫关键区块的同步性原语（primitive）比如互斥锁、信号量等，并且不需要来自操作系统的支持。</p>
<p>有可能以一种对调用代码透明的方式，使用抢占式调度的线程实现协程，但是会失去某些利益，特别是对硬性实时操作的适合性和相对廉价的相互之间切换。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁产生"><a href="#死锁产生" class="headerlink" title="死锁产生"></a>死锁产生</h3><ul>
<li><p>互斥条件：系统中存在临界资源，进程应互斥地使用这些资源；</p>
</li>
<li><p>占有和等待条件：进程在请求资源得不到满足而等待时，不释放已占有的资源；</p>
</li>
<li><p>不剥夺条件：已被占用的资源只能由属主释放，不允许被其他进程剥夺；</p>
</li>
<li><p>循环等待条件：存在循环等待链，其中，每个进程都在链中等待下一个进程所持有的资源，造成这组进程处于永远等待状态；</p>
</li>
</ul>
<p>前三个条件是死锁存在的必要条件，但不是充分条件，第4个条件是前3个条件同时存在时所产生的结果，故条件并不完全独立。但是，单独考虑每个条件是有用的，只要能破坏4个必要条件中的一个，就可以防止死锁。</p>
<p>解决死锁问题有三种策略和方法：死锁防止、死锁避免、死锁检测和解除。</p>
<h3 id="死锁防止"><a href="#死锁防止" class="headerlink" title="死锁防止"></a>死锁防止</h3><p>死锁的防止是指系统预先确定资源分配策略，进程按此规定来申请和使用资源，<strong>保证死锁有一个必要条件不会被满足，使得系统不发生死锁</strong>；其缺点是降低系统的并发性质，资源利用率低。</p>
<h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>死锁避免允许系统中同时存在前3个必要条件，通过合适的资源分配算法确保不会出现进程循环等待链，从而避免死锁。</p>
<p>死锁避免方法能支持更多的进程并发执行，它不是对进程随意强加规则，而是动态地确定是否分配资源给提出请求的进程。如果一个进程当前请求的资源会导致死锁，系统将拒绝启动该进程；如果一个资源的分配会导致下一步死锁，系统会拒绝本次分配。</p>
<p>银行家算法是的死锁避免算法，但缺乏实用价值。</p>
<h3 id="死锁检测与恢复"><a href="#死锁检测与恢复" class="headerlink" title="死锁检测与恢复"></a>死锁检测与恢复</h3><p>对资源的分配加以适当的限制可防止和避免死锁的发生，但是不利于进程对系统资源的充分共享。解决死锁的另一条路径是死锁检测和解除，这种方法对资源的分配不施加任何限制，也不采取死锁避免措施，系统定时地运行死锁检测程序，判断是否已经出现死锁，如果检测到系统已死锁，再采取措施解除它。</p>
<p>这种方法的难点在于：要确定何时运行死锁检测算法，如果这一算法执行的很频繁，将会浪费处理器时间；如果执行太稀疏，则死锁进程和系统资源会一直被锁定。</p>
<h1 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h1><p>存储管理是操作系统的重要组成部分，负责管理计算机系统的重要资源-主存储器。由于任何程序和数据必须占用主存空间才能得以执行和处理，因此，存储管理的优劣直接影响操作系统的性能。主存储器对数据的存取比处理器处理数据的速度慢得多，通过高速缓存可以部分缩小差距，但高效的主存管理仍然是操作系统设计中重要课题。</p>
<p>主存空间一般分为两部分：一部分是<strong>系统区</strong>，用于存放操作系统内核程序和数据结构等，另一部分是<strong>用户区</strong>，用于存放应用程序和数据。存储管理对核心区和用户区都提供相应的支持和管理。尽管现代计算机的主存容量不断增大，但仍不能保证有足够大的空间支持大型应用和系统程序及数据的使用。操作系统的主要任务之一是尽可能方便用户使用和提高主存利用率。存储管理的主要作用如下：</p>
<ul>
<li><p>分配和去配：进程可请求对主存区的独占式使用，主存区的请求和释放即主存空间的分配和去配操作由存储管理完成；</p>
</li>
<li><p>抽象和映射：主存储器被抽象，使得进程认为分配给他的地址空间是一个大且连续地址所组成的数组，或者把主存储器抽象成二维地址空间，以支持模块化程序设计；同时建立抽象机制支持进程用逻辑地址来映射到物理主存单元，实现地址转换；</p>
</li>
<li><p>隔离和共享：系统负责隔离已分配给进程的主存区，互不干扰免遭破坏，确保进程对存储单元的独占式使用，以实现存储保护功能；系统允许多个进程共享存储区，在这种情况下，超越隔离机制并授权进程允许共享访问，达到既能提高主存利用率又能共享主存某区内信息的目的；</p>
</li>
<li><p>主存扩容：物理主存容量不应限制应用程序的大小，主存和辅助存储器被抽象为虚拟主存，允许用户的虚拟地址空间大于主存物理地址空间，存储管理自动在不同的存储层次中移动信息；</p>
</li>
</ul>
<h2 id="连续存储管理"><a href="#连续存储管理" class="headerlink" title="连续存储管理"></a>连续存储管理</h2><h3 id="固定分区存储管理"><a href="#固定分区存储管理" class="headerlink" title="固定分区存储管理"></a>固定分区存储管理</h3><p>固定分区存储管理的基本思想是：主存空间被划分成数目固定不变的分区，各分区的大小不等，每个分区只装入一个作业，若多个分区中都装有作业，则它们可以并发执行，这是支持多道程序设计的最简单的存储管理技术。</p>
<h2 id="地址转换与存储保护"><a href="#地址转换与存储保护" class="headerlink" title="地址转换与存储保护"></a>地址转换与存储保护</h2><p>磁盘中的装载代码模块所使用的是<strong>逻辑地址</strong>，其逻辑地址集合称为进程的逻辑地址空间。逻辑地址可以是一维的，这时逻辑地址限制在从0开始的顺序排列的地址空间内；逻辑地址空间也可以是二维的，这是整个程序被分为若干段，每段都有不同的编号，段内地址从0开始顺序编址。</p>
<p>物理主存储器从统一的基地址开始顺序编址的存储单元称为<strong>物理地址或绝对地址</strong>，物理地址的总体构成物理地址空间。需要注意的是，物理地址空间是由存储器地址总线扫描出来的空间，其大小取决于实际安装的主存容量。</p>
<p>把逻辑地址转化为物理地址的过程称为<strong>地址重定位</strong>、地址映射或地址转换。与静态地址重定位相比，<strong>动态地址重定位具有允许程序在主存中移动、便于程序共享和主存利用率高等优点。</strong></p>
<h2 id="可变分区存储管理"><a href="#可变分区存储管理" class="headerlink" title="可变分区存储管理"></a>可变分区存储管理</h2><p>常用的可变分区分配算法有以下五种：</p>
<ul>
<li>最先适应分配算法：最先适应分配算法顺序查找未分配区表或链表，直至找到第一个能满足长度要求的空闲分区为止，分割此分区，一部分分配给作业，另一部分仍为空闲区（若有）；</li>
<li>下次适应分配算法：下次适应分配算法总是从未分配区的上一次扫描结束处顺序查找未分配区表或链表，直至找到<strong>第一个能满足长度要求的空闲区为止</strong>。这是最先适应分配算法的变种，<strong>能缩短平均查找时间，且存储空间利用率更加均衡，不会导致小空闲区集中于主存储器的一端</strong>；</li>
<li>最优适应分配算法：最优适应分配算法扫描整个未分配区表或链表，<strong>从空闲区挑选一个能满足用户进程要求的最小的分区进行分配</strong>。此算法保证不会分割更大的区域，使得装入<strong>大作业的要求容易得到满足</strong>。同时，通常把空闲区按长度递增顺序排列，查找时总是从最小的一个空闲区开始，直至找到满足要求的分区为止，此时最优适应分配算法等同于最先适应分配算法。此算法主存利用率好，所找出的分区如果正好满足要求则是最合适的。<strong>如果比所要求的分区略大则分割后使剩下的空闲分很小，难以利用，其查找时间也是最长的</strong>；</li>
<li>最坏适应分配算法：最坏适应分配算法扫描整个未分配区表或链表，<strong>总是挑选一个最大的空闲区分割给作业使用，其优点是使剩下二点空闲区不至过小，对中小型作业有利</strong>。采用此分配算法可把空闲区按照长度递减顺序排列，查找时只需看第一个分区能否满足进程需求，这样使最坏适应分配算法的查找效率很高，此时，最坏适应分配算法等同于最先适应分配算法；</li>
<li>快速适应分配算法：快速适应分配算法为那些<strong>经常用到的长度的空闲区设立单独的空闲区链表</strong>；</li>
</ul>
<h2 id="分页存储管理"><a href="#分页存储管理" class="headerlink" title="分页存储管理"></a>分页存储管理</h2><p>用分区方式管理存储器，每道程序要求占用主存的一个或多个连续存储区域，<strong>导致主存中产生“碎片”</strong>。有时为了接纳新作业，<strong>往往需要移动已在主存的信息</strong>，这样不仅不方便，而处理器的开销太大。</p>
<p><strong>采用分页存储管理允许程序存放到若干不相邻的空闲块中，既可免除移动信息工作，又可以充分利用主存空间，消除动态分区法中的”碎片“问题，从而提高主存空间的利用率。</strong></p>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>页面：进程逻辑地址空间划分成大小相等的区，每个区称为页面或页，页号从0开始依次编号；</p>
<p>页框：页框又称页帧，把主存物理地址空间分成大小相等的区，其大小与页面大小相等，每个区是一个物理块或页框，块号从0开始依次编号；</p>
<p>逻辑地址：分页存储器的逻辑地址由两部分组成，页号和页内偏移，格式为：页号 页内偏移；</p>
<p><strong>页号表示地址所在页面的编号</strong>，后面部分表示页内偏移。计算机地址总线通常是32位，页面尺寸若规定为12位（页长 4KB），那么，页号共20位，表示地址空间最多包含2^20个页面。</p>
<p>采用分页存储管理时，逻辑地址是连续的，用户在编制程序时仍使用相对地址，不必考虑如何分页，由硬件地址转换机构和操作系统的管理来决定页面尺寸，从而确定主存分块大小。<strong>进程在主存中的每个页框内的地址是连续的，但页框之间的地址可以不连续</strong>，<strong>进程主存地址由连续到离散的变化为虚拟存储器的实现奠定了基础。</strong></p>
<p>页表：使用<strong>动态地重定位技术</strong>，让程序在执行时动态地进行地址变换，由于程序以页面为单位进行存储，所以为<strong>每个页面设立一个重定位寄存器，这些重定位寄存器地集合称为页表</strong>。页表是操作系统为进程建立的，是程序页面和主存对应页框的对照表，页表中的每一栏指明程序中的一个页面和分得页框的对应关系。<strong>使用页表的目的是把页面映射为页框。</strong></p>
<h4 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h4><p>页表可存放在一组寄存器中，地址转换时只要从相应寄存器中取值就可以得到页框号，这样做虽然能加快地址转换，但硬件代价太高；页表也可以放在主存中，这样做可以降低系统开销，但是<strong>按照给定逻辑地址进行读写操作时，至少访问主存两次：一次访问页表，另一次根据物理地址访问指令或存取数据</strong>，这样降低运算速度，比通常执行指令的速度慢一半。</p>
<p><strong>为了提高运算速度，在硬件中设置相联存储器，用来存放进程最近访问的部分页表项，也称转换后缓冲（Transaction Lookaside Buffer， TLB）或者快表，它是分页存储管理的重要组成部分</strong>。</p>
<p>快表的存取时间远小于内存，速度快但造价高，故容量较小，只能存放几十个页表项。<strong>快表包含页号和对应的页框号，当把页号交给快表后，它通过并行匹配同时对所有快表项进行比较，如果找到，则立即输出页框号，并形成物理地址；如果找不到，再查找主存中的页表以形成物理地址，同时将页号及页框号登记到快表中，当快表已满且要登记新页时，系统需要淘汰旧的快表项，</strong>最简单的策略就是先进先出，总是淘汰最先登记的页。需要注意的是，快表和高速换粗是不同的，两者再一个系统中可同时使用，前者记录最近转换的页号及页框号，后者保存最近实际访问的指令或者数据副本。</p>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>现代操作系统普遍支持2^32~2^64B容量的逻辑地址空间，采用分页存储管理时，<strong>页表相当大</strong>。</p>
<p>以Windows为例，其运行的Intel x86 平台具有32位地址，规定页面4KB（2^12）, 那么4GB（2^32）的逻辑地址空间由1M（2^20）个页组成，若每个页表项占用4B，则需要占用4MB（2^20）连续主存空间来存放页表，这还是一个进程的地址空间。对于地址空间为64位的系统而言，问题会更加复杂。</p>
<p>为此， <strong>页表和页面一样也需要进行分页</strong>，这就是多级页表的概念。具体做法是：<strong>把整个页表分割成许多小页表，每个小页表称为页表页，其大小与页框长度相同，于是，每个页表页含有若干页表表项</strong>。</p>
<h2 id="分段存储管理"><a href="#分段存储管理" class="headerlink" title="分段存储管理"></a>分段存储管理</h2><p>促使存储管理方式从固定分区到动态分区，<strong>从分区方式向分页方式发展的主要原因是要提高主存空间利用率</strong>。那么，<strong>分段存储管理的引入主要满足用户（程序员）编程和使用上的要求</strong>，其他存储管理技术难以满足这些要求。</p>
<p>在分页存储管理中，经链接编辑处理得到一维地址结构的可装配目标模块，这是从0开始编址的单一连续逻辑地址空间，虽然可以把程序划分成页面，但<strong>页面与源程序并不存在逻辑关系，也就难以对源程序以模块为单位进行分配、共享和保护</strong>。事实上，程序更多是采用分段结构，高级语言往往采用模块化程序设计方法。应用程序由若干程序段（模块）组成，例如，由主程序段、子程序段、数据段和工作区段组成，每段都从0开始编址，有各自的名字和长度，且实现不同的功能。</p>
<p>分段存储管理把进程的逻辑地址空间分成多段，二维逻辑地址形式为：段号 段内位移。<strong>分段存储管理的实现基于可变分区存储管理的原理</strong>。<strong>可变分区以整个作业为单位来划分和连续存放，也就是说，作业在分区内是连续存放的，但独立作业之间不一定连续存放</strong>。而<strong>分段方法是以段位单位来划分和连续存放，为作业的各段分配一个连续的主存空间，而各段之间不一定连续</strong>。在进行存储分配时，应为进入主存的作业建立段表，各段在主存中的情况可由段表来记录，它指出主存中各分段的段号、段起始地址和段长度。在撤销进程时，回收所占用的主存空间，并清除此进程的段表。</p>
<h2 id="分段和分页的比较"><a href="#分段和分页的比较" class="headerlink" title="分段和分页的比较"></a>分段和分页的比较</h2><p>分段是<strong>信息的逻辑单位由源程序的逻辑结构及含义所决定</strong>，是<strong>用户可见</strong>的，<strong>段长由用户根据需求来决定</strong>，段起始地址可以从任何主存地址开始。在分段方式中，源程序（段号、段内位移）经链接装配后仍保持二维（地址）结构，<strong>引入目的是满足用户模块化程序设计的需要</strong>。</p>
<p>分页是<strong>信息的物理单位与源程序的逻辑结构无关</strong>，是<strong>用户不可见</strong>的，<strong>页长由系统（硬件）确定</strong>，页面只能从页大小的整数倍地址开始。在分页方式中，源程序（分页、页内位移）经链接装配后变成一维（地址）结构，<strong>引入的目的是实现离散分配并提高主存利用率</strong>。</p>
<h2 id="虚拟存储管理"><a href="#虚拟存储管理" class="headerlink" title="虚拟存储管理"></a>虚拟存储管理</h2><p><strong>前面介绍的存储管理称为实存管理，必须为进程分配足够的主存空间，装入其全部信息，否则进程无法运行</strong>。把进程的全部信息装入主存后，实际上并非同时使用，有些部分运行一遍，有些部分甚至从来不使用，进程在运行时不用的，或暂时不用的，或某些条件下才用的程序和数据，全部驻留于主存中是对宝贵存储资源的一种浪费，降低主存的利用率。于是，提出新的想法：<strong>不必装入进程的全部信息，仅将当前使用部分先装入主存，其余部分存放在磁盘中，待使用时由系统自动将其装进来，这就是虚拟存储管理技术的基本思路。</strong></p>
<p>虚拟存储器的定义：<strong>在具有层次结构存储器的计算机系统中，自动实现部分装入和部分替换的功能，能从逻辑上为用户提供一个比物理主存容量大得多的、可寻址的”主存储器“。</strong></p>
<p><strong>虚拟内存</strong>使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如 RAM）的使用也更有效率。目前，大多数操作系统都使用了虚拟内存，如 Windows 家族的“虚拟内存”；Linux 的“交换空间”等。</p>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>局部性原理表现在以下两个方面：</p>
<ul>
<li><p><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着<strong>大量的循环操作</strong>；</p>
</li>
<li><p><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为<strong>指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的</strong>；</p>
</li>
</ul>
<p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。</p>
<p>空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p>
<h3 id="请求分页虚拟存储管理"><a href="#请求分页虚拟存储管理" class="headerlink" title="请求分页虚拟存储管理"></a>请求分页虚拟存储管理</h3><h4 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h4><p>现代处理器使用的是一种称为虚拟寻址(Virtual Addressing) 的寻址方式。使用虚拟寻址，CPU 需要将逻辑地址翻译成物理地址，这样才能访问到真实的物理内存。完成虚拟地址转换为物理地址转换的硬件是 CPU 中的 MMU。</p>
<p>注：操作系统的存储管理依靠底层硬件的支撑来完成任务，此硬件称为主存管理部件（Memory Management Unit，MMU），它提供地址转换和存储保护功能，并支持虚拟存储管理和多任务管理。</p>
<h4 id="虚拟地址空间的作用"><a href="#虚拟地址空间的作用" class="headerlink" title="虚拟地址空间的作用"></a>虚拟地址空间的作用</h4><p>没有虚拟地址空间的时候，<strong>程序直接访问和操作的都是物理内存</strong>，会存在以下问题： </p>
<ul>
<li><p>用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃；</p>
</li>
<li><p>想要同时运行多个程序比较困难。例如微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这可能会造成微信崩溃；</p>
</li>
</ul>
<p>总结来说：如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难。</p>
<p>虚拟内存技术使得不同进程在运行过程中， 它所看到的是自己独自占有了当前系统的 4G 内存。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。 事实上，在每个进程创建加载时，内核只是为进程“创建” 了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data 段）拷贝到物理内存中， 只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中， 要动态分配内存，比如 malloc 时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</p>
<p>请求分页系统、 请求分段系统和请求段页式系统都是针对虚拟内存的， 通过请求实现内存与 外存的信息置换。</p>
<h5 id="虚拟内存的好处"><a href="#虚拟内存的好处" class="headerlink" title="虚拟内存的好处"></a>虚拟内存的好处</h5><ul>
<li><p>扩大地址空间；</p>
</li>
<li><p>内存保护：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还对特定 的内存地址提供写保护，可以防止代码或数据被恶意篡改；</p>
</li>
<li><p>公平内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间；</p>
</li>
<li><p>当进程通信时，可采用虚存共享的方式实现；</p>
</li>
<li><p>当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存；</p>
</li>
<li><p>虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把 CPU 交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高；</p>
</li>
<li><p>在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片；</p>
</li>
</ul>
<h5 id="虚拟内存的代价"><a href="#虚拟内存的代价" class="headerlink" title="虚拟内存的代价"></a>虚拟内存的代价</h5><ul>
<li><p>虚存的管理需要建立很多数据结构，占用额外的内存；</p>
</li>
<li><p>虚拟地址到物理地址的转换，增加了指令的执行时间；</p>
</li>
<li><p>页面的换入换出需要磁盘 I/O，较为耗时；</p>
</li>
<li><p>如果一页中只有一部分数据，会浪费内存。</p>
</li>
</ul>
<h4 id="虚拟内存技术的实现"><a href="#虚拟内存技术的实现" class="headerlink" title="虚拟内存技术的实现"></a>虚拟内存技术的实现</h4><p>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。虚拟内存的实现有以下三种方式：</p>
<ul>
<li><p><strong>请求分页存储管理</strong> ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</p>
</li>
<li><p><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</p>
</li>
<li><p><strong>请求段页式存储管理</strong></p>
</li>
</ul>
<h4 id="请求分页存储与分页存储"><a href="#请求分页存储与分页存储" class="headerlink" title="请求分页存储与分页存储"></a>请求分页存储与分页存储</h4><p>请求分页存储管理建立在分页管理之上，根本区别是是否将程序全部所需的全部地址空间都装入主存，请求分页存储管理不要求将作业全部地址空间同时装入主存，这也是请求分页存储管理可以提供虚拟内存的原因。</p>
<p>不管是上面那种实现方式，一般都需要：</p>
<ul>
<li><p>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</p>
</li>
<li><p><strong>缺页中断</strong>：如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序；</p>
</li>
<li><p><strong>虚拟地址空间</strong> ：逻辑地址到物理地址的变换；</p>
</li>
</ul>
<h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><p>在多道程序的正常运行过程中，属于不同进程的页面被分散存放在准村页框中，当发生缺页中断时，如果已无空闲页框，系统要选择一个驻留页面继进行淘汰。这里讨论的是所有驻留页面都可作为置换对象的情况，而不管页面所属进程的全局页面替换算法。</p>
<p>注：缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。在这个时候，被内存映射的文件实际上成了一个分页交换文件。</p>
<h5 id="最佳页面置换算法"><a href="#最佳页面置换算法" class="headerlink" title="最佳页面置换算法"></a>最佳页面置换算法</h5><p>OPT 选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在主存下的若干页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</p>
<h5 id="先进先出页面置换算法"><a href="#先进先出页面置换算法" class="headerlink" title="先进先出页面置换算法"></a>先进先出页面置换算法</h5><p>FIFO总是淘汰最先调入主存的页面，即选择在主存中驻留时间最久的页面进行淘汰。</p>
<h5 id="最近最久未使用页面置换算法"><a href="#最近最久未使用页面置换算法" class="headerlink" title="最近最久未使用页面置换算法"></a>最近最久未使用页面置换算法</h5><p>LRU淘汰的页面是在最近一段时间内最久未被访问的那一页，是基于程序局部性原理来考虑的，认为那些刚被使用过的页面可能还要被使用，而那些在较长时间内未被使用的页面可能不会立即被使用。</p>
<p>LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</p>
<h5 id="第二次机会页面替换算法"><a href="#第二次机会页面替换算法" class="headerlink" title="第二次机会页面替换算法"></a>第二次机会页面替换算法</h5><p>FIFO算法会把经常使用的页面淘汰掉，为了避免这一点，可对算法继续宁改造，把FIFO算法也页表中的”引用位“结合起来使用，这就是 Second Chance Replacement算法。</p>
<p>实现思想如下：首先检查FIFO页面队列中的队首，这是最早进入主存的页面，如果其”引用位“是0.那么这个页面既时间长又没有用，选择此页面淘汰，如果是1，说明虽然它进入主存的时间比较早，但最近仍然使用，于是将其引用位清0，并把这个页面移至队尾，把它看作一个新调入的页，再给一次机会。</p>
<h5 id="时钟轮转"><a href="#时钟轮转" class="headerlink" title="时钟轮转"></a>时钟轮转</h5><p>如果利用标准队列机制构造 FIFO 队列，SCR算法可能会产生频繁的出队和入队，实现代价较大，可采用循环队列机制构造页面队列，形成类似于钟表面的环形表，队列指针相当于钟表面上的指针，指向可能淘汰的页面，这就是时钟页面淘汰算法的得名。此算法和 SCR 本质上没有什么区别，仅仅是实现方法有所改变，仍然要使用页表中的“引用位”，把进程已调入主存的页面链接成循环队列，用指针指向循环队列中下一个将被替换的页面。</p>
<h5 id="最少使用页面置换算法"><a href="#最少使用页面置换算法" class="headerlink" title="最少使用页面置换算法"></a>最少使用页面置换算法</h5><p>Least Frequently Used 选择在之前时期使用最少的页面作为淘汰页。</p>
<h1 id="select-与-epoll"><a href="#select-与-epoll" class="headerlink" title="select 与 epoll"></a>select 与 epoll</h1><p>这一块是IO多路复用下的知识。</p>
<p><strong>I/O多路复用</strong></p>
<p>IO 复用模型在阻塞 IO 模型上多了一个 select 函数，select 函数有一个参数是文件描述符集合，意思就是对这些的文件描述符进行循环监听，当某个文件描述符就绪的时候，就对这个文件描述符进行处理。</p>
<p>这种 IO 模型是属于阻塞的 IO。 但是由于它可以对多个文件描述符进行阻塞监听，所以它的效率比阻塞 IO 模型高效。</p>
<p>IO 多路复用就是我们说的 select，poll，epoll。 select/epoll 的好处就在于单个 process就可以同时处理多个网络连接的 IO。 它的基本原理就是 select，poll，epoll 这个 function 会不断的轮询所负责的所有 socket，当某个 socket 有数据到达了，就通知用户进程。</p>
<p>当用户进程调用了 select，那么整个进程会被 block，而同时，kernel 会“监视”所有 select负责的 socket，当任何一个 socket 中的数据准备好了，select 就会返回。 这个时候用户进程再调用 read 操作，将数据从 kernel 拷贝到用户进程。</p>
<p>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符） 其中的任意一个进入读就绪状态，select()函数就可以返回。</p>
<p>I/O 多路复用和阻塞 I/O 其实并没有太大的不同，事实上，还更差一些。 因为这里需要使用两个 system call (select 和 recvfrom)，而 blocking IO 只调用了一个 system call (recvfrom)。但是，用 select 的优势在于它可以同时处理多个 connection。</p>
<p>所以，如果处理的连接数不是很高的话，使用 select/epoll 的 web server 不一定比使用multi-threading + blocking IO 的 web server 性能更好，可能延迟还更大。 select/epoll 的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。 ）</p>
<p>在 IO multiplexing Model 中，实际中，对于每一个 socket，一般都设置成为 non-blocking，但是，如上图所示，整个用户的 process 其实是一直被 block 的。 只不过 process 是被 select这个函数 block，而不是被 socket IO 给 block。</p>
<p><strong>select</strong></p>
<p>select：是最初解决IO阻塞问题的方法。用结构体 fd_set 来告诉内核监听多个文件描述符，该结构体被称为描述符集。 由数组来维持哪些描述符被置位了。 对结构体的操作封装在三个宏定义中。 通过轮寻来查找是否有描述符要被处理。</p>
<p>存在的问题：</p>
<ol>
<li>内置数组的形式使得 select 的最大文件数受限与 FD_SIZE；</li>
<li>每次调用 select 前都要重新初始化描述符集，将 fd 从用户态拷贝到内核态，每次调用select 后，都需要将 fd 从内核态拷贝到用户态；</li>
<li>轮寻排查当文件描述符个数很多时，效率很低；</li>
</ol>
<p><strong>poll</strong></p>
<p>poll：通过一个可变长度的数组解决了 select 文件描述符受限的问题。 数组中元素是结构体，该结构体保存描述符的信息，每增加一个文件描述符就向数组中加入一个结构体，结构体只需要拷贝一次到内核态。 poll 解决了 select 重复初始化的问题。 轮寻排查的问题未解决。</p>
<p><strong>epoll</strong></p>
<p>epoll：轮寻排查所有文件描述符的效率不高，使服务器并发能力受限。 因此，epoll 采用只返回状态发生变化的文件描述符，便解决了轮寻的瓶颈。</p>
<p>epoll 对文件描述符的操作有两种模式：LT（level trigger） 和 ET（edge trigger） 。 LT模式是默认模式。</p>
<ol>
<li><p>LT 模式</p>
<p>LT(level triggered)是缺省的工作方式，并且同时支持 block 和 no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。 如果你不作任何操作，内核还是会继续通知你的。</p>
</li>
<li><p>ET 模式</p>
<p>ET(edge-triggered)是高速工作方式，只支持 no-block socket。 在这种模式下，当描述符从未就绪变为就绪时，内核通过 epoll 告诉你。 然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个 EWOULDBLOCK 错误） 。 但是请注意，如果一直不对这个 fd 作 IO 操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p>
<p>ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。 epoll工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
</li>
<li><p>LT 模式与 ET 模式的区别如下：</p>
<p>LT 模式：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。 下次调用 epoll_wait 时，会再次响应应用程序并通知此事件。</p>
<p>ET 模式：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。 如果不处理，下次调用 epoll_wait 时，不会再次响应应用程序并通知此事件。</p>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>操作系统教程第四版 - 高等教育出版社</p>
<p><a href="https://snailclimb.gitee.io/javaguide/#/docs/operating-system/basis" target="_blank" rel="noopener">JavaGuide - 操作系统</a></p>
<p><a href="https://www.cnblogs.com/Anker/p/3271773.html" target="_blank" rel="noopener">孤儿进程与僵尸进程总结</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B" target="_blank" rel="noopener">wiki - 协程</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272" target="_blank" rel="noopener">廖雪峰 - 协程</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98" target="_blank" rel="noopener">虚拟内存</a></p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Operating-System/">Operating System</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/07/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">数据库基础</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">
                        <span class="hidden-mobile">计算机网络基础</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    
  <!-- 备案信息 -->
  <div class="beian">
    <a href="http://beian.miit.gov.cn/" target="_blank"
       rel="nofollow noopener"></a>
    
  </div>


    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 2,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  














</body>
</html>
