<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="Edgecloudsim Java Algorithm">
  <meta name="author" content="">
  <meta name="keywords" content="">
  <title>Java 基础 - 九流人</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 60vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>九流人</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bg/astronaut.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
                Java 基础
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-07-22 17:11">
      2020年7月22日 下午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      12k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      128
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：2020年8月30日 晚上
                
              </p>
            
            <article class="markdown-body">
              <p>以问答的形式梳理 Java 基础中一些重要的知识点。</p>
<a id="more"></a>



<h4 id="简要介绍-JVM"><a href="#简要介绍-JVM" class="headerlink" title="简要介绍 JVM"></a>简要介绍 JVM</h4><p>JVM 是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现，目的是使用相同的字节码，得出相同的结果。</p>
<p>JVM 可以理解的代码就叫做字节码（.class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又有解释型语言可移植的特点。字节码不针对特定的机器，所以 Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
<p>Java 程序从源代码到运行一般有下面 3 步：</p>
<p><img src="Java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" alt=""></p>
<p>需要格外注意 .class -&gt; 机器码这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的（热点代码），所以后面引进了 JIT 编译器，JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，会将字节码对应的机器码保存下来，下次可以直接使用，机器码的运行效率肯定是高于 Java 解释器的。所以说 Java 是编译与解释共存的语言。</p>
<p>HotSpot 采用了惰性评估（Lazy Evaluation）的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），这也是 JIT 需要编译的部分。JVM 会根据代码每次被执行的情况收集信息，做一些相应的优化，因此执行的次数越多，速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，直接将字节码编译成机器码，避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是，AOT 编译器的编译质量比不上 JIT 编译器。</p>
<h4 id="JRE-和-JDK"><a href="#JRE-和-JDK" class="headerlink" title="JRE 和 JDK"></a>JRE 和 JDK</h4><p>JDK 是 Java Development Kit，是功能齐全的 Java SDK。它包含JRE，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>
<p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 JVM、Java 类库、Java 命令和其他一些基础构件。但是，它不能用于创建新程序。</p>
<p>如果只是为了运行 Java 程序的话，那么只安装 JRE 就可以了。如果需要进行 Java 编程方面的工作，就需要安装 JDK。但是，这不是绝对的。有时，即使不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，只是在应用程序服务器中运行 Java 程序。但是，因为应用程序服务器会将 JSP 转换为 Java servlet，需要使用 JDK 来编译 servlet，所以也要安装 JDK。</p>
<h4 id="Java-编译与解释并存"><a href="#Java-编译与解释并存" class="headerlink" title="Java 编译与解释并存"></a>Java 编译与解释并存</h4><p>高级编程语言按照程序的执行方式分为编译型和解释型两种。简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。</p>
<p>Java 语言具有编译型语言和解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码，这种字节码由 Java 解释器来解释执行。</p>
<h4 id="字符型常量和字符串常量"><a href="#字符型常量和字符串常量" class="headerlink" title="字符型常量和字符串常量"></a>字符型常量和字符串常量</h4><p>形式上：字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符。</p>
<p>含义上：字符常量相当于一个整型值（ASCII 值），可以参加表达式运算；字符串常量代表一个地址值（该字符串在内存中存放位置）。</p>
<p>占内存大小：字符常量只占 2 个字节；字符串常量占若干个字节（char 在 Java 中占两个字节)。</p>
<h4 id="Java泛型，类型擦除及常用通配符"><a href="#Java泛型，类型擦除及常用通配符" class="headerlink" title="Java泛型，类型擦除及常用通配符"></a>Java泛型，类型擦除及常用通配符</h4><p>Java 泛型（Generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<p>Java的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</p>
<h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><ul>
<li><p>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝。</p>
</li>
<li><p>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容。</p>
</li>
</ul>
<h4 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h4><ul>
<li><p>重载（overload）：同一个方法根据输入数据的不同，做出不同的处理；</p>
<ul>
<li>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同；</li>
<li>同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理；</li>
</ul>
</li>
<li><p>重写（override）：子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，要覆盖父类方法；</p>
<ul>
<li>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写；</li>
<li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；</li>
<li>如果父类方法访问修饰符为 private/final/static，则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明；</li>
<li>构造方法无法被重写；</li>
<li>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变；</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">区别点</th>
<th align="center">重载方法</th>
<th align="center">重写方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">发生范围</td>
<td align="center">同一个类</td>
<td align="center">子类中</td>
</tr>
<tr>
<td align="center">参数列表</td>
<td align="center">必须修改</td>
<td align="center">不能修改</td>
</tr>
<tr>
<td align="center">返回类型</td>
<td align="center">可修改</td>
<td align="center">不能修改</td>
</tr>
<tr>
<td align="center">异常</td>
<td align="center">可修改</td>
<td align="center">可以减少或删除，不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td align="center">访问修饰符</td>
<td align="center">可修改</td>
<td align="center">不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td align="center">发生阶段</td>
<td align="center">编译期</td>
<td align="center">运行期</td>
</tr>
</tbody></table>
<h4 id="构造器-Constructor"><a href="#构造器-Constructor" class="headerlink" title="构造器 Constructor"></a>构造器 Constructor</h4><p>Constructor 不能被重写，但是可以重载，所以一个类中可以有多个构造函数。</p>
<h4 id="定义不使用且无参的构造方法的作用"><a href="#定义不使用且无参的构造方法的作用" class="headerlink" title="定义不使用且无参的构造方法的作用"></a>定义不使用且无参的构造方法的作用</h4><ul>
<li>Java 程序在执行子类的构造方法之前，如果没用 super() 来调用父类特定的构造方法，则会调用父类中没有参数的构造方法；</li>
<li>因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到无参的构造方法供执行。解决办法是在父类里加上一个不做事且无参的构造方法。</li>
</ul>
<h4 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h4><ul>
<li><p>从语法形式上看：</p>
<ul>
<li>成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；</li>
<li>成员变量可以被 public,private,static 等修饰符修饰，而局部变量不能被访问控制修饰符及 static 修饰；</li>
<li>成员变量和局部变量都能被 final 修饰；</li>
</ul>
</li>
<li><p>从变量在内存中的存储方式来看：</p>
<ul>
<li>如果成员变量使用 static 修饰，那么这个成员变量是属于类的，如果没有用 static 修饰，这个成员变量属于实例；</li>
<li>对象存在于堆内存，局部变量则存在于栈内存；</li>
</ul>
</li>
<li><p>从变量在内存中的生存时间上看：</p>
<ul>
<li>成员变量是对象的一部分，它随着对象的创建而存在；</li>
<li>局部变量随着方法的调用而自动消失；</li>
</ul>
</li>
<li><p>成员变量如果没有被赋初值会自动以类型的默认值而赋值（被 final 修饰的成员变量必须显式地赋值），而局部变量则不会自动赋值；</p>
</li>
</ul>
<h4 id="对象实例与对象引用"><a href="#对象实例与对象引用" class="headerlink" title="对象实例与对象引用"></a>对象实例与对象引用</h4><ul>
<li><p>new 创建对象实例，对象引用指向对象实例；</p>
<ul>
<li>对象实例在堆内存中，对象引用存放在栈内存中；</li>
</ul>
</li>
<li><p>一个对象引用可以指向 0 个或 1 个对象;一个对象可以有 n 个引用指向它；</p>
<ul>
<li>一根绳子可以不系气球，也可以系一个气球；可以用 n 条绳子系住一个气球；</li>
</ul>
</li>
</ul>
<h4 id="构造方法的作用"><a href="#构造方法的作用" class="headerlink" title="构造方法的作用"></a>构造方法的作用</h4><p>类的构造方法的主要作用是完成对类对象的初始化工作。</p>
<p>若一个类没有声明构造方法，该程序也可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了，所以很多时候在不知不觉地使用构造方法，这也是为什么在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果重载了有参的构造方法，可以把无参的构造方法也写出来（无论是否用到），避免在创建对象的时候踩坑。</p>
<p>调用子类构造方法之前先调用父类没有参数的构造方法可以帮助子类进行初始化工作。</p>
<h4 id="构造方法的特性"><a href="#构造方法的特性" class="headerlink" title="构造方法的特性"></a>构造方法的特性</h4><ul>
<li><p>名字与类名相同；</p>
</li>
<li><p>没有返回值，但不能用 void 声明构造函数；</p>
</li>
<li><p>生成类的对象时自动执行，无需调用；</p>
</li>
</ul>
<h4 id="对象的相等与指向他们的引用相等"><a href="#对象的相等与指向他们的引用相等" class="headerlink" title="对象的相等与指向他们的引用相等"></a>对象的相等与指向他们的引用相等</h4><p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p>
<p>“==”相等判断符用于比较基本数据类型和引用类型数据。当比较基本数据类型的时候比较的是数值，当比较引用类型数据时比较的是引用（指针）。</p>
<p>引用数据类型指向堆内存中一个具体的对象。比如 Student stu = new Student();  stu 就是一个引用，它指向的是 new 出来的 Student 对象。当需要操作这个 Student 对象的时候，只需要操作引用即可，比如 int age = stu.getAge()；。</p>
<p>“==”判断两个引用数据类型是否相等的时候，实际上是在判断两个引用是否指向同一个对象。</p>
<p>equals() 和 == 的本质区别的更通俗的说法是：==的比较规则是定死的，就是比较两个数据的值。而 equals() 的比较规则是不固定的，可以由用户自己定义。</p>
<p>如果想执行对象相等性的比较，就要覆盖 hashCode() 和 equals() 方法。</p>
<p>例如 HashSet 类会采用如下方法比较加入的对象是否与已经存在的对象相等：首先调用 hashCode() 比较要加入的对象与已经存在的对象的 hashcode 值，如果不存在相等的hashcode值，则不存在与要加入对象相等的对象，可以加入该对象；如果存在相等的hashcode值，则调用 equals() 检查 hashcode 相等的对象是否真的相等，如果两者相等，则要加入的对象已经存在了，加入操作就不会发生。</p>
<p>注意如果两个对象equal，则它们的hashcode值必须相同（所以如果覆盖了 equals() 方法，也必须同时覆盖 hashCode() 方法），但是如果两个对象具有相同的hashcode 值，它们不一定equal，所以 hashcode 值相同的对象还需要调用 equals() 来判断是否真的相等。</p>
<p>String类已经覆盖了 hashCode() 和 equals() 方法，所以 String 类的 hashCode() 和 equals() 方法执行的是对象相等性的比较。</p>
<h4 id="Java-中-IO-流"><a href="#Java-中-IO-流" class="headerlink" title="Java 中 IO 流"></a>Java 中 IO 流</h4><ul>
<li>按照流的流向分，可分为输入流和输出流；</li>
<li>按照操作单元划分，可划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流；</li>
</ul>
<p>Java IO 流涉及 40 多个类，这些类看上去杂乱，实际很有规则，彼此之间紧密联系， Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生的：</p>
<ul>
<li>InputStream/Reader：所有的输入流的基类，前者是字节输入流，后者是字符输入流；</li>
<li>OutputStream/Writer：所有输出流的基类，前者是字节输出流，后者是字符输出流；</li>
</ul>
<h4 id="字节流与字符流"><a href="#字节流与字符流" class="headerlink" title="字节流与字符流"></a>字节流与字符流</h4><p>问题本质想问：对应文件读写、网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</p>
<p>字符流是由 Java 虚拟机将字节转换得到的，过程比较耗时，并且，如果不知道编码类型容易出现乱码问题。所以，I/O 流提供了一个直接操作字符的接口，方便平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>序列化是指把一个Java对象变成二进制内容，本质上就是一个 byte[] 数组。将 Java 对象进行序列化的原因是，序列化后可以把 byte[] 保存到文件中，或者把 byte[] 通过网络传输到远程，这样，就相当于把 Java 对象存储到文件或者通过网络传输出去了。反序列化指的是把一个二进制内容（byte[] 数组）变回 Java 对象。反序列化可以将保存在文件中的 byte[] 数组转换为 Java 对象，或者从网络上读取 byte[] 并把它转换为 Java 对象。</p>
<p>一个 Java 对象要能序列化，必须实现一个特殊的 java.io.Serializable 接口，它的定义如下。Serializable 接口没有定义任何方法，它是一个空接口。这样的空接口称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Serializable</span> </span>&#123;
&#125;</code></pre>



<p>因为 Java 的序列化机制可以导致一个实例能直接从 byte[] 数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的 byte[] 数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。</p>
<p>实际上，Java 本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过 JSON 这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。</p>
<h4 id="BIO、NIO-和-AIO-的区别"><a href="#BIO、NIO-和-AIO-的区别" class="headerlink" title="BIO、NIO 和 AIO 的区别"></a>BIO、NIO 和 AIO 的区别</h4><ul>
<li>BIO (Blocking I/O)：同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型很好，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，对于十万甚至百万级的连接，传统的 BIO 模型是无能为力的。因此需要更高效的 I/O 处理模型来应对更高的并发量；</li>
<li>NIO (Non-blocking/New I/O)：NIO 是一种同步非阻塞的 I/O 模型，Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 Socket 和 ServerSocket 相对应的 SocketChannel  和 ServerSocketChannel 两种不同的套接字通道实现。两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发；</li>
<li>AIO (Asynchronous I/O)：AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2，它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。Netty 之前也尝试使用过 AIO，不过又放弃了。</li>
</ul>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>对比 Exception 和 Error，比较运行时异常和一般异常的区别。</p>
<p>Exception 和 Error 都是继承了 Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。</p>
<p>Exception 和 Error 体现了 Java 平台设计者对不同异常情况的分类。Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。</p>
<p>Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。</p>
<p>Exception 又分为检查（checked）异常和非检查（unchecked）异常，检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。不可检查的 Error，是 Throwable 不是 Exception。</p>
<p>注：JAVA语言规范将派生于Error类或RuntimeException类的所有异常称为非检查(unchecked)异常，所有其他的异常称为检查(checked)异常。”</p>
<p>非检查异常包含类似 NullPointerException、ArrayIndexOutOfBoundsException 之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。</p>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte、Short、Integer、Long、Character、Boolean。前 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character创建数值在[0,127]范围的缓存数据，Boolean 直接返回True Or False。如果超出对应范围仍然会去创建新的对象。把经常用到的数据存放在某块内存中，可以避免频繁的数据创建与销毁，实现数据共享，提高系统性能。</p>
<p>字符串常量池是Java常量池技术的一种实现, 在近代的 JDK 版本中（1.7后）, 字符串常量池被实现在Java堆内存中。</p>
<p>当用new关键字创建字符串对象时, 不会查询字符串常量池；当用双引号直接声明字符串对象时, 虚拟机将会查询字符串常量池。也就是说，字符串常量池提供了字符串的复用功能, 除非要显式创建新的字符串对象，否则对同一个字符串虚拟机只会维护一份拷贝。</p>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>主要解决：一个全局使用的类频繁地创建与销毁。</p>
<p>何时使用：想控制实例数目，节省系统资源的时候。</p>
<p>如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p>
<p>关键代码：构造函数是私有的。</p>
<p>应用实例：</p>
<ul>
<li>一个班级只有一个班主任；</li>
<li>Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行；</li>
<li>一些设备管理器常设计为单例模式，如一个电脑有两台打印机，在输出的时候要处理不能两台打印机打印同一个文件；</li>
</ul>
<p>优点：</p>
<ul>
<li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如网站首页页面缓存）；</li>
<li>避免对资源的多重占用（比如写文件操作）。</li>
</ul>
<p>缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<p>使用场景：</p>
<ul>
<li>要求生产唯一序列号；</li>
<li>WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来；</li>
<li>创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等；</li>
</ul>
<p>注意事项：</p>
<ul>
<li><p>getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化；</p>
</li>
<li><p>饿汉式：类一旦加载，就把单例初始化完成，保证 getInstance 的时候，单例是已经存在的了；</p>
<ul>
<li>饿汉式天生是线程安全的，因为它只在最开始实例化一次</li>
</ul>
</li>
<li><p>懒汉式：只有调用 getInstance 的时候，才去初始化这个单例。</p>
<ul>
<li>懒汉式本身是非线程安全的。</li>
</ul>
</li>
</ul>
<p>双检锁/双重校验锁（DCL，即 double-checked locking）</p>
<p>Lazy 初始化，是多线程安全</p>
<p>采用双锁机制，安全且在多线程情况下能保持高性能。getInstance() 的性能对应用程序很关键。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton singleton;  
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;&#125;  
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getSingleton</span><span class="hljs-params">()</span> </span>&#123;  
    <span class="hljs-keyword">if</span> (singleton == <span class="hljs-keyword">null</span>) &#123;  
        <span class="hljs-keyword">synchronized</span> (Singleton<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;  
        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-keyword">null</span>) &#123;  
            singleton = <span class="hljs-keyword">new</span> Singleton();  
        &#125;  
        &#125;  
    &#125;  
    <span class="hljs-keyword">return</span> singleton;  
    &#125;  
&#125;</code></pre>



<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>在工厂模式中，创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
<p>意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>
<p>主要解决：接口选择的问题。</p>
<p>何时使用：明确地计划不同条件下创建不同实例时。</p>
<p>如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。</p>
<p>关键代码：创建过程在其子类执行。</p>
<p>应用实例：您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。</p>
<p>优点： </p>
<ul>
<li>一个调用者想创建一个对象，只要知道其名称就可以了；</li>
<li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以；</li>
<li>屏蔽产品的具体实现，调用者只关心产品的接口。</li>
</ul>
<p>缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。</p>
<p>使用场景：</p>
<ul>
<li>日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方；</li>
<li>数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时；</li>
<li>设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</li>
</ul>
<p>注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p>
<h4 id="final、finally、-finalize"><a href="#final、finally、-finalize" class="headerlink" title="final、finally、 finalize"></a>final、finally、 finalize</h4><ul>
<li>final 可以用来修饰类、方法、变量，分别有不同的意义，final 修饰的 class 代表不可以继承扩展，final 的变量是不可以修改的，而 final 的方法也是不可以重写的（override）；</li>
<li>finally 则是 Java 保证重点代码一定要被执行的一种机制。可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC 连接、保证 unlock 锁等动作；</li>
<li>finalize 是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated；</li>
</ul>
<p>有 return 的情况下 try-catch-finally 的执行顺序：</p>
<ul>
<li>不管有没有出现异常，finally 块中代码都会执行；</li>
<li>当 try 和 catch 中有 return 时，finally 仍然会执行；</li>
<li>finally 是在 return 后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管 finally 中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值是在 finally 执行前确定的；</li>
<li>finally 中最好不要包含 return，否则程序会提前退出，返回值不是 try 或 catch 中保存的返回值。</li>
</ul>
<h4 id="强引用、软引用、弱引用、幻象引用"><a href="#强引用、软引用、弱引用、幻象引用" class="headerlink" title="强引用、软引用、弱引用、幻象引用"></a>强引用、软引用、弱引用、幻象引用</h4><p>在 Java 语言中，除了原始数据类型的变量，其他所有都是所谓的引用类型，指向各种不同的对象，理解引用对于掌握 Java 对象生命周期和 JVM 内部相关机制非常有帮助。不同的引用类型，主要体现的是对象不同的可达性（reachable）状态和对垃圾收集的影响。</p>
<ul>
<li>强引用（Strong Reference）：最常见的普通对象引用，只要还有强引用指向对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略；<ul>
<li>强引用特点：平常典型编码Object obj = new Object() 中的 obj 就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当 JVM 内存空间不足，JVM宁愿抛出 OutOfMemoryError 运行时错误，使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题；</li>
</ul>
</li>
<li>软引用（SoftReference）：一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OOM 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存；</li>
<li>弱引用（WeakReference）：不能使对象豁免垃圾收集，仅仅提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择；<ul>
<li>弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中；</li>
<li>应用场景：用于内存敏感的缓存；</li>
</ul>
</li>
<li>幻象引用：有时候也翻译成虚引用，不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制，也有人利用幻象引用监控对象的创建和销毁；<ul>
<li>应用场景：用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。  </li>
</ul>
</li>
</ul>
<h4 id="String、StringBuffer-和-StringBuilder"><a href="#String、StringBuffer-和-StringBuilder" class="headerlink" title="String、StringBuffer 和 StringBuilder"></a>String、StringBuffer 和 StringBuilder</h4><ul>
<li><p>String 是 Java 语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响；</p>
</li>
<li><p>StringBuffer 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder；</p>
</li>
<li><p>StringBuilder 是 Java 1.5 中新增的，能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选；</p>
</li>
</ul>
<h4 id="Java-反射与动态代理的原理"><a href="#Java-反射与动态代理的原理" class="headerlink" title="Java 反射与动态代理的原理"></a>Java 反射与动态代理的原理</h4><p>编程语言通常有各种不同的分类角度，动态类型和静态类型就是其中一种分类角度，简单区分就是语言类型信息是在运行时检查，还是编译期检查。</p>
<p>与其近似的还有一个对比，就是所谓强类型和弱类型，就是不同类型变量赋值时，是否需要显式地（强制）进行类型转换。那么，如何分类 Java 语言呢？通常认为，Java 是静态的强类型语言，但是因为提供了类似反射等机制，也具备了部分动态类型语言的能力。</p>
<p>反射机制是 Java 语言提供的一种基础功能，赋予程序在运行时自省（introspect，官方用语）的能力。通过反射可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。</p>
<p>反射的主要使用场景：</p>
<p>需要用反射的时候自然会用。反射肯定是能不用就不用。一般有两种需要用反射的情况：</p>
<p>1）方法名，甚至类名，是从某些配置文件读出来的，这时候就需要用。更甚有些类直接就是动态生成的，比如 gclib，肯定要用反射；</p>
<p>2）框架，比如Spring，Junit，大量需要用到反射做各种骚操作；</p>
<p>3）不推荐在生产使用：需要访问 private 的属性和方法。</p>
<p>使用反射可以读private 了，那是不是有些矛盾了。private 不是因为不想让一些代码暴露在外面所以才设置为private 的吗，这下好了，用反射都可以读，感觉有点像是耍流氓，那为什么还要设置为 private，反正都可以用反射读。就好像是卖保险柜的把保险柜的破解方法也告诉了别人一样。</p>
<p>访问private要设置一下 accessible 为 true。还是有限制的。private确实不应该被访问，但是总有特殊情况，就好像车不应该闯红灯，但是总有特殊情况，如果在红灯的时候直接在路口升起一堵墙，消防车救护车也不让过，也并非是好事。当一个人把属性设置为 private 的时候，也很难考虑到所有可能的情况。</p>
<p>动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。</p>
<p>实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。</p>
<h4 id="Class-forName-对象-getClass-类名-class"><a href="#Class-forName-对象-getClass-类名-class" class="headerlink" title="Class.forName, 对象.getClass, 类名.class"></a>Class.forName, 对象.getClass, 类名.class</h4><p>Class.forName 就是加载一个类，但是这个类只有在用到的时候才会被初始化，初始化可以认为就是执行 static 的初始化代码，以及检查这个类用到的别的类是否存在之类的。</p>
<p>对象 .getClass 和类名 .class 没什么太大区别。它们返回的类肯定都是已经初始化好的。如果说一定要有点区别的话，那也是最表面的区别。getClass 方法是调用对象的方法，那么首先必须得有一个对象才行。.class 是直接获取某个类的 class，不需要通过对象。</p>
<p>如果非要再说有啥区别，就跟 classloader 里各种弯弯绕有关系了，对象 .getClass 和类名 .class 得到的 class instance 可能会不一样，但是这些弯弯绕意义不大。</p>
<h4 id="int-与-Integer"><a href="#int-与-Integer" class="headerlink" title="int 与 Integer"></a>int 与 Integer</h4><p>答：int 就是常说的整形数字，是 Java 的 8 个原始数据类型（Primitive Types，boolean、byte 、short、char、int、float、double、long）之一。Java 语言虽然号称一切都是对象，但原始数据类型是例外。</p>
<p>Integer 是 int 对应的包装类，它有一个 int 类型的字段存储数据，并且提供了基本操作，比如数学运算、int 和字符串之间转换等。在 Java 5 中，引入了自动装箱和自动拆箱功能（boxing/unboxing），Java 可以根据上下文，自动进行转换，极大地简化了相关编程。</p>
<p>关于 Integer 的值缓存，这涉及 Java 5 中另一个改进。构建 Integer 对象的传统方式是直接调用构造器，直接 new 一个对象。但是根据实践，发现大部分数据操作都是集中在有限的、较小的数值范围，因而，在 Java 5 中新增了静态工厂方法 valueOf，在调用它的时候会利用一个缓存机制，带来了明显的性能改进。按照 Javadoc，这个值默认缓存是 -128 到 127 之间。</p>
<h4 id="Java-IO-与多路复用。"><a href="#Java-IO-与多路复用。" class="headerlink" title="Java  IO 与多路复用。"></a>Java  IO 与多路复用。</h4><p>Java IO 方式有很多种，基于不同的 IO 抽象模型和交互方式，可以进行简单区分。</p>
<ul>
<li><p>首先，传统的 java.io 包，它基于流模型实现，提供了一些最熟知的 IO 功能，比如 File 抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。</p>
<p>java.io 包的好处是代码比较简单、直观，缺点则是 IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。</p>
<p>很多时候，人们也把 java.net 下面提供的部分网络 API，比如 Socket、ServerSocket、HttpURLConnection 也归类到同步阻塞 IO 类库，因为网络通信同样是 IO 行为。</p>
<ul>
<li>同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善；</li>
<li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</li>
</ul>
</li>
<li><p>第二，在 Java 1.4 中引入了 NIO 框架（java.nio 包），提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。</p>
<ul>
<li>同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理；</li>
<li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</li>
</ul>
</li>
<li><p>第三，Java 7 中 NIO 有了进一步改进，即 NIO 2。引入了异步非阻塞 IO方式，也有人叫它 AIO（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。</p>
<ul>
<li>异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理；</li>
<li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li>
</ul>
</li>
</ul>
<h4 id="Java-文件拷贝"><a href="#Java-文件拷贝" class="headerlink" title="Java 文件拷贝"></a>Java 文件拷贝</h4><p>Java 有多种比较典型的文件拷贝实现方式，比如：</p>
<ul>
<li><p>利用 java.io 类库，直接为源文件构建一个 FileInputStream 读取，然后再为目标文件构建一个 FileOutputStream，完成写入工作；</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">copyFileByStream</span><span class="hljs-params">(File source, File dest)</span> <span class="hljs-keyword">throws</span></span>
<span class="hljs-function">        IOException </span>&#123;
    <span class="hljs-keyword">try</span> (InputStream is = <span class="hljs-keyword">new</span> FileInputStream(source);
         OutputStream os = <span class="hljs-keyword">new</span> FileOutputStream(dest);)&#123;
        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];
        <span class="hljs-keyword">int</span> length;
        <span class="hljs-keyword">while</span> ((length = is.read(buffer)) &gt; <span class="hljs-number">0</span>) &#123;
            os.write(buffer, <span class="hljs-number">0</span>, length);
        &#125;
    &#125;
 &#125;</code></pre>



</li>
</ul>
<ul>
<li><p>或者，利用 java.nio 类库提供的 transferTo 或 transferFrom 方法实现。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">copyFileByChannel</span><span class="hljs-params">(File source, File dest)</span> <span class="hljs-keyword">throws</span></span>
<span class="hljs-function">        IOException </span>&#123;
    <span class="hljs-keyword">try</span> (FileChannel sourceChannel = <span class="hljs-keyword">new</span> FileInputStream(source)
            .getChannel();
         FileChannel targetChannel = <span class="hljs-keyword">new</span> FileOutputStream(dest).getChannel
                 ();)&#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> count = sourceChannel.size() ;count&gt;<span class="hljs-number">0</span> ;) &#123;
            <span class="hljs-keyword">long</span> transferred = sourceChannel.transferTo(
                    sourceChannel.position(), count, targetChannel);            sourceChannel.position(sourceChannel.position() + transferred);
            count -= transferred;
        &#125;
    &#125;
 &#125;</code></pre>



</li>
</ul>
<p>  当然，Java 标准类库本身已经提供了几种 Files.copy 的实现。对于 Copy 的效率，这个其实与操作系统和配置等情况相关，总体上来说，NIO transferTo/From 的方式可能更快，因为它更能利用现代操作系统底层机制，避免不必要拷贝和上下文切换。</p>
<h4 id="类加载过程与双亲委派模型"><a href="#类加载过程与双亲委派模型" class="headerlink" title="类加载过程与双亲委派模型"></a>类加载过程与双亲委派模型</h4><p>Java 通过引入字节码和 JVM 机制，提供了强大的跨平台能力，理解 Java 的类加载机制是深入 Java 开发的必要条件。</p>
<p>一般来说，Java 的类加载过程分为三个主要步骤：加载、链接、初始化，具体行为在Java 虚拟机规范里有非常详细的定义。</p>
<ul>
<li><p>首先是加载阶段，它是 Java 将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象），这里的数据源可能是各种各样的形态，如 jar 文件、class 文件，甚至是网络数据源等；如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。</p>
<ul>
<li>加载阶段是用户参与的阶段，可以自定义类加载器，去实现自己的类加载过程。</li>
</ul>
</li>
<li><p>第二阶段是链接，这是核心的步骤，简单说是把原始的类定义信息平滑地转化入 JVM 运行的过程中。这里可进一步细分为三个步骤：</p>
<ul>
<li>验证：这是虚拟机安全的重要保障，JVM 需要核验字节信息是符合 Java 虚拟机规范的，否则就被认为是 VerifyError，这样就防止了恶意信息或者不合规的信息危害 JVM 的运行，验证阶段有可能触发更多 class 的加载。</li>
<li>准备：创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显式初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的 JVM 指令；</li>
<li>解析：在这一步会将常量池中的符号引用替换为直接引用。在Java 虚拟机规范中，详细介绍了类、接口、方法和字段等各个方面的解析；</li>
</ul>
</li>
<li><p>最后是初始化阶段：真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑；</p>
</li>
</ul>
<p>双亲委派模型，简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载 Java 类型。</p>
<h4 id="常量和静态变量"><a href="#常量和静态变量" class="headerlink" title="常量和静态变量"></a>常量和静态变量</h4><p>定义下面这样的类型，分别提供了普通静态变量、静态常量，常量。又考虑到原始类型和引用类型可能有区别。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CLPreparation</span> </span>&#123;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">100</span>;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INT_CONSTANT = <span class="hljs-number">1000</span>;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer INTEGER_CONSTANT = Integer.valueOf(<span class="hljs-number">10000</span>);
&#125;</code></pre>



<ul>
<li><p>普通原始类型静态变量和引用类型（即使是常量），是需要额外调用 putstatic 等 JVM 指令的，这些是在显式初始化阶段执行，而不是准备阶段调用；</p>
</li>
<li><p>原始类型常量，则不需要这样的步骤。其实，类加载机制的范围实在太大，从开发和部署的不同角度，各选取了一个典型扩展问题供参考：</p>
<ul>
<li>如果要真正理解双亲委派模型，需要理解 Java 中类加载器的架构和职责，至少要懂具体有哪些内建的类加载器，这些是上面的回答里没有提到的；以及如何自定义类加载器；</li>
<li>从应用角度，解决某些类加载问题，例如Java 程序启动较慢，想办法尽量减小 Java 类加载的开销；</li>
</ul>
</li>
</ul>
<p>通常类加载机制有三个基本特征：</p>
<ul>
<li><p>双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如 JDK 内部的 ServiceProvider/ServiceLoader 机制，用户可以在标准 API 框架上，提供自己的实现，JDK 也需要提供些默认的参考实现。 例如，Java 中 JNDI、JDBC、文件系统、Cipher 等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器；</p>
</li>
<li><p>可见性。子类加载器可以访问父加载器加载的类型，但是反过来是不允许的，不然，因为缺少必要的隔离，就没有办法利用类加载器去实现容器的逻辑；</p>
</li>
<li><p>单一性。由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见；</p>
</li>
</ul>
<h4 id="运行时动态生成-Java-类"><a href="#运行时动态生成-Java-类" class="headerlink" title="运行时动态生成 Java 类"></a>运行时动态生成 Java 类</h4><p>可以从常见的 Java 类来源分析，通常的开发过程是，开发者编写 Java 代码，调用 javac 编译成 class 文件，然后通过类加载机制载入 JVM，就成为应用运行时可以使用的 Java 类了。</p>
<p>从上面过程得到启发，其中一个直接的方式是从源码入手，可以利用 Java 程序生成一段源码，然后保存到文件等，下面就只需要解决编译问题了。</p>
<p>有一种笨办法，直接用 ProcessBuilder 之类启动 javac 进程，并指定上面生成的文件作为输入，进行编译。最后，再利用类加载器，在运行时加载即可。</p>
<p>前面的方法，本质上还是在当前程序进程之外编译的，那么还有没有不这么 low 的办法呢？</p>
<p>可以考虑使用 Java Compiler API，这是 JDK 提供的标准 API，里面提供了与 javac 对等的编译器功能，具体请参考java.compiler相关文档。</p>
<p>进一步思考，一直围绕 Java 源码编译成为 JVM 可以理解的字节码，换句话说，只要是符合 JVM 规范的字节码，不管它是如何生成的，是不是都可以被 JVM 加载呢？能不能直接生成相应的字节码，然后交给类加载器去加载呢？</p>
<p>当然也可以，不过直接去写字节码难度太大，通常可以利用 Java 字节码操纵工具和类库来实现，比如 ASM、Javassist、cglib 等。</p>
<h4 id="数据原子性"><a href="#数据原子性" class="headerlink" title="数据原子性"></a>数据原子性</h4><p>数据的读写能否保证数据原子性。</p>
<h4 id="读多写少场景下如何设计可以性能提升"><a href="#读多写少场景下如何设计可以性能提升" class="headerlink" title="读多写少场景下如何设计可以性能提升"></a>读多写少场景下如何设计可以性能提升</h4><h4 id="copy-on-write原则"><a href="#copy-on-write原则" class="headerlink" title="copy-on-write原则"></a>copy-on-write原则</h4><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>Head First Java - 第二版</p>
<p>JavaGuide</p>
<p><a href="https://juejin.im/post/6844903847572275207" target="_blank" rel="noopener">深入探究Java中equals()和==的区别是什么</a></p>
<p><a href="https://juejin.im/post/6844903853528186887" target="_blank" rel="noopener">详解Java中的字符串</a></p>
<p><a href="https://blog.csdn.net/ty497122758/article/details/78979302" target="_blank" rel="noopener">JAVA BIO与NIO、AIO的区别</a></p>
<p><a href="https://blog.csdn.net/thinkingcao/article/details/78563211" target="_blank" rel="noopener">有 return 的情况下try catch finally的执行顺序</a></p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Java/">Java</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java-%E5%9F%BA%E7%A1%80/">Java 基础</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/07/22/Java%20OOP%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java OOP一些理解</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/07/21/Python-Tips/">
                        <span class="hidden-mobile">Python Tips</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    
  <!-- 备案信息 -->
  <div class="beian">
    <a href="http://beian.miit.gov.cn/" target="_blank"
       rel="nofollow noopener"></a>
    
  </div>


    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 2,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  














</body>
</html>
