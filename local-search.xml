<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL 基础</title>
    <link href="/2020/08/07/MySQL-%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/08/07/MySQL-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>文章对 MySQL 基础做归纳总结。</p><a id="more"></a><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>写数据库操作的时候，须做到心里有数，知道每个语句执行的结果，代码会产生什么样的资源消耗，语句的执行会占用哪些锁，分析语句执行速度慢的原因等。</p><p>不能仅仅满足于执行结果是否正确。因为这样会限制提高数据库的技术水平增长，限制提高基于数据库的业务架构能力。一个语句可以试，一个五条语句的事务分析就要试很多次，一个复杂业务系统的数据库设计，就无法试出来。</p><p>原理有助于剪枝，排除掉那些理论上明显错误的方案，这样才有精力真的去试那些有限的、可能正确的方案。我们不需要特别精通数据库，但是多知道一些原理，就能多一些剪枝，架构设计就能少一些错误选项的干扰，项目架构正确的可能性就更高。</p><p>剪枝的过程也能进一步印证学习的时间可以节省工作的时间。当然，“原理”是一个很大的概念，有的原理更接近实战，有的远一些。</p><h1 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h1><h1 id="MySQL-基础架构"><a href="#MySQL-基础架构" class="headerlink" title="MySQL 基础架构"></a>MySQL 基础架构</h1><p>简单来说 MySQL 主要分为 Server 层和存储引擎层：</p><ul><li><strong>Server 层：</strong>主要包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。还有一个通用的日志模块 bin log 日志模块；</li><li><strong>存储引擎：</strong> 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redo log 模块。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始作为默认存储引擎。</li></ul><p>连接器、查询缓存、分析器、优化器、执行器的主要功能如下：</p><ul><li><strong>连接器：</strong> 管理连接，权限认证；</li><li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存，命中则直接返回结果（功能不太实用，MySQL 8.0 后移除）；</li><li><strong>分析器：</strong> 词法分析，语法分析；</li><li><strong>优化器：</strong> 执行计划生成，索引选择；</li><li><strong>执行器：</strong> 操作引擎，返回结果；</li></ul><h2 id="一条SQL语句在MySQL中如何执行"><a href="#一条SQL语句在MySQL中如何执行" class="headerlink" title="一条SQL语句在MySQL中如何执行"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/database/%E4%B8%80%E6%9D%A1sql%E8%AF%AD%E5%8F%A5%E5%9C%A8mysql%E4%B8%AD%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84" target="_blank" rel="noopener">一条SQL语句在MySQL中如何执行</a></h2><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>MySQL 整体来看分为两块：<strong>Server 层主要和 MySQL 功能层面相关</strong>；<strong>引擎层负责存储相关的具体事宜</strong>。Server 层的日志称为 binlog，归档日志，有时候也叫做二进制日志。</p><p>内容：逻辑格式的日志，可以简单认为是执行过的事务中的 sql 语句。但又不完全是 sql 语句这么简单，而是包括了执行的 sql 语句（增删改）反向的信息（作为回滚用），意味着 delete 对应着 delete 本身和其反向的 insert；update对应着 update 执行前后的版本的信息；insert 对应着 delete 和 insert 本身的信息。</p><p>作用：<strong>用于复制</strong>。在主从复制中，从库利用主库上的 binlog 进行重播，实现<strong>主从同步</strong>。用于<strong>数据库的基于时间点的还原</strong>。</p><p>binlog 有三种模式：Statement（基于 sql 语句的复制）、Row（基于行的复制）以及 Mixed（混合模式）。</p><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>概念：重做日志。</p><p>在 MySQL 中，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，可以使用 <strong>WAL(Write-Ahead Logging)</strong> 技术。它的关键点就是<strong>先写日志，再写磁盘</strong>。具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log 里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p><p>内容：物理格式的日志，记录的是物理数据页面的修改的信息，redo log 是顺序写入redo log file的物理文件中的。</p><p>作用：保证即使数据库发生异常重启，之前提交的记录都不会丢失，达到 crash-safe 的目的。</p><p>InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下图所：</p><img src="mysql_redo_log_pic1.png" srcset="/img/loading.gif" style="zoom:60%;" align="middle"/><p><img src="mysql_redo_log_pic1.png" srcset="/img/loading.gif" alt=""></p><p>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>write pos 和 checkpoint 之间的是还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</p><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>概念：回滚日志。</p><p>内容：逻辑格式的日志，在执行 undo 的时候，仅仅是<strong>将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于redo log的</strong>。</p><p>作用：<strong>保存了事务发生之前的数据的一个版本</strong>，可以用于<strong>回滚</strong>，同时可以提供<strong>多版本并发控制下的读</strong>（MVCC），也即非锁定读。</p><h3 id="redo-log-与-binlog"><a href="#redo-log-与-binlog" class="headerlink" title="redo log 与 binlog"></a>redo log 与 binlog</h3><p>需要 redo log 和 binlog 两份日志的原因是，最开始 MySQL 里没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，<strong>binlog 日志只能用于归档</strong>。InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 <strong>binlog 没有 crash-safe 能力</strong>，所以 InnoDB 使用另外一套日志系统，也就是 <strong>redo log 来实现 crash-safe 能力</strong>。</p><p>这两种日志有以下三点不同：</p><ul><li><p>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用；</p></li><li><p>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”；</p></li><li><p>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志；</p></li></ul><h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p>对这日志有一个基本的了解之后，再来看执行器和 InnoDB 引擎在执行下面这个简单的 update 语句时的内部流程：</p><pre><code class="hljs sql"><span class="hljs-comment">#创建一个表，表中有一个主键 ID 和一个整型字段 c</span>mysql&gt; create table T(ID int primary key, c int);<span class="hljs-comment">#将 ID=2 这一行的值加 1</span>mysql&gt; update T set c=c+1 where ID=2;</code></pre><p>  　　1. 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回；<br>        　　2. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据；<br>            　　3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务；<br>                    　　4. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘；<br>          　　5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</p><p>最后三步将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是”两阶段提交”。两阶段提交的目的，是为了 bin log和redo log 两份日志之间的逻辑一致。要说明这个问题，需要考虑这个问题：怎样让数据库恢复到半个月内任意一秒的状态？</p><p>我们知道，binlog 会以“追加写”的形式记录所有的逻辑操作。如果要达到半个月内的数据库状态都可以恢复的目的，那么备份系统中必须要保存最近半个月的所有 binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。</p><p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那么可以这么做：</p><ol><li>找到最近的一次全量备份，从这个备份恢复到临时库；</li><li>从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。</li></ol><p>这样临时库就跟误删之前的线上库一样了，然后可以把表数据从临时库取出来，按需要恢复到线上库去。这就是数据恢复过程。</p><p>那么为什么日志需要“两阶段提交”。可以用反证法解释。由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。看看这两种方式会有什么问题。</p><p>以 update 语句作为例子。假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？</p><ul><li><p>先写 redo log 后写 binlog：</p><p>假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于 redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。那么，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。</p></li><li><p>先写 binlog 后写 redo log：</p><p>如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。</p></li></ul><p>所以，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。这个过程和场景来不仅用于误操作后恢复数据，在需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用 binlog 来实现的，这个“不一致”就会导致线上出现主从数据库不一致的情况。</p><p>简单说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务是指构成单一逻辑工作单元的操作的集合逻辑上的一组操作，通俗来说要么都执行，要么都不执行。</p><p>事务最经典的例子就是转账。假如小明要给小红转账1000元，会涉及到两个关键操作：小明的余额减少1000元，小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p><h2 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h2><ul><li><p>原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p></li><li><p>一致性：事务执行前后数据库保持约束一致性和业务逻辑一致性；</p><ul><li>执行事务前后，数据保持一致。例如转账业务中，事务是否成功，转账者和收款人的总额应该是不变的；</li></ul></li><li><p>隔离性：在事务并发执行时，各个事务都感觉不到其他事务的存在；</p><ul><li>并发访问数据库时，一个事务不被其他事务所干扰；</li></ul></li><li><p>持久性：事务被提交后，它对数据库的更改是持久的，即使数据库系统崩溃也能恢复；</p></li></ul><h2 id="并发事务存在的问题"><a href="#并发事务存在的问题" class="headerlink" title="并发事务存在的问题"></a>并发事务存在的问题</h2><p>在典型的应用程序中，多个事务并发运行，经常会有操作相同的数据来完成各自的任务的场景，即多个用户对统一数据进行操作。并发虽然是必须的，但可能会导致以下的问题：</p><ul><li><strong>脏读（Dirty read）：</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的；</li><li><strong>丢失修改（Lost to modify）：</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失；</li><li><strong>不可重复读（Unrepeatableread）：</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读；</li><li><strong>幻读（Phantom read）：</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li></ul><h3 id="不可重复度和幻读的区别"><a href="#不可重复度和幻读的区别" class="headerlink" title="不可重复度和幻读的区别"></a>不可重复度和幻读的区别</h3><p>不可重复读的重点是<strong>修改</strong>，幻读的重点在于<strong>新增或者删除</strong>。</p><ul><li><p>事务1中的A先生读取自己的工资为 1000 的操作还没完成，事务2中的B先生就修改了A的工资为2000，导致A再读自己的工资时工资变为 2000，这是不可重复读；</p></li><li><p>某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。</p></li></ul><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>MySQL 标准定义了四个隔离级别：</p><ul><li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，一个事务还没提交时，它做的变更就能被别的事务看到。<strong>可能会导致脏读、幻读或不可重复读</strong>；</li><li><strong>READ-COMMITTED(读取已提交)：</strong> 一个事务提交之后，它做的变更才会被其他事务看到。<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>；</li><li><strong>REPEATABLE-READ(可重复读)：</strong> 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>；</li><li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。<strong>该级别可以防止脏读、不可重复读以及幻读</strong>；</li></ul><h1 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h1><p>今天我要跟你聊聊 MySQL 的锁。数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。</p><p>根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。今天这篇文章，我会和你分享全局锁和表级锁。而关于行锁的内容，我会留着在下一篇文章中再和你详细介绍。</p><p>这里需要说明的是，锁的设计比较复杂，这两篇文章不会涉及锁的具体实现细节，主要介绍的是碰到锁时的现象和其背后的原理。</p><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。</p><p>当需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：</p><ul><li>数据更新语句（数据的增删改）；</li><li>数据定义语句（包括建表、修改表结构等）；</li><li>更新类事务的提交语句。</li></ul><p>全局锁的典型使用场景是，做全库逻辑备份，也就是把整库每个表都 select 出来存成文本。</p><p>对于全部是 InnoDB 引擎的库，建议选择使用–single-transaction 参数，对应用会更友好。</p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>MySQL 里面<strong>表级别的锁</strong>有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p><ul><li>表锁的语法是 lock tables … read/write。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象；<ul><li>例如，如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表；</li><li>在没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面太大。</li></ul></li><li>MDL（metadata lock)。MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是保证读写的正确性。例如，如果一个查询正在遍历一个表中的数据，执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。因此，MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</li></ul><p>读锁之间不互斥，因此可以有多个线程同时对一张表增删改查。</p><p>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</p><p>虽然 MDL 锁是系统默认会加的，但是有一些问题不可以忽略。经常有人掉到这个坑里：给一个小表加个字段，导致整个库挂了。</p><p>我们知道，给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。在对大表操作的时候，肯定会特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也会出问题。对于下面的操作序列，假设表 t 是一个小表。</p><p>注：实验环境是 MySQL 5.6。</p><p><img src="metadata_lock_example1.jpg" srcset="/img/loading.gif" alt=""></p><p>session A 先启动，这时候会对表 t 加一个 MDL 读锁。由于 session B 需要的也是 MDL 读锁，因此可以正常执行。之后 session C 会被 blocked，因为 session A 的 MDL 读锁还没有释放，而 session C 需要 MDL 写锁，因此只能被阻塞。</p><p>如果只有 session C 自己被阻塞还没什么关系，但是之后所有要在表 t 上新申请 MDL 读锁的请求也会被 session C 阻塞。因为所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了。</p><p>如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。</p><p>事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</p><p>基于上面的分析，讨论一个问题，如何安全地给小表加字段？首先要解决长事务，事务不提交，就会一直占着 MDL 锁。在 MySQL 的 information_schema 库的 innodb_trx 表中，可以查到当前执行中的事务。如果要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。</p><p>但考虑一下这个场景。如果要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而不得不加个字段，该怎么做呢？</p><p>这时候 kill 可能未必管用，因为新的请求马上就来了。比较理想的机制是，在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。</p><p>MariaDB 已经合并了 AliSQL 的这个功能，所以这两个开源分支目前都支持 DDL NOWAIT/WAIT n 这个语法。</p><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tbl_name <span class="hljs-keyword">NOWAIT</span> <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> ...<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tbl_name <span class="hljs-keyword">WAIT</span> N <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> ...</code></pre><p>表锁一般是在数据库引擎不支持行锁的时候才会被用到的。如果应用程序里有 lock tables 这样的语句，需要追查一下，比较可能的情况是：</p><ul><li>系统现在还在用 MyISAM 这类不支持事务的引擎，那要安排升级换引擎；</li><li>引擎升级了，但是代码还没升级。业务开发把 lock tables 和 unlock tables 改成 begin 和 commit，问题就解决了。</li></ul><p>MDL 会直到事务提交才释放，在做表结构变更的时候，一定要小心不要导致锁住线上查询和更新。</p><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。<strong>不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度</strong>。</p><p>InnoDB 支持行锁，这也是 MyISAM 被 InnoDB 替代的重要原因之一。</p><p>行锁就是针对数据表中行记录的锁。比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。</p><p>在下面的操作序列中，事务 B 的 update 语句执行时会是什么现象呢？假设字段 id 是表 t 的主键。</p><p><img src="Innodb_lock_example1.jpg" srcset="/img/loading.gif" alt=""></p><p>这个问题的结论取决于事务 A 在执行完两条 update 语句后，持有哪些锁，以及在什么时候释放。可以验证一下：实际上事务 B 的 update 语句会被阻塞，直到事务 A 执行 commit 之后，事务 B 才能继续执行。</p><p>事务 A 持有的两个记录的行锁，都是在 commit 的时候才释放的。</p><p>也就是说，在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是<strong>两阶段锁协议</strong>。</p><p>开发的时候要正确安排事务的语句，基本原则是：<strong>如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放</strong>。</p><p>例如，要实现一个电影票在线交易业务，顾客 A 要在影院 B 购买电影票。简化一点，这个业务需要涉及到以下操作：</p><ul><li>从顾客 A 账户余额中扣除电影票价；</li><li>给影院 B 的账户余额增加这张电影票价；</li><li>记录一条交易日志。</li></ul><p>完成这个交易，需要 update 两条记录，并 insert 一条记录。为保证交易的原子性，要把这三个操作放在一个事务中。如何安排这三个语句在事务中的顺序？</p><p>试想如果同时有另外一个顾客 C 要在影院 B 买票，那么这两个事务冲突的部分就是语句 2 了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。</p><p>根据两阶段锁协议，不论怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，如果把语句 2 安排在最后，比如按照 3、1、2 这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度。</p><p>这样设计的话，影院余额这一行的行锁在一个事务中不会停留很长时间。但是，这并没有完全解决困扰。如果这个影院做活动，可以低价预售一年内所有的电影票，而且这个活动只做一天。于是在活动时间开始的时候，MySQL 可能就挂了，服务器的 CPU 消耗可能接近 100%，但整个数据库每秒就执行不到 100 个事务。这就涉及死锁和死锁检测了。</p><h3 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h3><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。<strong>减少死锁的主要方向，就是控制访问相同资源的并发事务量</strong>。这里用数据库中的行锁举个例子。</p><p><img src="Innodb_lock_example2.jpg" srcset="/img/loading.gif" alt=""></p><p>这时候，事务 A 在等待事务 B 释放 id=2 的行锁，而事务 B 在等待事务 A 释放 id=1 的行锁。 事务 A 和事务 B 在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：</p><ul><li><p>直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置；</p></li><li><p>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。</p></li></ul><p>在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。但是又不可能直接把这个时间设置成一个很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p><p>所以，正常情况下还是要采用第二种策略，即：<strong>主动死锁检测</strong>，而且 innodb_deadlock_detect 的默认值本身就是 on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。可以想象一下这个过程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p><p>那如果是上面说到的所有事务都要更新同一行的场景呢？每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，会看到 CPU 利用率很高，但是每秒却执行不了几个事务。</p><p>根据上面的分析，讨论怎么解决由这种<strong>热点行更新导致的性能问题</strong>。</p><p>问题的症结在于，死锁检测要耗费大量的 CPU 资源。一种头痛医头的方法，就是<strong>如果能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉</strong>。但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。另一个思路是<strong>控制并发度</strong>。根据上面的分析，如果并发能够控制住，比如同一行同时最多只有 10 个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。一个直接的想法就是，在客户端做并发控制。但是，很快发现这个方法不太可行，因为客户端很多。对于一个有 600 个客户端的应用，即使每个客户端控制到只有 5 个并发线程，汇总到数据库服务端以后，峰值并发数也可能要达到 3000。</p><p>因此，<strong>并发控制要做在数据库服务端</strong>。如果有中间件，可以考虑在中间件实现；如果团队有能修改 MySQL 源码的人，也可以做在 MySQL 里面。基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了。</p><p>如果团队里暂时没有数据库方面的专家，不能实现这样的方案，可以考虑从设计上优化这个问题。</p><p>考虑通过将一行改成逻辑上的多行来减少锁冲突。还是以影院账户为例，可以考虑放在多条记录上，比如 10 个记录，影院的账户总额等于这 10 个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的 1/10，可以减少锁等待个数，也就减少了死锁检测的 CPU 消耗。这个方案看上去是无损的，但其实这类方案需要根据业务逻辑做详细设计。如果账户余额可能会减少，比如退票逻辑，那么这时候就需要考虑当一部分行记录变成 0 的时候，代码要有特殊处理。</p><h3 id="表级锁和行级锁对比"><a href="#表级锁和行级锁对比" class="headerlink" title="表级锁和行级锁对比"></a>表级锁和行级锁对比</h3><ul><li><strong>表级锁：</strong>对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB引擎都支持表级锁；</li><li><strong>行级锁：</strong>MySQL中锁定粒度最小的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li></ul><h2 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h2><p>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB 只好引入新的锁，也就是间隙锁 (Gap Lock)。间隙锁，锁的就是两个值之间的空隙。</p><p>建表和初始化语句如下，这个表除了主键 id 外，还有一个索引 c，初始化语句在表中插入了 6 行数据。</p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`t`</span> (  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`c`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`d`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>),  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`c`</span> (<span class="hljs-string">`c`</span>)) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span>;<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>),(<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>),(<span class="hljs-number">20</span>,<span class="hljs-number">20</span>,<span class="hljs-number">20</span>),(<span class="hljs-number">25</span>,<span class="hljs-number">25</span>,<span class="hljs-number">25</span>);</code></pre><p>表 t 初始化插入了 6 个记录，这就产生了 7 个间隙。</p><p><img src="image-20200807190224369.png" srcset="/img/loading.gif" alt=""></p><p>这样，当执行 select * from t where d=5 for update 的时候，就不止是给数据库中已有的 6 个记录加上了行锁，还同时加了 7 个间隙锁。这样就确保了无法再插入新的记录。也就是说这时候，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。数据行是可以加上锁的实体，数据行之间的间隙，也是可以加上锁的实体。但是间隙锁跟我们之前碰到过的锁都不太一样。</p><p>注：select for update 是为了在查询时，避免其他用户以该表进行插入，修改或删除等操作，造成表的不一致性。</p><p>比如行锁，分成读锁和写锁。下图就是这两种类型行锁的冲突关系，也就是说，跟行锁有冲突关系的是“另外一个行锁”。</p><p><img src="%E4%B8%A4%E7%A7%8D%E8%A1%8C%E9%94%81%E9%97%B4%E7%9A%84%E5%86%B2%E7%AA%81%E5%85%B3%E7%B3%BB.png" srcset="/img/loading.gif" alt=""></p><p>但是间隙锁不一样，<strong>跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作</strong>。间隙锁之间都不存在冲突关系。</p><p>如下图所示，这里 session B 并不会被堵住。因为表 t 里并没有 c=7 这个记录，因此 session A 加的是间隙锁 (5,10)。而 session B 也是在这个间隙加的间隙锁。它们有共同的目标，即：保护这个间隙，不允许插入值。但它们之间是不冲突的。</p><p><img src="%E9%97%B4%E9%9A%99%E9%94%81%E4%B9%8B%E9%97%B4%E4%B8%8D%E4%BA%92%E9%94%81.png" srcset="/img/loading.gif" alt=""></p><h2 id="next-key-lock"><a href="#next-key-lock" class="headerlink" title="next-key lock"></a>next-key lock</h2><p>间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间。也就是说，表 t 初始化以后，如果用 select * from t for update 要把整个表所有记录锁起来，就形成了 7 个 next-key lock，分别是 (-∞,0]、(0,5]、……、(20, 25]、(25, +supremum]。这是因为 +∞是开区间。实现上，InnoDB 给每个索引加了一个不存在的最大值 supremum，这样才符合“都是前开后闭区间”的要求。</p><p>注：文章中，如果没有特别说明，我们把间隙锁记为开区间，把 next-key lock 记为前开后闭区间。</p><p>间隙锁和 next-key lock 的引入，解决了幻读的问题，但同时也带来了一些“困扰”。对应到这个例子的表来说，业务逻辑这样的：任意锁住一行，如果这一行不存在的话就插入，如果存在这一行就更新它的数据，代码如下：</p><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>=N <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<span class="hljs-comment">/*如果行不存在*/</span><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(N,N,N);<span class="hljs-comment">/*如果行存在*/</span><span class="hljs-keyword">update</span> t <span class="hljs-keyword">set</span> d=N <span class="hljs-keyword">set</span> <span class="hljs-keyword">id</span>=N;<span class="hljs-keyword">commit</span>;</code></pre><p>考虑 insert … on duplicate key update 是否可以解决问题？在有多个唯一键的时候，这个方法是不能满足需求的。</p><p>现在，只讨论这个逻辑。现象是，这个逻辑一旦有并发，就会碰到死锁。为什么这个逻辑每次操作前用 for update 锁起来，已经是最严格的模式了，为什么还会出现死锁。这里，用两个 session 来模拟并发，并假设 N=9。</p><p><img src="%E9%97%B4%E9%9A%99%E9%94%81%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E9%94%81.png" srcset="/img/loading.gif" alt=""></p><p>其实都不需要用到后面的 update 语句，就已经形成死锁了。按语句执行顺序来分析一下：</p><ul><li>session A 执行 select … for update 语句，由于 id=9 这一行并不存在，因此会加上间隙锁 (5,10)；</li><li>session B 执行 select … for update 语句，同样会加上间隙锁 (5,10)，间隙锁之间不会冲突，因此这个语句可以执行成功；</li><li>session B 试图插入一行 (9,9,9)，被 session A 的间隙锁挡住了，只好进入等待；</li><li>session A 试图插入一行 (9,9,9)，被 session B 的间隙锁挡住了。</li></ul><p>至此，两个 session 进入互相等待状态，形成死锁。当然，InnoDB 的死锁检测马上就发现了这对死锁关系，让 session A 的 insert 语句报错返回了。</p><p>所以，<strong>间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的</strong>。</p><p>为了解决幻读的问题，引入了这么一大串内容，有没有更简单一点的处理方法呢。</p><p>之前分析的问题都是在可重复读隔离级别下的，间隙锁是在可重复读隔离级别下才会生效的。所以，如果把隔离级别设置为读提交的话，就没有间隙锁了。但同时，要解决可能出现的数据和日志不一致问题，需要把 binlog 格式设置为 row。这，也是现在不少公司使用的配置组合。</p><h3 id="gap-lock和next-key-lock对比"><a href="#gap-lock和next-key-lock对比" class="headerlink" title="gap lock和next-key lock对比"></a>gap lock和next-key lock对比</h3><ul><li><p>InnoDB 对于行的查询使用 next-key lock；</p></li><li><p>当查询的索引含有唯一属性时，将 next-key lock 降级为record key；</p></li><li><p>有两种方式显式关闭 gap 锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock）1）将事务隔离级别设置为 RC；2）将参数innodb_locks_unsafe_for_binlog设置为1。</p></li></ul><h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><p>表级锁和行级锁可以进一步划分为共享锁（s）和排他锁（X）：</p><ul><li><p>共享锁（Share Locks，简记为S）又被称为读锁；</p><ul><li>其他用户可以并发读取数据，但任何事务都不能获取数据上的排他锁，直到已释放所有共享锁。若事务T对数据对象A加上S锁，则事务T只能读A；其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改；</li><li>如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不 能加排他锁。获取共享锁的事务只能读数据，不能修改数据。</li></ul></li><li><p>排它锁（(Exclusive lock,简记为X锁)）又称为写锁。</p><ul><li>若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。它防止任何其它事务获取资源上的锁，直到在事务的末尾将资源上的原始锁释放为止。在更新操作(INSERT、UPDATE 或 DELETE)过程中始终应用排它锁；</li><li>如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获取排他锁的事务既能读数据，又能修改数据。</li></ul></li></ul><p>当一个事务需要给自己需要的某个资源加锁的时候，如果遇到一个共享锁正锁定着自己需要的资源的时候，自己可以再加一个共享锁，不过不能加排他锁。但是，如果遇到自己需要锁定的资源已经被一个排他锁占有之后，则只能等待该锁定释放资源之后自己才能获取锁定资源并添加自己的锁定。而意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以需要锁定行的表上面添加一个合适的意向锁。如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。</p><p>InnoDB另外的两个表级锁：</p><ul><li><strong>意向共享锁（IS）：</strong> 表示事务准备给数据行记入共享锁，事务在一个数据行加共享锁前必须先取得该表的IS锁；</li><li><strong>意向排他锁（IX）：</strong> 表示事务准备给数据行加入排他锁，事务在一个数据行加排他锁前必须先取得该表的IX锁。</li></ul><p>注：</p><ul><li><p>这里的意向锁是表级锁，表示的是一种意向，仅仅表示事务正在读或写某一行记录，在真正加行锁时才会判断是否冲突。意向锁是 InnoDB 自动加的，不需要用户干预；</p></li><li><p>IX，IS是表级锁，不会和行级的X，S锁发生冲突，只会和表级的X，S发生冲突。</p></li></ul><h2 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h2><p>自增锁(AUTO-INC Locks)是事务插入时自增列上特殊的<strong>表级别</strong>的锁。最简单的一种情况：如果一个事务正在向表中插入值，则任何其他事务必须等待，以便第一个事务插入的行接收连续的主键值。</p><p>一般把主键设置为 AUTO_INCREMENT 的列，默认情况下这个字段的值为0，InnoDB会在 AUTO_INCREMENT 修饰下的数据列所关联的索引末尾设置独占锁。在访问自增计数器时，InnoDB使用自增锁，但是锁定仅仅持续到当前SQL语句的末尾，而不是整个事务的结束，毕竟自增锁是表级别的锁，如果长期锁定会大大降低数据库的性能。由于是表锁，在使用期间，其他会话无法插入表中。</p><h2 id="页级锁"><a href="#页级锁" class="headerlink" title="页级锁"></a>页级锁</h2><p>MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。页级进行了折衷，一次锁定相邻的一组记录。BDB支持页级锁。开销和加锁时间界于表锁和行锁之间，会出现死锁。锁定粒度界于表锁和行锁之间，并发度一般。</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p><strong>索引是一种用于快速查询和检索数据的数据结构。</strong>实现索引的方式却有很多种，所以就引入了索引模型的概念。可以提高读写效率的数据结构有很多，例如哈希表、有序数组和搜索树（B树， B+树等）。</p><ul><li><strong>哈希表</strong>结构适用于只有<strong>等值查询</strong>的场景；</li><li>有序数组在<strong>等值查询和范围查询场景</strong>中的性能就都非常优秀，<strong>有序数组索引只适用于静态存储引擎</strong>，比如保存 2017 年某个城市的所有人口信息，这类不会再修改的数据；</li><li>多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是大多数的数据库存储并不使用二叉树。原因是<strong>索引不止存在内存中，还要写到磁盘上</strong>。一棵 100 万节点的平衡二叉树，树高 20。<strong>一次查询可能需要访问 20 个数据块</strong>。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，速度太慢。为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，<strong>一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘</strong>。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。<strong>N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，被广泛应用在数据库引擎中</strong>；</li><li>哈希、有序数组或 N 叉树都是不断迭代、不断优化的产物或者解决方案。数据库技术不断发展，<strong>跳表、LSM 树</strong>等数据结构也被用于引擎设计中；</li></ul><p>使用索引既有优势也有劣势：</p><ul><li><p>大部分系统的读请求总是大于写请求的，索引可以加快查询和检索数据的效率；</p></li><li><p>创建索引和维护索引需要耗费许多时间：当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低执行效率；</p></li><li><p>占用物理存储空间：索引需要使用物理文件存储，也会耗费一定空间。</p></li></ul><h2 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h2><h3 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h3><ul><li>B树的所有节点既存放键(key) 也存放数据(data)；B+树只有叶子节点存放 key 和 data，内节点只存放key；</li><li>B树的叶子节点都是独立的；B+树的叶子节点有一条引用链指向与它相邻的叶子节点；</li><li>B树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能没有到叶子节点，检索就结束了。B+树的检索效率很稳定，任何查找都需要从根节点访问到叶子节点的，叶子节点的顺序检索很明显；</li></ul><h3 id="Hash索引和B-树索引"><a href="#Hash索引和B-树索引" class="headerlink" title="Hash索引和B+树索引"></a>Hash索引和B+树索引</h3><ul><li><p>Hash索引定位快：hash 索引指的就是 hash 表，最大的优点是能够在很短的时间内，根据 hash 函数定位到数据所在的位置；</p></li><li><p>Hash索引不支持顺序和范围查询，hash 索引是根据 hash 算法来定位的，对1 - 499的数据分别进行 hash 计算效果不太理想。B+树是有序的，对于范围查询比较有优势，直接遍历比500小的叶子节点就够了。</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> tb1 <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> &lt; <span class="hljs-number">500</span>;</code></pre></li><li><p>Hash冲突问题；</p></li></ul><h2 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h2><p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。InnoDB 使用 B+ 树索引模型，能够很好地<strong>配合磁盘的读写特性，减少单次查询的磁盘访问次数</strong>。所以数据都是存储在 B+ 树中的。</p><p>每一个索引在 InnoDB 里面对应一棵 B+ 树。假设有一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引。这个表的建表语句是：</p><pre><code class="hljs sql">mysql&gt; create table T(id int primary key, k int not null, name varchar(16),index (k))engine=InnoDB;</code></pre><p>表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下。</p><p><img src="InnoDB_btree_example1.png" srcset="/img/loading.gif" alt=""></p><p>从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引：</p><ul><li><p><strong>主键索引的叶子节点存的是整行数据</strong>。在 InnoDB 里，<strong>主键索引也被称为聚簇索引</strong>（clustered index）。</p></li><li><p><strong>非主键索引的叶子节点内容是主键的值</strong>。在 InnoDB 里，<strong>非主键索引也被称为二级索引</strong>（secondary index）。</p></li></ul><p>那么基于主键索引和普通索引的查询的区别是什么？</p><ul><li><p>如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；</p></li><li><p>如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为<strong>回表</strong>。</p></li></ul><p>也就是说，<strong>基于非主键索引的查询需要多扫描一棵索引树。因此，应用中应该尽量使用主键查询</strong>。</p><h2 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h2><p>B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。</p><p>而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为<strong>页分裂</strong>。这种情况下性能会受影响。除了性能外，页分裂操作还<strong>影响数据页的利用率</strong>。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。</p><p>有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p><p>基于上面的索引维护过程说明，讨论一个案例。一些建表规范里面会说：要求建表语句里一定要有自增主键。当然事无绝对，分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。</p><p><strong>自增主键是指自增列上定义的主键</strong>，在建表语句中一般是这么定义的： <strong>NOT NULL PRIMARY KEY AUTO_INCREMENT</strong>。</p><p>插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。</p><p>也就是说，自增主键的插入数据模式，正符合递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p><p>而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</p><p>除了考虑性能外，还可以从存储空间的角度来看。假设表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。显然，<strong>主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小</strong>。所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p><p>有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：</p><ul><li><p>只有一个索引；</p></li><li><p>该索引必须是唯一索引。</p></li></ul><p>这就是典型的 KV 场景。由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。这时候就要优先考虑“尽量使用主键查询”的原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。</p><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>主键索引的叶子节点存的是整行的数据(聚簇索引)。数据表的主键列使用的就是主键索引。一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p><p>在 mysql 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p><h3 id="非主键索引"><a href="#非主键索引" class="headerlink" title="非主键索引"></a>非主键索引</h3><p>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引，辅助索引，因为二级索引的叶子节点存储的数据是主键。通过二级索引，可以定位主键的位置。</p><p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>唯一索引(Unique Key) ：唯一索引的属性列不能出现重复的数据，但是允许数据为NULL，一张表允许创建多个唯一索引。建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</p><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><p>普通索引(Index) ：普通索引的作用是快速查询数据，一张表允许创建多个普通索引，允许数据重复和NULL。</p><p>主键索引只要搜索ID这个B+Tree即可拿到数据。普通索引先搜索索引拿到主键值，再到主键索引树搜索一次(回表)。</p><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>前缀索引(Prefix) ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</p><h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><p>全文索引(Full Text) ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6之后 InnoDB 也支持了全文索引。</p><h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</p><p>在 Mysql 中，InnoDB 引擎的表的 .ibd文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p><h4 id="聚集索引的优点"><a href="#聚集索引的优点" class="headerlink" title="聚集索引的优点"></a>聚集索引的优点</h4><p>聚集索引的查询速度非常的快，因为整个B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p><h4 id="聚集索引的缺点"><a href="#聚集索引的缺点" class="headerlink" title="聚集索引的缺点"></a>聚集索引的缺点</h4><ul><li><p>依赖于有序的数据 ：因为B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度比较慢。</p></li><li><p>更新代价大 ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改， 而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。</p></li></ul><h3 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h3><p>非聚集索引即索引结构和数据分开存放的索引。二级索引属于非聚集索引。</p><p>MYISAM 引擎的表的.MYI文件包含了表的索引，该表的索引(B+树)的每个叶子非叶子节点存储索引， 叶子节点存储索引和索引对应数据的指针，指向.MYD文件的数据。</p><p>非聚集索引的叶子节点并不一定存放数据的指针， 因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</p><p>普通索引，唯一索引，全文索引属于非聚集索引。</p><h4 id="非聚集索引的优点"><a href="#非聚集索引的优点" class="headerlink" title="非聚集索引的优点"></a>非聚集索引的优点</h4><p>更新代价比聚集索引要小 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p><h4 id="非聚集索引的缺点"><a href="#非聚集索引的缺点" class="headerlink" title="非聚集索引的缺点"></a>非聚集索引的缺点</h4><ul><li><p>非聚集索引也依赖于有序的数据；</p></li><li><p>可能会二次查询（回表）：这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</p></li></ul><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>表的初始化语句</p><pre><code class="hljs sql">mysql&gt; create table T (ID int primary key,k int NOT NULL DEFAULT 0, s varchar(16) NOT NULL DEFAULT '',index k(k))engine=InnoDB;<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> T <span class="hljs-keyword">values</span>(<span class="hljs-number">100</span>,<span class="hljs-number">1</span>, <span class="hljs-string">'aa'</span>),(<span class="hljs-number">200</span>,<span class="hljs-number">2</span>,<span class="hljs-string">'bb'</span>),(<span class="hljs-number">300</span>,<span class="hljs-number">3</span>,<span class="hljs-string">'cc'</span>),(<span class="hljs-number">500</span>,<span class="hljs-number">5</span>,<span class="hljs-string">'ee'</span>),(<span class="hljs-number">600</span>,<span class="hljs-number">6</span>,<span class="hljs-string">'ff'</span>),(<span class="hljs-number">700</span>,<span class="hljs-number">7</span>,<span class="hljs-string">'gg'</span>);</code></pre><p><img src="InnoDB_btree_example2.png" srcset="/img/loading.gif" alt=""></p><p>表 T 中，如果执行 select * from T where k between 3 and 5，需要执行几次树的搜索操作，会扫描多少行？</p><p>SQL 查询语句的执行流程如下：</p><ul><li><p>在 k 索引树上找到 k=3 的记录，取得 ID = 300；</p></li><li><p>再到 ID 索引树查到 ID=300 对应的 R3；</p></li><li><p>在 k 索引树取下一个值 k=5，取得 ID=500；</p></li><li><p>再回到 ID 索引树查到 ID=500 对应的 R4；</p></li><li><p>在 k 索引树取下一个值 k=6，不满足条件，循环结束。</p></li></ul><p>在这个过程中，回到主键索引树搜索的过程，称为回表。可以看到，这个查询过程读了 k 索引树的 3 条记录（步骤 1、3 和 5），回表了两次（步骤 2 和 4）。</p><p>在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么有没有可能经过索引优化，避免回表过程呢？</p><p>如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”查询需求，这称为覆盖索引。</p><p>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</p><p>需要注意的是，在引擎内部使用覆盖索引在索引 k 上其实读了三个记录，R3~R5（对应的索引 k 上的记录项），但是对于 MySQL 的 Server 层来说，它就是找引擎拿到了两条记录，因此 MySQL 认为扫描行数是 2。</p><p>基于上面覆盖索引的说明，讨论一个问题：在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？</p><p>假设这个市民表的定义是这样的：</p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`tuser`</span> (  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`id_card`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`age`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`ismale`</span> <span class="hljs-built_in">tinyint</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>),  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`id_card`</span> (<span class="hljs-string">`id_card`</span>),  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`name_age`</span> (<span class="hljs-string">`name`</span>,<span class="hljs-string">`age`</span>)) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span></code></pre><p>身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求，只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？</p><p>如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。</p><p>当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这正是业务 DBA，或者称为业务数据架构师的工作。</p><h2 id="索引创建原则"><a href="#索引创建原则" class="headerlink" title="索引创建原则"></a>索引创建原则</h2><h3 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h3><p>单列索引即由一列属性组成的索引。</p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>联合索引即由多列属性组成索引。</p><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>如果为每一种查询都设计一个索引，索引是不是太多了。如果现在要按照市民的身份证号去查他的家庭地址呢？虽然这个查询需求在业务中出现的概率不高，但总不能让它走全表扫描吧？反过来说，单独为一个不频繁的请求创建一个（身份证号，地址）的索引又感觉有点浪费。应该怎么做呢？</p><p>结论是：B+ 树索引结构可以利用索引的“最左前缀”，来定位记录。</p><p>为了直观地说明这个概念，用（name，age）这个联合索引来分析。</p><p><img src="name_age_%E7%B4%A2%E5%BC%95%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" srcset="/img/loading.gif" alt=""></p><p>可以看到，索引项是按照索引定义里面出现的字段顺序排序的。</p><p>当逻辑需求是查到所有名字是“张三”的人时，可以快速定位到 ID4，然后向后遍历得到所有需要的结果。</p><p>如果要查的是所有名字第一个字是“张”的人，SQL 语句的条件是”where name like ‘张 %’”。这时，也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。</p><p>可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</p><p>基于上面对最左前缀索引的说明，讨论一个问题：在建立联合索引的时候，如何安排索引内的字段顺序。</p><p>这里评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。因此，第一原则是，<strong>如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的</strong>。</p><p>所以要为高频请求创建 (身份证号，姓名）这个联合索引，并用这个索引支持“根据身份证号查询地址”的需求。</p><p>那么，如果既有联合查询，又有基于 a、b 各自的查询呢？查询条件里面只有 b 的语句，是无法使用 (a,b) 这个联合索引的，这时候不得不维护另外一个索引，也就是说需要同时维护 (a,b)、(b) 这两个索引。</p><p>这时候，要考虑的原则就是空间了。比如上面这个市民表的情况，name 字段是比 age 字段大的 ，那建议创建一个（name,age) 的联合索引和一个 (age) 的单字段索引。</p><p>假设创建的联合索引由三个字段组成：</p><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">INDEX</span> index_name (<span class="hljs-keyword">num</span>,<span class="hljs-keyword">name</span>,age)</code></pre><p>那么当查询的条件有为:num / (num AND name) / (num AND name AND age)时，索引才生效。所以<strong>在创建联合索引时，尽量把查询最频繁的那个字段作为最左(第一个)字段。查询的时候也尽量以这个字段为第一条件。</strong></p><h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。那么，那些不符合最左前缀的部分，会怎么样呢？</p><p>以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是 10 岁的所有男孩”。那么，SQL 语句是这么写的：</p><pre><code class="hljs sql">mysql&gt; select * from tuser where name like '张%' and age=10 and ismale=1;</code></pre><p>运用前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录 ID3。比全表扫描要好。然后要判断其他条件是否满足。</p><p>在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。</p><p>而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。图 3 和图 4，是这两个过程的执行流程图。</p><p><img src="%E6%97%A0%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" srcset="/img/loading.gif" alt=""></p><p>在图 3 和 4 这两个图里面，每一个虚线箭头表示回表一次。</p><p>图 3 中，在 (name,age) 索引里面特意去掉了 age 的值，这个过程 InnoDB 并不会去看 age 的值，只是按顺序把“name 第一个字是’张’”的记录一条条取出来回表。因此，需要回表 4 次。</p><p>图 4 跟图 3 的区别是，InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。在这个例子中，只需要对 ID4、ID5 这两条记录回表取数据判断，就只需要回表 2 次。</p><h2 id="索引创建注意点"><a href="#索引创建注意点" class="headerlink" title="索引创建注意点"></a>索引创建注意点</h2><ul><li><p>最左前缀原则；</p></li><li><p>不为NULL的字段；</p><ul><li>索引字段的数据应该尽量不为NULL，因为对于数据为NULL的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为NULL，建议使用0,1,true,false这样语义较为清晰的短值或短字符作为替代；</li></ul></li><li><p>被频繁查询的字段；</p><ul><li>创建索引的字段应该是查询操作非常频繁的字段；</li></ul></li><li><p>被作为WHERE条件查询的字段，应该被考虑建立索引；</p></li><li><p>经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率；</p></li><li><p>被频繁更新的字段应该慎重建立索引；</p><ul><li>虽然索引能带来查询上的效率，但是维护索引的成本也不小。如果一个字段不被经常查询，反而被经常修改，那么就更不应该建立索引；</li></ul></li><li><p>不被经常查询的字段没有必要建立索引；</p></li><li><p>尽可能的考虑建立联合索引而不是单列索引；</p><ul><li>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升；</li></ul></li><li><p>注意避免冗余索引；</p><ul><li>冗余索引指的是索引的功能相同。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的。在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引；</li></ul></li><li><p>考虑在字符串类型的字段上使用前缀索引代替普通索引；</p><ul><li>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</li></ul></li><li><p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p></li></ul><h1 id="数据库有优化"><a href="#数据库有优化" class="headerlink" title="数据库有优化"></a>数据库有优化</h1><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p><ul><li><p>限定数据的范围<br>务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</p></li><li><p>读/写分离<br>经典的数据库拆分方案，主库负责写，从库负责读；</p></li><li><p>垂直分区<br>根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库；</p><ul><li>垂直拆分的优点：可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护；</li><li>垂直拆分的缺点：主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</li></ul></li><li><p>水平分区</p><ul><li>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。水平拆分可以支撑非常大的数据量；</li><li>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响；</li><li>水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以水平拆分最好分库；</li><li>水平拆分能够支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨节点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O；</li><li>数据库分片的两种常见方案：<ul><li>客户端代理：分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。当当网的 Sharding-JDBC、阿里的TDDL是两种比较常用的实现；</li><li>中间件代理：在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。我们现在谈的 Mycat、360的Atlas、网易的DDB等等都是这种架构的实现。</li></ul></li></ul></li></ul><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><p>常见的如 java线程池、jdbc连接池、redis 连接池等是池化设计的代表实现。这种设计会初始预设资源，解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销等。</p><p>除了初始化资源，池化设计还包括如下这些特征：池子的初始值、池子的活跃值、池子的最大值等，这些特征可以直接映射到 java 线程池和数据库连接池的成员属性中。</p><p>数据库连接本质就是一个 socket 的连接。数据库服务端还要维护一些缓存和用户权限等信息，所以会占用一些内存。可以把数据库连接池看做是维护的数据库连接的缓存，以便将来需要对数据库的请求时可以重用这些连接。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序的请求，既昂贵又浪费资源。在连接池中，创建连接后，将其放置在池中，并再次使用它，因此不必建立新的连接。如果已经使用了所有的连接，则会建立一个新连接并将其添加到池中。连接池还减少了用户必须等待建立与数据库的连接的时间。</p><h2 id="分库分表之后，id-主键如何处理"><a href="#分库分表之后，id-主键如何处理" class="headerlink" title="分库分表之后，id 主键如何处理"></a>分库分表之后，id 主键如何处理</h2><p>因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来支持。</p><p>生成全局 id 有下面这几种方式：</p><ul><li>UUID：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字；</li><li>数据库自增 id : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈；</li><li>利用 redis 生成 id : 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本；</li><li><a href="https://github.com/twitter-archive/snowflake" target="_blank" rel="noopener">Twitter的snowflake算法</a>；</li><li><a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" rel="noopener">美团的Leaf分布式ID生成系统</a> ：Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper等中间件。</li></ul><h2 id="SQL执行很慢的原因"><a href="#SQL执行很慢的原因" class="headerlink" title="SQL执行很慢的原因"></a>SQL执行很慢的原因</h2><p>一个 SQL 执行的很慢，要分两种情况讨论：</p><ul><li><p>大多数情况下很正常，偶尔很慢，则有如下原因：</p><ul><li>数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘；</li><li>执行的时候，遇到锁，如表锁、行锁。</li></ul></li><li><p>这条 SQL 语句一直执行的很慢，则有如下原因：</p><ul><li>没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引；</li><li>数据库选错了索引。</li></ul></li></ul><h1 id="MyISAM-与-InnoDB"><a href="#MyISAM-与-InnoDB" class="headerlink" title="MyISAM 与 InnoDB"></a>MyISAM 与 InnoDB</h1><p>MyISAM 虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。</p><ul><li><p>是否支持行级锁: MyISAM 只有表级锁，InnoDB 支持行级锁和表级锁，默认为行级锁。</p></li><li><p>是否支持事务和崩溃后的安全恢复： MyISAM 强调的是性能，每次查询具有原子性，执行速度比 InnoDB 更快，但是不提供事务支持。InnoDB 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p></li><li><p>是否支持外键：MyISAM不支持，而InnoDB支持。</p></li><li><p>是否支持MVCC：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。推荐阅读：<a href="https://segmentfault.com/a/1190000012650596" target="_blank" rel="noopener">MySQL-InnoDB-MVCC多版本并发控制</a></p></li></ul><p>《MySQL高性能》上面有一句话这样写到:</p><blockquote><p>不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB的速度都可以让MyISAM望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。</p></blockquote><p>一般情况下选择 InnoDB 都是没有问题的，但是某些情况下并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择MyISAM也是一个不错的选择。</p><h1 id="自测题"><a href="#自测题" class="headerlink" title="自测题"></a>自测题</h1><ul><li><p>有哪些索引类型，适用场景是是什么。</p></li><li><p>适用索引的优缺点</p></li><li><p>二叉树不适合做索引的原因</p><p>二叉树这里主要用红黑树，AVL因为旋转次数较多，一般不用。但两者都不适合索引，因为深度太大，查询慢 </p></li><li><p>哈希做索引的优劣</p><p>哈希索引是有做索引的，根据哈希值确认对应位置，访问速度快，但不适合范围查询。在InnoDB中有将热点数据建立自适应哈希</p></li><li><p>说说聚簇索引和非聚簇索引</p></li><li><p>多列索引实现原理</p></li><li><p>B+具体的实现原理，B+树和B树有什么区别</p></li><li><p>简单说说数据库第3范式</p></li><li><p>如何添加索引</p></li><li><p>口述查询表中某商品单价</p></li><li><p>说说左外连接和内连接的区别</p></li><li><p>说说数据库读写分离的作用</p></li><li><p>说说事务</p></li><li><p>数据提交了会不会丢失，引出事务，和事务恢复过程</p><p>事务提交不会丢失数据，然后分析事务恢复过程<br>说恢复的时候，先以一个更新语句为例。会经过两层，SQL上层和存储层。然后具体讲了binlog，undo log，redo log 如何完成的过程</p></li><li><p>undo log作用</p></li><li><p>原子性和MVCC</p></li><li><p>undo Log等日志会不会丢失</p><p>有可能，先写入到缓存。具体讲了undo log写入到 redo log日志中，redo log写入缓存，最后才刷新到磁盘。<br>提升了IO性能</p></li><li><p>说说隔离级别</p></li><li><p>最左原则</p></li><li><p>说说行锁和列锁</p></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/wq-blogs/p/11867199.html" target="_blank" rel="noopener">mysql日志：redo log、binlog、undo log 区别与作用</a></p><p><a href="https://blog.csdn.net/qq_34337272/article/details/80611486" target="_blank" rel="noopener">MySQL 锁机制简单了解一下</a></p><p><a href="https://www.cnblogs.com/chenmingjun/p/10556206.html" target="_blank" rel="noopener">MySQL 中的 int(11) 代表什么意思？</a></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 基础</title>
    <link href="/2020/08/04/Java-%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/08/04/Java-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>以问答的形式梳理 Java 基础中一些重要的知识点。</p><a id="more"></a><h4 id="简要介绍-JVM"><a href="#简要介绍-JVM" class="headerlink" title="简要介绍 JVM"></a>简要介绍 JVM</h4><p>JVM 是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现，目的是使用相同的字节码，得出相同的结果。</p><p>JVM 可以理解的代码就叫做字节码（.class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又有解释型语言可移植的特点。字节码不针对特定的机器，所以 Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p><p>Java 程序从源代码到运行一般有下面 3 步：</p><p><img src="Java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" alt=""></p><p>需要格外注意 .class -&gt; 机器码这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的（热点代码），所以后面引进了 JIT 编译器，JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，会将字节码对应的机器码保存下来，下次可以直接使用，机器码的运行效率肯定是高于 Java 解释器的。所以说 Java 是编译与解释共存的语言。</p><p>HotSpot 采用了惰性评估（Lazy Evaluation）的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），这也是 JIT 需要编译的部分。JVM 会根据代码每次被执行的情况收集信息，做一些相应的优化，因此执行的次数越多，速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，直接将字节码编译成机器码，避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是，AOT 编译器的编译质量比不上 JIT 编译器。</p><h4 id="JRE-和-JDK"><a href="#JRE-和-JDK" class="headerlink" title="JRE 和 JDK"></a>JRE 和 JDK</h4><p>JDK 是 Java Development Kit，是功能齐全的 Java SDK。它包含JRE，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p><p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 JVM、Java 类库、Java 命令和其他一些基础构件。但是，它不能用于创建新程序。</p><p>如果只是为了运行 Java 程序的话，那么只安装 JRE 就可以了。如果需要进行 Java 编程方面的工作，就需要安装 JDK。但是，这不是绝对的。有时，即使不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，只是在应用程序服务器中运行 Java 程序。但是，因为应用程序服务器会将 JSP 转换为 Java servlet，需要使用 JDK 来编译 servlet，所以也要安装 JDK。</p><h4 id="Java-编译与解释并存"><a href="#Java-编译与解释并存" class="headerlink" title="Java 编译与解释并存"></a>Java 编译与解释并存</h4><p>高级编程语言按照程序的执行方式分为编译型和解释型两种。简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。</p><p>Java 语言具有编译型语言和解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码，这种字节码由 Java 解释器来解释执行。</p><h4 id="字符型常量和字符串常量"><a href="#字符型常量和字符串常量" class="headerlink" title="字符型常量和字符串常量"></a>字符型常量和字符串常量</h4><p>形式上：字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符。</p><p>含义上：字符常量相当于一个整型值（ASCII 值），可以参加表达式运算；字符串常量代表一个地址值（该字符串在内存中存放位置）。</p><p>占内存大小：字符常量只占 2 个字节；字符串常量占若干个字节（char 在 Java 中占两个字节)。</p><h4 id="Java泛型，类型擦除及常用通配符"><a href="#Java泛型，类型擦除及常用通配符" class="headerlink" title="Java泛型，类型擦除及常用通配符"></a>Java泛型，类型擦除及常用通配符</h4><p>Java 泛型（Generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p>Java的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</p><h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><ul><li><p>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝。</p></li><li><p>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容。</p></li></ul><h4 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h4><ul><li><p>重载（overload）：同一个方法根据输入数据的不同，做出不同的处理；</p><ul><li>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同；</li><li>同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理；</li></ul></li><li><p>重写（override）：子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，要覆盖父类方法；</p><ul><li>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写；</li><li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；</li><li>如果父类方法访问修饰符为 private/final/static，则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明；</li><li>构造方法无法被重写；</li><li>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变；</li></ul></li></ul><table><thead><tr><th align="center">区别点</th><th align="center">重载方法</th><th align="center">重写方法</th></tr></thead><tbody><tr><td align="center">发生范围</td><td align="center">同一个类</td><td align="center">子类中</td></tr><tr><td align="center">参数列表</td><td align="center">必须修改</td><td align="center">不能修改</td></tr><tr><td align="center">返回类型</td><td align="center">可修改</td><td align="center">不能修改</td></tr><tr><td align="center">异常</td><td align="center">可修改</td><td align="center">可以减少或删除，不能抛出新的或者更广的异常</td></tr><tr><td align="center">访问修饰符</td><td align="center">可修改</td><td align="center">不能做更严格的限制（可以降低限制）</td></tr><tr><td align="center">发生阶段</td><td align="center">编译期</td><td align="center">运行期</td></tr></tbody></table><h4 id="构造器-Constructor"><a href="#构造器-Constructor" class="headerlink" title="构造器 Constructor"></a>构造器 Constructor</h4><p>Constructor 不能被重写，但是可以重载，所以一个类中可以有多个构造函数。</p><h4 id="定义不使用且无参的构造方法的作用"><a href="#定义不使用且无参的构造方法的作用" class="headerlink" title="定义不使用且无参的构造方法的作用"></a>定义不使用且无参的构造方法的作用</h4><ul><li>Java 程序在执行子类的构造方法之前，如果没用 super() 来调用父类特定的构造方法，则会调用父类中没有参数的构造方法；</li><li>因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到无参的构造方法供执行。解决办法是在父类里加上一个不做事且无参的构造方法。</li></ul><h4 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h4><ul><li><p>从语法形式上看：</p><ul><li>成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；</li><li>成员变量可以被 public,private,static 等修饰符修饰，而局部变量不能被访问控制修饰符及 static 修饰；</li><li>成员变量和局部变量都能被 final 修饰；</li></ul></li><li><p>从变量在内存中的存储方式来看：</p><ul><li>如果成员变量使用 static 修饰，那么这个成员变量是属于类的，如果没有用 static 修饰，这个成员变量属于实例；</li><li>对象存在于堆内存，局部变量则存在于栈内存；</li></ul></li><li><p>从变量在内存中的生存时间上看：</p><ul><li>成员变量是对象的一部分，它随着对象的创建而存在；</li><li>局部变量随着方法的调用而自动消失；</li></ul></li><li><p>成员变量如果没有被赋初值会自动以类型的默认值而赋值（被 final 修饰的成员变量必须显式地赋值），而局部变量则不会自动赋值；</p></li></ul><h4 id="对象实例与对象引用"><a href="#对象实例与对象引用" class="headerlink" title="对象实例与对象引用"></a>对象实例与对象引用</h4><ul><li><p>new 创建对象实例，对象引用指向对象实例；</p><ul><li>对象实例在堆内存中，对象引用存放在栈内存中；</li></ul></li><li><p>一个对象引用可以指向 0 个或 1 个对象;一个对象可以有 n 个引用指向它；</p><ul><li>一根绳子可以不系气球，也可以系一个气球；可以用 n 条绳子系住一个气球；</li></ul></li></ul><h4 id="构造方法的作用"><a href="#构造方法的作用" class="headerlink" title="构造方法的作用"></a>构造方法的作用</h4><p>类的构造方法的主要作用是完成对类对象的初始化工作。</p><p>若一个类没有声明构造方法，该程序也可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了，所以很多时候在不知不觉地使用构造方法，这也是为什么在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果重载了有参的构造方法，可以把无参的构造方法也写出来（无论是否用到），避免在创建对象的时候踩坑。</p><p>调用子类构造方法之前先调用父类没有参数的构造方法可以帮助子类进行初始化工作。</p><h4 id="构造方法的特性"><a href="#构造方法的特性" class="headerlink" title="构造方法的特性"></a>构造方法的特性</h4><ul><li><p>名字与类名相同；</p></li><li><p>没有返回值，但不能用 void 声明构造函数；</p></li><li><p>生成类的对象时自动执行，无需调用；</p></li></ul><h4 id="对象的相等与指向他们的引用相等"><a href="#对象的相等与指向他们的引用相等" class="headerlink" title="对象的相等与指向他们的引用相等"></a>对象的相等与指向他们的引用相等</h4><p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p><p>“==”相等判断符用于比较基本数据类型和引用类型数据。当比较基本数据类型的时候比较的是数值，当比较引用类型数据时比较的是引用（指针）。</p><p>引用数据类型指向堆内存中一个具体的对象。比如 Student stu = new Student();  stu 就是一个引用，它指向的是 new 出来的 Student 对象。当需要操作这个 Student 对象的时候，只需要操作引用即可，比如 int age = stu.getAge()；。</p><p>“==”判断两个引用数据类型是否相等的时候，实际上是在判断两个引用是否指向同一个对象。</p><p>equals() 和 == 的本质区别的更通俗的说法是：==的比较规则是定死的，就是比较两个数据的值。而 equals() 的比较规则是不固定的，可以由用户自己定义。</p><p>如果想执行对象相等性的比较，就要覆盖 hashCode() 和 equals() 方法。</p><p>例如 HashSet 类会采用如下方法比较加入的对象是否与已经存在的对象相等：首先调用 hashCode() 比较要加入的对象与已经存在的对象的 hashcode 值，如果不存在相等的hashcode值，则不存在与要加入对象相等的对象，可以加入该对象；如果存在相等的hashcode值，则调用 equals() 检查 hashcode 相等的对象是否真的相等，如果两者相等，则要加入的对象已经存在了，加入操作就不会发生。</p><p>注意如果两个对象equal，则它们的hashcode值必须相同（所以如果覆盖了 equals() 方法，也必须同时覆盖 hashCode() 方法），但是如果两个对象具有相同的hashcode 值，它们不一定equal，所以 hashcode 值相同的对象还需要调用 equals() 来判断是否真的相等。</p><p>String类已经覆盖了 hashCode() 和 equals() 方法，所以 String 类的 hashCode() 和 equals() 方法执行的是对象相等性的比较。</p><h4 id="Java-中-IO-流"><a href="#Java-中-IO-流" class="headerlink" title="Java 中 IO 流"></a>Java 中 IO 流</h4><ul><li>按照流的流向分，可分为输入流和输出流；</li><li>按照操作单元划分，可划分为字节流和字符流；</li><li>按照流的角色划分为节点流和处理流；</li></ul><p>Java IO 流涉及 40 多个类，这些类看上去杂乱，实际很有规则，彼此之间紧密联系， Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生的：</p><ul><li>InputStream/Reader：所有的输入流的基类，前者是字节输入流，后者是字符输入流；</li><li>OutputStream/Writer：所有输出流的基类，前者是字节输出流，后者是字符输出流；</li></ul><h4 id="字节流与字符流"><a href="#字节流与字符流" class="headerlink" title="字节流与字符流"></a>字节流与字符流</h4><p>问题本质想问：对应文件读写、网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</p><p>字符流是由 Java 虚拟机将字节转换得到的，过程比较耗时，并且，如果不知道编码类型容易出现乱码问题。所以，I/O 流提供了一个直接操作字符的接口，方便平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p><h4 id="BIO、NIO-和-AIO-的区别"><a href="#BIO、NIO-和-AIO-的区别" class="headerlink" title="BIO、NIO 和 AIO 的区别"></a>BIO、NIO 和 AIO 的区别</h4><ul><li>BIO (Blocking I/O)：同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型很好，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，对于十万甚至百万级的连接，传统的 BIO 模型是无能为力的。因此需要更高效的 I/O 处理模型来应对更高的并发量；</li><li>NIO (Non-blocking/New I/O)：NIO 是一种同步非阻塞的 I/O 模型，Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 Socket 和 ServerSocket 相对应的 SocketChannel  和 ServerSocketChannel 两种不同的套接字通道实现。两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发；</li><li>AIO (Asynchronous I/O)：AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2，它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。Netty 之前也尝试使用过 AIO，不过又放弃了。</li></ul><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>对比 Exception 和 Error，比较运行时异常和一般异常的区别。</p><p>Exception 和 Error 都是继承了 Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。</p><p>Exception 和 Error 体现了 Java 平台设计者对不同异常情况的分类。Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。</p><p>Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。</p><p>Exception 又分为检查（checked）异常和非检查（unchecked）异常，检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。前面我介绍的不可查的 Error，是 Throwable 不是 Exception。</p><p>注：JAVA语言规范将派生于Error类或RuntimeException类的所有异常称为非检查(unchecked)异常，所有其他的异常称为检查(checked)异常。”</p><p>非检查异常包含类似 NullPointerException、ArrayIndexOutOfBoundsException 之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。</p><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte、Short、Integer、Long、Character、Boolean。前 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character创建数值在[0,127]范围的缓存数据，Boolean 直接返回True Or False。如果超出对应范围仍然会去创建新的对象。把经常用到的数据存放在某块内存中，可以避免频繁的数据创建与销毁，实现数据共享，提高系统性能。</p><p>字符串常量池是Java常量池技术的一种实现, 在近代的 JDK 版本中（1.7后）, 字符串常量池被实现在Java堆内存中。</p><p>当用new关键字创建字符串对象时, 不会查询字符串常量池；当用双引号直接声明字符串对象时, 虚拟机将会查询字符串常量池。也就是说，字符串常量池提供了字符串的复用功能, 除非要显式创建新的字符串对象，否则对同一个字符串虚拟机只会维护一份拷贝。</p><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>主要解决：一个全局使用的类频繁地创建与销毁。</p><p>何时使用：想控制实例数目，节省系统资源的时候。</p><p>如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p><p>关键代码：构造函数是私有的。</p><p>应用实例：</p><ul><li>一个班级只有一个班主任；</li><li>Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行；</li><li>一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件；</li></ul><p>优点：</p><ul><li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）；</li><li>避免对资源的多重占用（比如写文件操作）。</li></ul><p>缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><p>使用场景：</p><ul><li>要求生产唯一序列号；</li><li>WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来；</li><li>创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等；</li></ul><p>注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化；</p><p>双检锁/双重校验锁（DCL，即 double-checked locking）</p><p>Lazy 初始化，是多线程安全</p><p>采用双锁机制，安全且在多线程情况下能保持高性能。getInstance() 的性能对应用程序很关键。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;      <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton singleton;      <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;&#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getSingleton</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span> (singleton == <span class="hljs-keyword">null</span>) &#123;          <span class="hljs-keyword">synchronized</span> (Singleton<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;          <span class="hljs-keyword">if</span> (singleton == <span class="hljs-keyword">null</span>) &#123;              singleton = <span class="hljs-keyword">new</span> Singleton();          &#125;          &#125;      &#125;      <span class="hljs-keyword">return</span> singleton;      &#125;  &#125;</code></pre><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>在工厂模式中，创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><p>意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><p>主要解决：接口选择的问题。</p><p>何时使用：明确地计划不同条件下创建不同实例时。</p><p>如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。</p><p>关键代码：创建过程在其子类执行。</p><p>应用实例：您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。</p><p>优点： </p><ul><li>一个调用者想创建一个对象，只要知道其名称就可以了；</li><li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以；</li><li>屏蔽产品的具体实现，调用者只关心产品的接口。</li></ul><p>缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。</p><p>使用场景：</p><ul><li>日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方；</li><li>数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时；</li><li>设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</li></ul><p>注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p><h4 id="final、finally、-finalize"><a href="#final、finally、-finalize" class="headerlink" title="final、finally、 finalize"></a>final、finally、 finalize</h4><ul><li>final 可以用来修饰类、方法、变量，分别有不同的意义，final 修饰的 class 代表不可以继承扩展，final 的变量是不可以修改的，而 final 的方法也是不可以重写的（override）；</li><li>finally 则是 Java 保证重点代码一定要被执行的一种机制。我们可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC 连接、保证 unlock 锁等动作；</li><li>finalize 是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated；</li></ul><h4 id="强引用、软引用、弱引用、幻象引用"><a href="#强引用、软引用、弱引用、幻象引用" class="headerlink" title="强引用、软引用、弱引用、幻象引用"></a>强引用、软引用、弱引用、幻象引用</h4><p>在 Java 语言中，除了原始数据类型的变量，其他所有都是所谓的引用类型，指向各种不同的对象，理解引用对于掌握 Java 对象生命周期和 JVM 内部相关机制非常有帮助。不同的引用类型，主要体现的是对象不同的可达性（reachable）状态和对垃圾收集的影响。</p><ul><li>强引用（Strong Reference）：最常见的普通对象引用，只要还有强引用指向对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略；<ul><li>强引用特点：平常典型编码Object obj = new Object() 中的 obj 就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当 JVM 内存空间不足，JVM宁愿抛出 OutOfMemoryError 运行时错误，使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题；</li><li>软引用（SoftReference）：一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OOM 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存；</li></ul></li><li>弱引用（WeakReference）：不能使对象豁免垃圾收集，仅仅提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择；<ul><li>弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中；</li><li>应用场景：用于内存敏感的缓存；</li></ul></li><li>幻象引用：有时候也翻译成虚引用，不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制，也有人利用幻象引用监控对象的创建和销毁；<ul><li>应用场景：用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。  </li></ul></li></ul><h4 id="String、StringBuffer-和-StringBuilder"><a href="#String、StringBuffer-和-StringBuilder" class="headerlink" title="String、StringBuffer 和 StringBuilder"></a>String、StringBuffer 和 StringBuilder</h4><ul><li><p>String 是 Java 语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响；</p></li><li><p>StringBuffer 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder；</p></li><li><p>StringBuilder 是 Java 1.5 中新增的，能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选；</p></li></ul><h4 id="Java-反射与动态代理的原理"><a href="#Java-反射与动态代理的原理" class="headerlink" title="Java 反射与动态代理的原理"></a>Java 反射与动态代理的原理</h4><p>编程语言通常有各种不同的分类角度，动态类型和静态类型就是其中一种分类角度，简单区分就是语言类型信息是在运行时检查，还是编译期检查。</p><p>与其近似的还有一个对比，就是所谓强类型和弱类型，就是不同类型变量赋值时，是否需要显式地（强制）进行类型转换。那么，如何分类 Java 语言呢？通常认为，Java 是静态的强类型语言，但是因为提供了类似反射等机制，也具备了部分动态类型语言的能力。</p><p>反射机制是 Java 语言提供的一种基础功能，赋予程序在运行时自省（introspect，官方用语）的能力。通过反射可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。</p><p>动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。</p><p>实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。</p><h4 id="int-与-Integer"><a href="#int-与-Integer" class="headerlink" title="int 与 Integer"></a>int 与 Integer</h4><p>答：int 是我们常说的整形数字，是 Java 的 8 个原始数据类型（Primitive Types，boolean、byte 、short、char、int、float、double、long）之一。Java 语言虽然号称一切都是对象，但原始数据类型是例外。</p><p>Integer 是 int 对应的包装类，它有一个 int 类型的字段存储数据，并且提供了基本操作，比如数学运算、int 和字符串之间转换等。在 Java 5 中，引入了自动装箱和自动拆箱功能（boxing/unboxing），Java 可以根据上下文，自动进行转换，极大地简化了相关编程。</p><p>关于 Integer 的值缓存，这涉及 Java 5 中另一个改进。构建 Integer 对象的传统方式是直接调用构造器，直接 new 一个对象。但是根据实践，发现大部分数据操作都是集中在有限的、较小的数值范围，因而，在 Java 5 中新增了静态工厂方法 valueOf，在调用它的时候会利用一个缓存机制，带来了明显的性能改进。按照 Javadoc，这个值默认缓存是 -128 到 127 之间。</p><h4 id="Java-IO-与多路复用。"><a href="#Java-IO-与多路复用。" class="headerlink" title="Java  IO 与多路复用。"></a>Java  IO 与多路复用。</h4><p>Java IO 方式有很多种，基于不同的 IO 抽象模型和交互方式，可以进行简单区分。</p><ul><li><p>首先，传统的 java.io 包，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。</p><p>java.io 包的好处是代码比较简单、直观，缺点则是 IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。</p><p>很多时候，人们也把 java.net 下面提供的部分网络 API，比如 Socket、ServerSocket、HttpURLConnection 也归类到同步阻塞 IO 类库，因为网络通信同样是 IO 行为。</p></li><li><p>第二，在 Java 1.4 中引入了 NIO 框架（java.nio 包），提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。</p></li><li><p>第三，在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO方式，也有很多人叫它 AIO（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。</p></li></ul><h4 id="Java-文件拷贝"><a href="#Java-文件拷贝" class="headerlink" title="Java 文件拷贝"></a>Java 文件拷贝</h4><p>Java 有多种比较典型的文件拷贝实现方式，比如：</p><ul><li><p>利用 java.io 类库，直接为源文件构建一个 FileInputStream 读取，然后再为目标文件构建一个 FileOutputStream，完成写入工作；</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">copyFileByStream</span><span class="hljs-params">(File source, File dest)</span> <span class="hljs-keyword">throws</span></span><span class="hljs-function">        IOException </span>&#123;    <span class="hljs-keyword">try</span> (InputStream is = <span class="hljs-keyword">new</span> FileInputStream(source);         OutputStream os = <span class="hljs-keyword">new</span> FileOutputStream(dest);)&#123;        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];        <span class="hljs-keyword">int</span> length;        <span class="hljs-keyword">while</span> ((length = is.read(buffer)) &gt; <span class="hljs-number">0</span>) &#123;            os.write(buffer, <span class="hljs-number">0</span>, length);        &#125;    &#125; &#125;</code></pre></li></ul><ul><li><p>或者，利用 java.nio 类库提供的 transferTo 或 transferFrom 方法实现。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">copyFileByChannel</span><span class="hljs-params">(File source, File dest)</span> <span class="hljs-keyword">throws</span></span><span class="hljs-function">        IOException </span>&#123;    <span class="hljs-keyword">try</span> (FileChannel sourceChannel = <span class="hljs-keyword">new</span> FileInputStream(source)            .getChannel();         FileChannel targetChannel = <span class="hljs-keyword">new</span> FileOutputStream(dest).getChannel                 ();)&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> count = sourceChannel.size() ;count&gt;<span class="hljs-number">0</span> ;) &#123;            <span class="hljs-keyword">long</span> transferred = sourceChannel.transferTo(                    sourceChannel.position(), count, targetChannel);            sourceChannel.position(sourceChannel.position() + transferred);            count -= transferred;        &#125;    &#125; &#125;</code></pre></li></ul><p>  当然，Java 标准类库本身已经提供了几种 Files.copy 的实现。对于 Copy 的效率，这个其实与操作系统和配置等情况相关，总体上来说，NIO transferTo/From 的方式可能更快，因为它更能利用现代操作系统底层机制，避免不必要拷贝和上下文切换。</p><h4 id="类加载过程与双亲委派模型"><a href="#类加载过程与双亲委派模型" class="headerlink" title="类加载过程与双亲委派模型"></a>类加载过程与双亲委派模型</h4><p>Java 通过引入字节码和 JVM 机制，提供了强大的跨平台能力，理解 Java 的类加载机制是深入 Java 开发的必要条件。</p><p>一般来说，Java 的类加载过程分为三个主要步骤：加载、链接、初始化，具体行为在Java 虚拟机规范里有非常详细的定义。</p><ul><li><p>首先是加载阶段，它是 Java 将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象），这里的数据源可能是各种各样的形态，如 jar 文件、class 文件，甚至是网络数据源等；如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。</p><ul><li>加载阶段是用户参与的阶段，可以自定义类加载器，去实现自己的类加载过程。</li></ul></li><li><p>第二阶段是链接，这是核心的步骤，简单说是把原始的类定义信息平滑地转化入 JVM 运行的过程中。这里可进一步细分为三个步骤：</p><ul><li>验证：这是虚拟机安全的重要保障，JVM 需要核验字节信息是符合 Java 虚拟机规范的，否则就被认为是 VerifyError，这样就防止了恶意信息或者不合规的信息危害 JVM 的运行，验证阶段有可能触发更多 class 的加载。</li><li>准备：创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显式初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的 JVM 指令；</li><li>解析：在这一步会将常量池中的符号引用替换为直接引用。在Java 虚拟机规范中，详细介绍了类、接口、方法和字段等各个方面的解析；</li></ul></li><li><p>最后是初始化阶段：真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑；</p></li></ul><p>双亲委派模型，简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载 Java 类型。</p><h4 id="常量和静态变量"><a href="#常量和静态变量" class="headerlink" title="常量和静态变量"></a>常量和静态变量</h4><p>定义下面这样的类型，分别提供了普通静态变量、静态常量，常量又考虑到原始类型和引用类型可能有区别。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CLPreparation</span> </span>&#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">100</span>;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INT_CONSTANT = <span class="hljs-number">1000</span>;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer INTEGER_CONSTANT = Integer.valueOf(<span class="hljs-number">10000</span>);&#125;</code></pre><ul><li><p>普通原始类型静态变量和引用类型（即使是常量），是需要额外调用 putstatic 等 JVM 指令的，这些是在显式初始化阶段执行，而不是准备阶段调用；</p></li><li><p>原始类型常量，则不需要这样的步骤。其实，类加载机制的范围实在太大，从开发和部署的不同角度，各选取了一个典型扩展问题供参考：</p><ul><li>如果要真正理解双亲委派模型，需要理解 Java 中类加载器的架构和职责，至少要懂具体有哪些内建的类加载器，这些是上面的回答里没有提到的；以及如何自定义类加载器；</li><li>从应用角度，解决某些类加载问题，例如Java 程序启动较慢，想办法尽量减小 Java 类加载的开销；</li></ul></li></ul><p>通常类加载机制有三个基本特征：</p><ul><li><p>双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如 JDK 内部的 ServiceProvider/ServiceLoader 机制，用户可以在标准 API 框架上，提供自己的实现，JDK 也需要提供些默认的参考实现。 例如，Java 中 JNDI、JDBC、文件系统、Cipher 等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器；</p></li><li><p>可见性。子类加载器可以访问父加载器加载的类型，但是反过来是不允许的，不然，因为缺少必要的隔离，就没有办法利用类加载器去实现容器的逻辑；</p></li><li><p>单一性。由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见；</p></li></ul><h4 id="运行时动态生成-Java-类"><a href="#运行时动态生成-Java-类" class="headerlink" title="运行时动态生成 Java 类"></a>运行时动态生成 Java 类</h4><p>可以从常见的 Java 类来源分析，通常的开发过程是，开发者编写 Java 代码，调用 javac 编译成 class 文件，然后通过类加载机制载入 JVM，就成为应用运行时可以使用的 Java 类了。</p><p>从上面过程得到启发，其中一个直接的方式是从源码入手，可以利用 Java 程序生成一段源码，然后保存到文件等，下面就只需要解决编译问题了。</p><p>有一种笨办法，直接用 ProcessBuilder 之类启动 javac 进程，并指定上面生成的文件作为输入，进行编译。最后，再利用类加载器，在运行时加载即可。</p><p>前面的方法，本质上还是在当前程序进程之外编译的，那么还有没有不这么 low 的办法呢？</p><p>可以考虑使用 Java Compiler API，这是 JDK 提供的标准 API，里面提供了与 javac 对等的编译器功能，具体请参考java.compiler相关文档。</p><p>进一步思考，一直围绕 Java 源码编译成为 JVM 可以理解的字节码，换句话说，只要是符合 JVM 规范的字节码，不管它是如何生成的，是不是都可以被 JVM 加载呢？能不能直接生成相应的字节码，然后交给类加载器去加载呢？</p><p>当然也可以，不过直接去写字节码难度太大，通常我们可以利用 Java 字节码操纵工具和类库来实现，比如 ASM、Javassist、cglib 等。</p><h4 id="数据原子性"><a href="#数据原子性" class="headerlink" title="数据原子性"></a>数据原子性</h4><p>数据的读写能否保证数据原子性。</p><h4 id="读多写少场景下如何设计可以性能提升"><a href="#读多写少场景下如何设计可以性能提升" class="headerlink" title="读多写少场景下如何设计可以性能提升"></a>读多写少场景下如何设计可以性能提升</h4><h4 id="copy-on-write原则"><a href="#copy-on-write原则" class="headerlink" title="copy-on-write原则"></a>copy-on-write原则</h4><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>Head First Java - 第二版</p><p>JavaGuide</p><p><a href="https://juejin.im/post/6844903847572275207" target="_blank" rel="noopener">深入探究Java中equals()和==的区别是什么</a></p><p><a href="https://juejin.im/post/6844903853528186887" target="_blank" rel="noopener">详解Java中的字符串</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法</title>
    <link href="/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>文章对常用的数据结构做归纳总结。</p><a id="more"></a><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><ul><li>时间和空间的转换，两者之间平衡的意识；</li><li>掌握常用的基础数据结构，包括内部实现、常用操作的时间和空间复杂度；</li><li>针对不同的场景，能够选择较为合适的数据结构；</li></ul><h1 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a>常用数据结构</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li><p>用一组连续的内存空间，存储一组具有相同类型的数据；</p></li><li><p>支持随机访问，但插入、删除操作比较低效；</p></li></ul><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="随机访问"><a href="#随机访问" class="headerlink" title="随机访问"></a>随机访问</h4><p>一维寻址公式：a[k]_address = base_address + k * type_size；</p><p>二维寻址公式，对于 m*n 的数组：a[i][j]_address = base_address + (i*n+j) * type_size；</p><p>所以，根据下标随机访问的时间复杂度为 O(1)；</p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><ul><li>开头插入：最坏时间复杂度是O(n)；</li><li>平均情况时间复杂度： (1+2+…n)/n = O(n)；</li><li>在中间第 k 位插入：时间复杂度可以达到是O(1)；<ul><li>如果数组中的数据是有序的，在某个位置插入一个新的元素时，就必须搬移 k 之后的数据，但是，</li><li>如果数组中存储的数据没有任何规律，数组只是被当作一个存储数据的集合。这种情况下，如果要将某个数据插入到第 k 个位置，为了避免大规模的数据搬移，还有一个简单的办法，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置；</li></ul></li><li>在末尾插入：时间复杂度是O(1)；</li></ul><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><ul><li>开头删除：最坏时间复杂度O(n)；</li><li>平均情况时间复杂度O(n)；</li><li>在中间第 k 位删除：每次删除操作只记录数据已被删除。当没有更多空间时，才触发执行真正的删除操作；<ul><li>在某些特殊场景下，并不一定要求数组中数据的连续性。如果将多次删除操作集中在一起执行，删除的效率会有所提高；</li><li>JVM 的标记清除垃圾回收算法的核心思想应用了这个思想；</li></ul></li><li>在末尾删除：时间复杂度O(1)；</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li><p>平时的业务开发，使用编程语言提供的容器类比较方便，有助于提高开发效率；</p></li><li><p>底层的开发适合直接使用数组，更加高效；</p></li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul><li>通过指针将一组零散的内存块串联起来使用；</li><li>插入、删除数据快；</li></ul><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>根据指针一个节点一个节点依次遍历，直到找到目标节点。</p><h4 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h4><p>只要考虑相邻节点的指针改变，时间复杂度是O(1)。</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>一种特殊的单链表，尾节点指针指向链表的头节点。</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><ul><li><p>支持两个方向，后继指针 next 指向后面的节点，前驱指针 pre 指向前面的节点；</p></li><li><p>查找、插入、删除的效率都比单链表高；</p></li></ul><h4 id="删除“值等于给定值”的节点"><a href="#删除“值等于给定值”的节点" class="headerlink" title="删除“值等于给定值”的节点"></a>删除“值等于给定值”的节点</h4><ul><li><p>从头节点开始遍历，依次对比，直到找到值等于给定值的节点，通过指针操作将其删除；</p></li><li><p>时间复杂度为O(n)；</p></li></ul><h4 id="删除给定指针指向的节点"><a href="#删除给定指针指向的节点" class="headerlink" title="删除给定指针指向的节点"></a>删除给定指针指向的节点</h4><ul><li>对于单链表，已经知道了要删除的节点，但是要删除某个结点 q 需要知道其前驱结点，而单链表不可以直接获取前驱结点，所以为了找到前驱结点，要从头结点开始遍历链表，直到 p-&gt;next=q，说明 p 是 q 的前驱结点。时间复杂度为O(n)；</li><li>对于双向链表，因为节点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，O(1) 的时间复杂度就可以完成操作；</li></ul><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><ul><li><p>链表适合插入、删除操作比较频繁的场景；</p></li><li><p>双向链表比单链表的插入、删除等操作简单、高效，适用在很多场景；</p></li><li><p>循环链表适合要处理的数据具有环形结构的特点，比如约瑟夫环问题；</p></li></ul><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>一种操作受限的线性表，只允许在一端插入和删除数据，特点是FILO。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li><p>只需要一个栈顶指针；</p></li><li><p>用数组实现的栈叫顺序栈，用链表实现的栈叫链式栈；</p></li></ul><h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 基于数组实现的顺序栈</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayStack</span> </span>&#123;  <span class="hljs-keyword">private</span> String[] items;  <span class="hljs-comment">// 数组</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;       <span class="hljs-comment">// 栈中元素个数</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;           <span class="hljs-comment">// 栈的大小</span>  <span class="hljs-comment">// 初始化数组，申请一个大小为n的数组空间</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayStack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">this</span>.items = <span class="hljs-keyword">new</span> String[n];    <span class="hljs-keyword">this</span>.n = n;    <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;  &#125;  <span class="hljs-comment">// 入栈操作</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">push</span><span class="hljs-params">(String item)</span> </span>&#123;    <span class="hljs-comment">// 数组空间不够了，直接返回false，入栈失败。</span>    <span class="hljs-keyword">if</span> (count == n) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-comment">// 将item放到下标为count的位置，并且count加一</span>    items[count] = item;    ++count;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  &#125;    <span class="hljs-comment">// 出栈操作</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 栈为空，则直接返回null</span>    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 返回下标为count-1的数组元素，并且栈中元素个数count减一</span>    String tmp = items[count-<span class="hljs-number">1</span>];    --count;    <span class="hljs-keyword">return</span> tmp;  &#125;&#125;</code></pre><h4 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 基于链表实现的链式栈</span><span class="hljs-comment"> * 注意：通俗的理解，节点的next指针是指向“底下”的节点，是指向下面的节点</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackBasedOnLinkedList</span> </span>&#123;  <span class="hljs-keyword">private</span> Node top = <span class="hljs-keyword">null</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;    Node newNode = <span class="hljs-keyword">new</span> Node(value, <span class="hljs-keyword">null</span>);    <span class="hljs-comment">// 判断是否栈空</span>    <span class="hljs-keyword">if</span> (top == <span class="hljs-keyword">null</span>) &#123;      top = newNode;    &#125; <span class="hljs-keyword">else</span> &#123;      newNode.next = top;      top = newNode;    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 这里用-1表示栈中没有数据。</span><span class="hljs-comment">   */</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (top == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> value = top.data;    top = top.next;    <span class="hljs-keyword">return</span> value;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printAll</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 用一个临时变量</span>    Node p = top;    <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;      System.out.print(p.data + <span class="hljs-string">" "</span>);      p = p.next;    &#125;    System.out.println();  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data;    <span class="hljs-keyword">private</span> Node next;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data, Node next)</span> </span>&#123;      <span class="hljs-keyword">this</span>.data = data;      <span class="hljs-keyword">this</span>.next = next;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> data;    &#125;  &#125;&#125;</code></pre><h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><ul><li>不管是顺序栈还是链式栈，存储数据只需要一个大小为 n 的数组。在<strong>入栈</strong>和<strong>出栈</strong>过程中，只需要一两个临时变量存储空间，所以<strong>空间复杂度是 O(1)</strong>；<ul><li><strong>注：</strong>这里存储数据需要一个大小为 n 的数组，并不是说空间复杂度就是 O(n)。因为这 n 个空间是必须的，无法省掉。<strong>所以空间复杂度，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间</strong>；</li></ul></li><li>顺序栈还是链式栈，<strong>入栈、出栈</strong>只涉及<strong>栈顶</strong>个别数据的操作，所以时间复杂度都是 O(1)；</li></ul><h3 id="动态扩容的栈"><a href="#动态扩容的栈" class="headerlink" title="动态扩容的栈"></a>动态扩容的栈</h3><p>尽管链式栈的大小不受限，但要存储 next 指针，<strong>内存消耗相对较多</strong>。</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><ul><li><p>底层依赖一个支持动态扩容的数组；</p></li><li><p>栈满之后，要申请一个更大的数组，将原来的数据搬移到新的数组中；</p></li></ul><h4 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h4><ul><li><p>最好情况时间复杂度是O(1)；</p></li><li><p>最坏情况时间复杂度是O(n)；</p></li><li><p>均摊时间复杂度是O(1)；</p></li></ul><h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><p>时间复杂度是O(1)。</p><h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><h4 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h4><p>作为一个比较基础的数据结构，<strong>应用场景较多</strong>。一个比较经典的应用场景就是<strong>函数调用栈</strong>。栈可以用于在函数调用时保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？</p><ul><li>其实，不一定非要用栈来保存临时变量，只不过函数调用符合<strong>后进先出</strong>的特性，用栈这种数据结构来实现，是最<strong>顺理成章</strong>的选择；</li><li>从调用函数进入被调用函数，对于<strong>数据</strong>来说，变化的是什么呢？是<strong>作用域</strong>。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段<strong>栈空间</strong>给这个函数的变量，在函数结束的时候，将<strong>栈顶复位</strong>，正好回到调用函数的作用域内；</li></ul><p><strong>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构</strong>，用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;   ret = add(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>);   res = a + ret;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, res);   reuturn <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;   <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;   sum = x + y;   <span class="hljs-keyword">return</span> sum;&#125;</code></pre><p><img src="%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88.PNG" srcset="/img/loading.gif" alt=""></p><h4 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h4><p>算术表达式只包含加减乘除四则运算。一个保存操作数的栈，另一个是保存运算符的栈。</p><ul><li>从左向右遍历表达式，当遇到<strong>数字</strong>，就直接<strong>压入操作数栈</strong>；</li><li>当遇到<strong>运算符</strong>，就与<strong>运算符栈的栈顶元素</strong>进行比较，<ul><li>如果比运算符栈顶元素的<strong>优先级高</strong>，就将当前运算符<strong>压栈</strong>；</li><li>如果比运算符栈顶元素的优先级<strong>低或者相同</strong>，从运算符栈中<strong>取栈顶运算符</strong>，从操作数栈的栈顶<strong>取 2 个操作数</strong>，然后进行计算，再把计算完的结果<strong>压入操作数栈</strong>，继续比较；</li></ul></li></ul><h4 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h4><p>表达式中只包含三种括号，圆括号 ()、方括号[]和花括号{}，可以任意嵌套。给定一个包含三种括号的表达式字符串。用栈可以解决检查它的合法性。</p><ul><li>用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；</li><li>当扫描到右括号时，从栈顶取出一个左括号，<ul><li>如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串；</li><li>如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式；</li></ul></li><li>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式；</li></ul><h4 id="实现浏览器的前进、后退功能"><a href="#实现浏览器的前进、后退功能" class="headerlink" title="实现浏览器的前进、后退功能"></a>实现浏览器的前进、后退功能</h4><p>使用两个栈，X 和 Y，把首次浏览的页面依次压入栈 X，</p><ul><li>当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y；</li><li>当点击前进按钮时，依次从栈 Y 中取出数据，放入栈 X 中；</li><li>当栈 X 中没有数据时，就说明没有页面可以继续后退浏览了；当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了；</li></ul><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>一种操作受限的线性表数据结构，特性是FIFO。</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>需要两个指针，head指针指向队头，tail指针指向队尾。</p><h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><ul><li><p>用数组实现的队列；</p></li><li><p>出队时不用搬移数据。如果没有空闲空间，只需要在入队时再集中触发一次数据的搬移操作；</p></li></ul><p>队满的判断条件是 tail == n，队空的判断条件是 head == tail。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 基于数组实现的队列</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayQueue</span> </span>&#123;  <span class="hljs-comment">// 数组：items，数组大小：n</span>  <span class="hljs-keyword">private</span> String[] items;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;  <span class="hljs-comment">// head表示队头下标，tail表示队尾下标</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tail = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 申请一个大小为capacity的数组</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;    items = <span class="hljs-keyword">new</span> String[capacity];    n = capacity;  &#125;  <span class="hljs-comment">// 入队</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(String item)</span> </span>&#123;    <span class="hljs-comment">// 如果tail == n 表示队列已经满了</span>    <span class="hljs-keyword">if</span> (tail == n) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    items[tail] = item;    ++tail;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  &#125;  <span class="hljs-comment">// 出队</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 如果head == tail 表示队列为空</span>    <span class="hljs-keyword">if</span> (head == tail) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 为了让其他语言的同学看的更加明确，把--操作放到单独一行来写了</span>    String ret = items[head];    ++head;    <span class="hljs-keyword">return</span> ret;  &#125;&#125;</code></pre><p>以上的不停地入队、出队操作，head 和 tail 都会持续往后移动。当 tail 移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。</p><p>一个可能的解决方案：在出队时可以不用搬移数据。<strong>如果没有空闲空间，只需要在入队时，再集中触发一次数据的搬移操作</strong>。借助这个思想，出队函数 dequeue() 保持不变，<strong>改造一下入队函数 enqueue()</strong> 的实现，就可以解决刚才的问题。</p><pre><code class="hljs java"><span class="hljs-comment">// 入队操作，将item放入队尾</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(String item)</span> </span>&#123;  <span class="hljs-comment">// tail == n表示队列末尾没有空间了</span>  <span class="hljs-keyword">if</span> (tail == n) &#123;    <span class="hljs-comment">// tail ==n &amp;&amp; head==0，表示整个队列都占满了</span>    <span class="hljs-keyword">if</span> (head == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-comment">// 数据搬移</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head; i &lt; tail; ++i) &#123;      items[i-head] = items[i];    &#125;    <span class="hljs-comment">// 搬移完之后重新更新head和tail</span>    tail -= head;    head = <span class="hljs-number">0</span>;  &#125;    items[tail] = item;  ++tail;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><h3 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h3><p>用链表实现的队列。基于链表的实现，需要两个指针：</p><ul><li>head 指针指向链表的第一个结点；</li><li>tail 指针指向最后一个结点；</li><li>入队时：tail-&gt;next= new_node, tail = tail-&gt;next；</li><li>出队时：head = head-&gt;next；</li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 基于链表实现的队列</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueueBasedOnLinkedList</span> </span>&#123;  <span class="hljs-comment">// 队列的队首和队尾</span>  <span class="hljs-keyword">private</span> Node head = <span class="hljs-keyword">null</span>;  <span class="hljs-keyword">private</span> Node tail = <span class="hljs-keyword">null</span>;  <span class="hljs-comment">// 入队</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(String value)</span> </span>&#123;    <span class="hljs-keyword">if</span> (tail == <span class="hljs-keyword">null</span>) &#123;      Node newNode = <span class="hljs-keyword">new</span> Node(value, <span class="hljs-keyword">null</span>);      head = newNode;      tail = newNode;    &#125; <span class="hljs-keyword">else</span> &#123;      tail.next = <span class="hljs-keyword">new</span> Node(value, <span class="hljs-keyword">null</span>);      tail = tail.next;    &#125;  &#125;  <span class="hljs-comment">// 出队</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    String value = head.data;    head = head.next;    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      tail = <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-keyword">return</span> value;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printAll</span><span class="hljs-params">()</span> </span>&#123;    Node p = head;    <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;      System.out.print(p.data + <span class="hljs-string">" "</span>);      p = p.next;    &#125;    System.out.println();  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">private</span> String data;    <span class="hljs-keyword">private</span> Node next;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(String data, Node next)</span> </span>&#123;      <span class="hljs-keyword">this</span>.data = data;      <span class="hljs-keyword">this</span>.next = next;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> data;    &#125;  &#125;&#125;</code></pre><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>用数组来实现队列的时候，在 tail==n 时，会有<strong>数据搬移</strong>操作，这样入队操作性能就会受到影响。可以使用逻辑上数组首尾相连成环的循环队列解决这个问题。</p><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>确定好队空和队满的判定条件：</p><ul><li>队空：head == tail；</li><li>队满：(tail + 1) % n == head；</li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 基于数组实现的循环队列</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircularQueue</span> </span>&#123;  <span class="hljs-comment">// 数组：items，数组大小：n</span>  <span class="hljs-keyword">private</span> String[] items;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;  <span class="hljs-comment">// head表示队头下标，tail表示队尾下标</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tail = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 申请一个大小为capacity的数组</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CircularQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;    items = <span class="hljs-keyword">new</span> String[capacity];    n = capacity;  &#125;  <span class="hljs-comment">// 入队</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(String item)</span> </span>&#123;    <span class="hljs-comment">// 队列满了</span>    <span class="hljs-keyword">if</span> ((tail + <span class="hljs-number">1</span>) % n == head) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    items[tail] = item;    tail = (tail + <span class="hljs-number">1</span>) % n;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  &#125;  <span class="hljs-comment">// 出队</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 如果head == tail 表示队列为空</span>    <span class="hljs-keyword">if</span> (head == tail) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    String ret = items[head];    head = (head + <span class="hljs-number">1</span>) % n;    <span class="hljs-keyword">return</span> ret;  &#125;&#125;</code></pre><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>队列满时，tail指向的位置没有存储数据，所以循环队列会浪费一个数组的存储空间。</p><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><ul><li><p>在队列的基础上增加了阻塞操作；</p></li><li><p>队列为空时，从队头取数据会被阻塞；</p></li></ul><h3 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h3><p>线程安全的队列。</p><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>方式一：直接在enqueue()、dequeue() 上加锁，锁粒度大并发度会比较低下，同一时刻仅允许一个存取数操作。</p><p>方式二：利用 CAS 原子操作，可以实现非常高效的并发队列。</p><h3 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h3><ul><li>平时的业务很少直接用到队列；</li><li>一些具有特殊特性的队列应用比较广泛，比如循环队列、阻塞队列和并发队列；</li><li>循环队列比链式队列应用更加广泛；</li><li>高性能队列 Disruptor、Linux环形缓存，都用到了循环并发队列；</li><li>Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等；</li></ul><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>每个节点最多有两个子节点，即左子节点和右子节点。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul><li><p>节点高度 = 节点到叶子节点的最长路径（边数）；</p></li><li><p>节点深度 =  根节点到这个节点所经历的边的个数；</p></li><li><p>节点层数 = 节点深度 + 1；</p></li><li><p>树的高度 = 根节点的高度；</p></li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li><p>满二叉树：叶子节点全都在最底层，除叶子节点之外，每个节点都有左右两个子节点；</p></li><li><p>完全二叉树：叶子节点都在最底下两层，而且最后一层的叶子节点都靠左排列；</p></li><li><p>二叉查找树：最大的特点是支持<strong>动态数据集合的快速插入、删除、查找操作</strong>。树中的任意一个节点，</p><ul><li>其左子树中的每个节点的值，都要小于这个节点的值；</li><li>其右子树中的每个节点的值，都要大于这个节点的值；</li></ul></li></ul><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><h3 id="BST查找操作"><a href="#BST查找操作" class="headerlink" title="BST查找操作"></a>BST查找操作</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySearchTree</span> </span>&#123;  <span class="hljs-keyword">private</span> Node tree;  <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;    Node p = tree;    <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">if</span> (data &lt; p.data) p = p.left;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data &gt; p.data) p = p.right;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> p;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;  &#125;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data;    <span class="hljs-keyword">private</span> Node left;    <span class="hljs-keyword">private</span> Node right;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;      <span class="hljs-keyword">this</span>.data = data;    &#125;  &#125;&#125;</code></pre><h3 id="BST的插入操作"><a href="#BST的插入操作" class="headerlink" title="BST的插入操作"></a>BST的插入操作</h3><p>二叉查找树的插入过程有点类似查找操作。新插入的数据<strong>一般都是在叶子节点</strong>上，所以只需要从根节点开始，依次<strong>比较要插入的数据和节点的大小关系</strong>。</p><ul><li>如果要插入的数据比节点的数据大：<ol><li>并且节点的右子树为空，就将新数据直接插到右子节点的位置；</li><li>如果不为空，就递归遍历右子树，查找插入位置；</li></ol></li><li>如果要插入的数据比节点数值小：<ol><li>并且节点的左子树为空，就将新数据直接插到左子节点的位置；</li><li>如果不为空，就递归遍历左子树，查找插入位置；</li></ol></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;  <span class="hljs-keyword">if</span> (tree == <span class="hljs-keyword">null</span>) &#123;    tree = <span class="hljs-keyword">new</span> Node(data);    <span class="hljs-keyword">return</span>;  &#125;  Node p = tree;  <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">if</span> (data &gt; p.data) &#123;      <span class="hljs-keyword">if</span> (p.right == <span class="hljs-keyword">null</span>) &#123;        p.right = <span class="hljs-keyword">new</span> Node(data);        <span class="hljs-keyword">return</span>;      &#125;      p = p.right;    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// data &lt; p.data</span>      <span class="hljs-keyword">if</span> (p.left == <span class="hljs-keyword">null</span>) &#123;        p.left = <span class="hljs-keyword">new</span> Node(data);        <span class="hljs-keyword">return</span>;      &#125;      p = p.left;    &#125;  &#125;&#125;</code></pre><h3 id="BST的删除操作"><a href="#BST的删除操作" class="headerlink" title="BST的删除操作"></a>BST的删除操作</h3><p>BST的删除操作相对复杂，针对要删除节点的子节点个数的不同，需要分三种情况来处理。</p><ul><li>如果<strong>要删除的节点没有子节点</strong>，只需要直接将父节点中，指向要删除节点的指针置为 null。</li><li>如果<strong>要删除的节点只有一个子节点</strong>（只有左子节点或者右子节点），只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。</li><li>如果<strong>要删除的节点有两个子节点</strong>。那么需要<strong>找到这个节点的右子树中的最小节点</strong>，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;  Node p = tree; <span class="hljs-comment">// p指向要删除的节点，初始化指向根节点</span>  Node pp = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// pp记录的是p的父节点</span>  <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; p.data != data) &#123;    pp = p;    <span class="hljs-keyword">if</span> (data &gt; p.data) p = p.right;    <span class="hljs-keyword">else</span> p = p.left;  &#125;  <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 没有找到</span>  <span class="hljs-comment">// 要删除的节点有两个子节点</span>  <span class="hljs-keyword">if</span> (p.left != <span class="hljs-keyword">null</span> &amp;&amp; p.right != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 查找右子树中最小节点</span>    Node minP = p.right;    Node minPP = p; <span class="hljs-comment">// minPP表示minP的父节点</span>    <span class="hljs-keyword">while</span> (minP.left != <span class="hljs-keyword">null</span>) &#123;      minPP = minP;      minP = minP.left;    &#125;    p.data = minP.data; <span class="hljs-comment">// 将minP的数据替换到p中</span>    p = minP; <span class="hljs-comment">// 下面就变成了删除minP了</span>    pp = minPP;  &#125;  <span class="hljs-comment">// 删除节点是叶子节点或者仅有一个子节点</span>  Node child; <span class="hljs-comment">// p的子节点</span>  <span class="hljs-keyword">if</span> (p.left != <span class="hljs-keyword">null</span>) child = p.left;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.right != <span class="hljs-keyword">null</span>) child = p.right;  <span class="hljs-keyword">else</span> child = <span class="hljs-keyword">null</span>;  <span class="hljs-keyword">if</span> (pp == <span class="hljs-keyword">null</span>) tree = child; <span class="hljs-comment">// 删除的是根节点</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pp.left == p) pp.left = child;  <span class="hljs-keyword">else</span> pp.right = child;&#125;</code></pre><h3 id="BST的其他操作"><a href="#BST的其他操作" class="headerlink" title="BST的其他操作"></a>BST的其他操作</h3><ul><li>除了<strong>插入、删除、查找</strong>操作之外，二叉查找树中还可以支持快速地<strong>查找最大节点</strong>和<strong>最小节点</strong>、<strong>前驱节点</strong>和<strong>后继节点</strong>；</li><li>二叉查找树除了支持上面几个操作之外，还有一个重要的特性，就是<strong>中序遍历二叉查找树，可以输出有序的数据序列</strong>，时间复杂度是 O(n)，非常高效。因此，二叉查找树也叫作<strong>二叉排序树</strong>；</li><li>支持重复数据的二叉查找树： <ul><li>很多时候，在二叉查找树中存储的是一个包含很多字段的对象。利用对象的某个字段作为<strong>键值</strong>来构建二叉查找树。对象中的其他字段叫作<strong>卫星数据</strong>；</li></ul></li></ul><h3 id="散列表与BST"><a href="#散列表与BST" class="headerlink" title="散列表与BST"></a>散列表与BST</h3><p>散列表也支持这些操作，且相比于二叉查找树更高效，时间复杂度是 O(1)。思考这两种数据结构的适用场景。</p><ul><li>散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。BST中序遍历可以在 O(n) 时间复杂度内输出有序的数据序列；</li><li>散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定；尽管二叉查找树的性能不稳定，但是在工程中，最常用的平衡二叉查找树的性能稳定，时间复杂度稳定在 O(logn)；</li><li>尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定比平衡二叉查找树的效率高；</li><li>散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定；</li><li>为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间；</li></ul><p>综合这几点，平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲突。实际的开发过程中，需要结合具体的需求来选择使用哪一个。</p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><ul><li><p>链式存储法</p></li><li><p>顺序存储法</p></li></ul><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>将所有节点都遍历打印出来。经典的方法有<strong>前序遍历、中序遍历和后序遍历</strong>。其中，前、中、后序，表示的是<strong>节点与它的左右子树节点</strong>遍历打印的<strong>先后顺序</strong>。二叉树的前、中、后序遍历是一个<strong>递归</strong>的过程。时间复杂度均为O(n)；</p><ul><li>前序遍历：根-&gt;左子树-&gt;右子树；</li><li>中序遍历：左子树-&gt;根-&gt;右子树；</li><li>后序遍历：左子树-&gt;右子树-&gt;根；</li></ul><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><ul><li>一个完全二叉树；</li><li>每一个节点的值都必须大于等于（或小于等于）其子树中的每个节点的值；</li></ul><h2 id="存储-1"><a href="#存储-1" class="headerlink" title="存储"></a>存储</h2><p>完全二叉树比较适合用数组来存储。用数组来存储完全二叉树节省存储空间。通过数组的下标，可以找到一个节点的左右子节点和父节点，而不需要存储左右子节点的指针。假设节点在数组中的下标为 i，那么：</p><ul><li>其父节点的下标为 i/2；</li><li>其左子节点的下标为 i∗2；</li><li>其右子节点的下标为 i∗2+1；</li></ul><h2 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h2><p>插入一个元素和删除堆顶元素。</p><h2 id="基于堆实现排序"><a href="#基于堆实现排序" class="headerlink" title="基于堆实现排序"></a>基于堆实现排序</h2><ol><li>建堆<ul><li>思路1：从前往后处理数组，并且每个数据插入堆中时，都是从下往上堆化；</li><li>思路2：从后往前处理数组，并且每个数据都是从上往下堆化</li></ul></li><li>第二步：排序<ol><li>堆顶跟最后一个元素交换，把下标为n的元素放到堆顶，通过堆化的方法，将剩下的 n - 1 个元素重新构建成堆；</li><li>堆化完成之后，取堆顶的元素，放到下标是 n - 1 的位置；</li><li>一直重复这个过程，直到最后堆中只剩下标为 1 的一个元素，排序工作完成</li></ol></li></ol><h3 id="快速排序与堆排序"><a href="#快速排序与堆排序" class="headerlink" title="快速排序与堆排序"></a>快速排序与堆排序</h3><ul><li><p>堆排序数据访问的方式没有快速排序友好</p><ul><li><p>对于快速排序来说，数据是顺序访问的；</p></li><li><p>对于堆排序来说，数据是跳着访问的；</p><ul><li>堆排序中，最重要的一个操作就是数据的堆化。对堆顶节点进行堆化，访问数组的元素对应的下标是跳跃的，快速排序则是局部顺序访问。所以，堆排序<strong>对 CPU 缓存是不友好的</strong>。</li></ul></li></ul></li><li><p>同样的数据，在排序过程中，堆排序算法的数据交换次数多于快速排序</p><ul><li>排序的时候有序度和逆序度两个概念；</li><li>对于<strong>基于比较的排序算法</strong>来说，整个排序过程就是由<strong>比较和交换（或移动）</strong>这两个基本的操作组成的；</li><li><strong>快速排序数据交换的次数不会比逆序度多</strong>，但是堆排序的第一步是建堆，<strong>建堆</strong>的过程会打乱数据原有的相对先后顺序，<strong>导致原数据的有序度降低</strong>。比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了；</li></ul></li><li><p>所以，快速排序比堆排序性能好</p></li></ul><h2 id="堆内容小结"><a href="#堆内容小结" class="headerlink" title="堆内容小结"></a>堆内容小结</h2><ul><li>堆是一种<strong>完全二叉树</strong>。它最大的特性是：<strong>每个节点的值都大于等于（或小于等于）其子树节点的值</strong>。因此，堆被分成了两类，<strong>大顶堆和小顶堆</strong>；</li><li>堆中比较重要的两个操作是<strong>插入一个数据</strong>和<strong>删除堆顶元素</strong>。这两个操作都要用到堆化；<ul><li><strong>插入</strong>一个数据的时候，把新插入的数据<strong>放到数组的最后</strong>，然后<strong>从下往上堆化</strong>；</li><li><strong>删除堆顶数据</strong>的时候，把数组中的<strong>最后一个元素放到堆顶</strong>，然后从<strong>上往下堆化</strong>；</li><li>这两个操作时间复杂度都是 O(logn)；</li></ul></li><li>堆排序，堆排序包含两个过程：</li><li>建堆和排序；<ul><li>建堆：将<strong>下标从 n/2 到 1 的节点</strong>，依次进行<strong>从上到下的堆化操作</strong>，就可以将数组中的数据组织成堆这种数据结构；</li><li>排序：<strong>迭代地将堆顶的元素放到堆的末尾，并将堆的大小减一，然后再堆化</strong>。重复这个过程，直到堆中只剩下一个元素，整个数组中的数据就都<strong>有序排列</strong>了；</li></ul></li><li><strong>优先级队列</strong>是一种特殊的队列，优先级高的数据先出队，不像普通的队列那样，先进先出。实际上，<strong>堆就可以看作优先级队列</strong>，只是称谓不一样罢了；</li><li><strong>Top K 问题</strong>可以分为<strong>针对静态数据</strong>和<strong>针对动态数据</strong>，只需要利用一个堆，就可以做到非常高效率的查询 Top K 的数据；</li><li><strong>求中位数</strong>实际上还有很多变形，比如<strong>求 99 百分位数据、90 百分位数据</strong>等，处理的思路都是一样的，即<strong>利用两个堆，一个大顶堆，一个小顶堆</strong>，随着数据的动态添加，<strong>动态调整两个堆中的数据</strong>，最后<strong>大顶堆的堆顶元素就是要求的数据</strong>；</li></ul><h2 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h2><h3 id="实现优先级队列"><a href="#实现优先级队列" class="headerlink" title="实现优先级队列"></a>实现优先级队列</h3><p>队列最大的特性就是先进先出。在优先级队列中，数据的出队顺序不是先进先出，而是按照<strong>优先级</strong>来，优先级最高的，最先出队。</p><p>实现一个优先级队列的方法有很多，但是用堆来实现是<strong>最直接、最高效</strong>的。这是因为，堆和优先级队列非常相似。一个堆就可以看作一个优先级队列。很多时候，它们只是概念上的区分而已。<strong>往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素</strong>。</p><p>优先级队列的应用场景非常多。很多数据结构和算法都要依赖它。比如，赫夫曼编码、图的最短路径、最小生成树算法等等。很多语言都提供了优先级队列的实现，Java 的 PriorityQueue，C++ 的 priority_queue 等。</p><h3 id="合并有序小文件"><a href="#合并有序小文件" class="headerlink" title="合并有序小文件"></a>合并有序小文件</h3><p>假设有 100 个小文件，每个文件的大小是 100MB，每个文件中存储的都是有序的字符串。希望将这些 100 个小文件合并成一个有序的大文件。</p><p><strong>方法一：</strong>整体思路有点像归并排序中的合并函数：</p><ul><li>从这 100 个文件中，<strong>各取第一个字符串</strong>，放入数组中，然后比较大小，把<strong>最小的字符串</strong>放入合并后的大文件中，并从数组中删除；</li><li>假设，这个最小的字符串来自于 a.txt 这个小文件，就再从这个小文件<strong>取下一个字符串</strong>，放到数组中，<strong>重新比较大小</strong>，并且选择最小的放入合并后的大文件，将它从数组中删除；</li><li>依次类推，直到所有的文件中的数据都放入到大文件为止；</li><li>这里用数组这种数据结构，来存储从小文件中取出来的字符串。每次从数组中取最小字符串，都需要循环遍历整个数组，显然，这不是很高效。</li></ul><p><strong>方法二：</strong>优先级队列，也可以说是堆：</p><ul><li>把小文件中取出来的字符串放入到小顶堆中，<strong>堆顶的元素就是优先级队列队首的元素</strong>，就是最小的字符串；</li><li>将这个字符串放入到大文件中，并将其从堆中删除；</li><li>再从小文件中取出下一个字符串，放入到堆中；</li><li>循环这个过程，就可以将 100 个小文件中的数据依次放入到大文件中；</li><li>删除堆顶数据和往堆中插入数据的时间复杂度都是 O(logn)，n 表示堆中的数据个数，这里就是 100。该方法比原来数组存储的方式高效；</li></ul><h3 id="高性能定时器"><a href="#高性能定时器" class="headerlink" title="高性能定时器"></a>高性能定时器</h3><p>假设有一个定时器，定时器中维护了很多定时任务，每个任务都设定了一个要触发执行的时间点。<strong>定时器每过一个很小的单位时间（比如 1 秒），就扫描一遍任务，看是否有任务到达设定的执行时间。如果到达了，就拿出来执行。</strong></p><p>但是，这样每过 1 秒就扫描一遍任务列表的做法比较低效，主要原因有两点：</p><ul><li>任务的约定执行时间离当前时间可能还有很久，这样前面很多次扫描其实都是徒劳的；</li><li>每次都要扫描整个任务列表，如果任务列表很大的话，势必会比较耗时。</li></ul><p>针对这些问题，可以用优先级队列来解决：</p><ul><li>按照任务设定的执行时间，将这些任务存储在优先级队列中，<strong>队列首部（也就是小顶堆的堆顶）存储的是最先执行的任务</strong>；<ul><li>这样，定时器就不需要每隔 1 秒就扫描遍历任务列表了；</li></ul></li><li>取队首任务的执行时间点，与当前时间点相减，得到一个<strong>时间间隔 T</strong>。这个时间间隔 T 就是，从当前时间开始，需要等待多久，才会有第一个任务需要被执行。这样，<strong>定时器就可以设定在 T 秒之后，定时器取优先级队列中队首的任务执行</strong>。<ul><li>这样，当前时间点到（T-1）秒这段时间里，定时器都不需要做任何事情；</li></ul></li><li>再计算新的队首任务的执行时间点与当前时间点的差值，把这个值作为定时器执行下一个任务需要等待的时间；</li><li><strong>循环以上操作</strong>，定时器既不用间隔 1 秒就轮询一次，也不用遍历整个任务列表，性能就提高了。</li></ul><h3 id="针对静态-动态数据集合求Top-K"><a href="#针对静态-动态数据集合求Top-K" class="headerlink" title="针对静态/动态数据集合求Top K"></a>针对静态/动态数据集合求Top K</h3><ul><li>针对静态数据集合，也就是说数据集合事先确定，不会再变；<ul><li>在一个包含 n 个数据的数组中，查找前 K 大数据：<ul><li><strong>维护一个大小为 K 的小顶堆</strong>，顺序遍历数组，从数组中取出数据与堆顶元素比较：<ul><li>若比堆顶元素大，就把堆顶元素删除，并且将这个元素插入到堆中；</li><li>若比堆顶元素小，则不做处理，继续遍历数组；</li><li>遍历数组中的数据，遍历结束后，堆中的数据就是前 K 大数据了。</li></ul></li><li>遍历数组需要 O(n) 的时间复杂度，<strong>一次堆化操作需要 O(logK)</strong> 的时间复杂度，所以最坏情况下，n 个元素都入堆一次，时间复杂度就是 O(nlogK)。</li></ul></li></ul></li><li>针对动态数据集合，也就是说数据集合事先并不确定，有数据动态地加入到集合中：<ul><li>针对动态数据求得 Top K 就是实时 Top K。一个数据集合中有两个操作，一个是<strong>添加数据</strong>，另一个询问<strong>当前的前 K 大数据</strong>：<ul><li>如果每次询问前 K 大数据，都基于当前的数据重新计算的话，那时间复杂度就是 O(nlogK)，n 表示当前的数据的大小。</li><li>实际上，可以一直都<strong>维护一个 K 大小的小顶堆</strong>，当有数据被添加到集合中时，将其与堆顶的元素对比：<ul><li>若比堆顶元素大，就把堆顶元素删除，并且将这个元素插入到堆中；</li><li>若比堆顶元素小，则不做处理；</li><li>这样，无论任何时候需要查询当前的前 K 大数据，都可以立刻将结果返回。</li></ul></li></ul></li></ul></li></ul><h3 id="热榜-Top10-关键词"><a href="#热榜-Top10-关键词" class="headerlink" title="热榜 Top10 关键词"></a>热榜 Top10 关键词</h3><p>处理这个问题，有很多高级的解决方法，比如使用 MapReduce 等。</p><p>将处理的场景限定为单机，可以使用的内存为 1GB，该问题的可选解决方案为：</p><ul><li>用户搜索的关键词，有很多可能都是重复的，所以首先要统计每个搜索关键词出现的频率。可以通过<strong>散列表、平衡二叉查找树或者其他一些支持快速查找、插入的数据结构</strong>，来记录关键词及其出现的次数；<ul><li>假设选用<strong>散列表</strong>，可以顺序扫描这 10 亿个搜索关键词。当扫描到某个关键词时，就去散列表中查询：<ul><li>如果存在，将对应的次数加一；</li><li>如果不存在，将它插入到散列表，并记录次数为 1；</li><li>遍历完这 10 亿个搜索关键词之后，散列表中就存储了不重复的搜索关键词以及出现的次数；</li></ul></li></ul></li><li>然后，再根据前面讲的<strong>用堆求 Top K 的方法</strong>，建立一个大小为 10 的小顶堆，遍历散列表，依次取出每个搜索关键词及对应出现的次数，然后与堆顶的搜索关键词对比。如果出现次数比堆顶搜索关键词的次数多，那就删除堆顶的关键词，将这个出现次数更多的关键词加入到堆中；</li><li>以此类推，当遍历完整个散列表中的搜索关键词之后，堆中的搜索关键词就是出现次数最多的 Top 10 搜索关键词了；</li><li><strong>上面的解决思路其实存在漏洞</strong>。10 亿的关键词还是很多的。假设 10 亿条搜索关键词中不重复的有 1 亿条，如果每个搜索关键词的平均长度是 50 个字节，那存储 1 亿个关键词起码需要 <strong>5GB</strong> 的内存空间，而散列表因为要避免频繁冲突，不会选择太大的装载因子，所以<strong>消耗的内存空间就更多</strong>了。而<strong>机器只有 1GB 的可用内存空间</strong>，所以无法一次性将所有的搜索关键词加入到内存中。</li><li>在哈希算法那一节讲过，<strong>相同数据经过哈希算法得到的哈希值是一样的</strong>。可以根据哈希算法的这个特点，<strong>将 10 亿条搜索关键词先通过哈希算法分片到 10 个文件中</strong>。具体可以这样做：<ul><li>创建 10 个空文件 00，01，02，……，09；</li><li><strong>遍历这 10 亿个关键词，并且通过某个哈希算法对其求哈希值，然后哈希值同 10 取模，</strong>得到的结果就是这个搜索关键词应该被分到的文件编号；</li></ul></li><li>对这<strong>10亿个关键词分片</strong>之后，每个文件都只有 1 亿的关键词，去除掉重复的，可能就只有 1000 万个，每个关键词平均 50 个字节，所以总的大小就是 500MB。1GB 的内存完全可以放得下；</li><li><strong>针对每个包含 1 亿条搜索关键词的文件，利用散列表和堆，分别求出 Top 10</strong>，然后把这个 10 个 Top 10 放在一块，然后取这 100 个关键词中，出现次数最多的 10 个关键词，这就是这 10 亿数据中的 Top 10 最频繁的搜索关键词了；</li></ul><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>一种非线性表数据结构，比树要复杂</p><h2 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h2><ul><li><p>有向图</p></li><li><p>无向图</p></li><li><p>带权图</p></li></ul><h2 id="存储-2"><a href="#存储-2" class="headerlink" title="存储"></a>存储</h2><h3 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h3><p>缺点：浪费存储空间</p><p>优点：存储方式简单、直接、方便计算</p><p>应用：Floyd-Warshall算法</p><h3 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h3><ul><li>查询效率没有邻接矩阵存储方式高；</li><li>如果链过长，可以将链表转换成其他更高效的数据结构，比如平衡二叉查找树；</li><li>实际开发中，用红黑树或者其他动态数据结构，比如跳表、散列表等，更加快速地查找两个顶点之间是否存在边；</li><li>将链表改成有序动态数组，通过二分查找的方法快速定位两个顶点之间是否存在边；</li></ul><h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><ul><li><p>通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置；</p></li><li><p>当按照键值查询元素时，可以用同样的散列函数，将键值转化为数组下标，从对应的数组下标的位置取元素；</p></li><li><p>数组的一种扩展，由数组演化而来。没有数组，就没有散列表。</p></li></ul><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>hash(key)（key表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值）。</p><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><p>散列函数计算得到的散列值是一个非负整数。</p><ul><li><p>如果 key1 == key2, 那么 hash(key1) == hash(key2)</p></li><li><p>如果 key1 != key2, 那么 hash(key1) != hash(key2)</p></li></ul><h3 id="设计要点"><a href="#设计要点" class="headerlink" title="设计要点"></a>设计要点</h3><ul><li><p>散列函数的设计不能太过复杂；</p></li><li><p>散列函数生成的值要尽可能随机并且均匀分布；</p></li></ul><h2 id="装载因子"><a href="#装载因子" class="headerlink" title="装载因子"></a>装载因子</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>散列表的装载因子 = 填入表中的元素个数 / 散列表的长度；</p><ul><li>装填因子越大，说明空闲的位置越少，冲突越多，散列表的性能会下降；</li></ul><h3 id="装载因子过大怎么办"><a href="#装载因子过大怎么办" class="headerlink" title="装载因子过大怎么办"></a>装载因子过大怎么办</h3><ul><li>当装载因子过大时，可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到新散列表中；</li><li>针对散列表的扩容，数据搬移操作比数组要复杂的多，需要通过散列函数重新计算每个数据的存储位置；</li></ul><h2 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h2><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>如果出现散列冲突，就重新探测一个空闲位置，将其插入。</p><h4 id="应用-5"><a href="#应用-5" class="headerlink" title="应用"></a>应用</h4><p>数据量比较小，装载因子小的时候，适合采用开放寻址法。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><p>散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度；</p></li><li><p>这样实现的散列表，序列化起来比较简单；</p></li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li><p>删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据；</p></li><li><p>装载因子的上限不能太大；</p></li></ul><h4 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h4><p>往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p><h4 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a>二次探测</h4><p>和线性探测有共同点：</p><ul><li><p>线性探测每次探测的步长是1，探测的下标序列就是hash(key) + 0，hash(key) + 1，hash(key) + 2，……</p></li><li><p>二次探测探测的步长就变成了原来的“二次方”，探测的下标序列就是hash(key) + 0，hash(key) + 1^2，hash(key) + 2^2，……</p></li></ul><h4 id="双重散列"><a href="#双重散列" class="headerlink" title="双重散列"></a>双重散列</h4><p>先用一组散列表中的第一个散列函数，计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p><h3 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h3><p>一种更加常用的散列冲突的解决办法，比开放寻址法简单很多。</p><p>每个“桶”（bucket）或者”槽“（slot）会对应一条链表。所有散列值相同的元素都放到相同槽位对应的链表中。</p><h4 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a>操作</h4><ul><li><p>插入时，只需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表中即可；</p></li><li><p>查找、删除一个元素时，同样通过散列函数计算出对应的槽，遍历链表查找或者删除；</p></li></ul><h4 id="应用-6"><a href="#应用-6" class="headerlink" title="应用"></a>应用</h4><ul><li><p>适合存储大对象，大数据量的散列表；</p></li><li><p>更加灵活、支持更多的优化策略，比如用红黑树代替链表；</p></li></ul><h2 id="散列表的应用"><a href="#散列表的应用" class="headerlink" title="散列表的应用"></a>散列表的应用</h2><h3 id="LRU淘汰缓存算法"><a href="#LRU淘汰缓存算法" class="headerlink" title="LRU淘汰缓存算法"></a>LRU淘汰缓存算法</h3><p>一个缓存（cache）系统主要包含下面这几个操作：</p><ul><li>往缓存中<strong>添加</strong>一个数据；</li><li>从缓存中<strong>删除</strong>一个数据；</li><li>在缓存中<strong>查找</strong>一个数据。</li></ul><p>维护一个按照访问时间从大到小有序排列的链表结构。因为缓存大小有限，当缓存空间不够，需要淘汰一个数据的时候，直接将链表<strong>头部</strong>的结点删除。</p><p>当要缓存某个数据的时候，先在链表中查找这个数据：</p><ul><li>如果没有找到，直接将数据放到链表的尾部；</li><li>如果找到了，把它移动到链表的尾部；</li><li>因为查找数据需要遍历链表，所以单纯用链表实现的 LRU 缓存淘汰算法的时间复杂很高，是 O(n)。</li></ul><p>如果将<strong>散列表</strong>和<strong>链表</strong>两种数据结构组合使用，可以将这三个操作的时间复杂度都降低到 O(1)。</p><p>pre和next组成<strong>双向链表</strong>，这个链表是按照缓存的时间由大到小，组成的一个<strong>缓存队列</strong>；</p><p>hnext（使用<strong>链表法</strong>解决冲突的<strong>散列表中的链表的next指针</strong>）的作用是，（当发生哈希冲突时）在链表中<strong>插入缓存数据</strong>时，用于<strong>哈希值相等的缓存数据的连接</strong>。</p><p><img src="LRU.PNG" srcset="/img/loading.gif" alt=""></p><p><strong>散列表和链表经常一块使用</strong>。散列表虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数<strong>打乱之后无规律存储</strong>的。</p><p>它<strong>无法支持按照某种顺序快速地遍历数据</strong>。如果希望按照<strong>顺序</strong>遍历散列表中的数据，需要将散列表中的数据拷贝到数组中，然后排序，再遍历。因为<strong>散列表是动态数据结构</strong>，不停地有数据的插入、删除，所以<strong>按序遍历散列表</strong>中的数据的时候，需要<strong>先排序，效率很低</strong>。为了解决这个问题，将散列表和链表（或者跳表）结合在一起使用。</p><h3 id="Word-拼写检查实现"><a href="#Word-拼写检查实现" class="headerlink" title="Word 拼写检查实现"></a>Word 拼写检查实现</h3><p>常用的英文单词有 20 万个左右，假设单词的平均长度是 10 个字母，平均一个单词占用 10 个字节的内存空间，那 20 万英文单词大约占 2MB 的存储空间，就算放大 10 倍也就是 20MB。</p><p>这个大小完全可以放在内存里面。所以<strong>可以用散列表来存储整个英文单词词典</strong>。当用户输入某个英文单词时，拿用户输入的单词<strong>去散列表中查找</strong>。如果查到，则说明拼写正确；如果没有查到，则说明拼写可能有误，给予提示。借助散列表这种数据结构，就可以轻松实现快速判断是否存在拼写错误。</p><h2 id="工业级散列表特性"><a href="#工业级散列表特性" class="headerlink" title="工业级散列表特性"></a>工业级散列表特性</h2><ul><li><p>支持快速的查询、插入、删除操作；</p></li><li><p>内存占用合理，不能浪费过多的内存空间；</p></li><li><p>性能稳定，极度情况下，散列表的性能也不会退化到无法接受的情况；</p></li></ul><h3 id="实现工业级散列表要点"><a href="#实现工业级散列表要点" class="headerlink" title="实现工业级散列表要点"></a>实现工业级散列表要点</h3><ul><li><p>设计一个合适的散列表；</p></li><li><p>定义装载因子的阈值，并且设计动态扩容策略；</p></li><li><p>选择合适的散列冲突解决方法；</p></li></ul><h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><ul><li><p>将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法；</p></li><li><p>通过原始数据映射之后得到的二进制值串就是哈希值；</p></li></ul><h2 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a>设计步骤</h2><ul><li><p>从哈希值不能反向导出原始数据；</p></li><li><p>堆输入数据非常敏感，哪怕原始数据只修改了一个bit，最后得到的哈希值也大不相同；</p></li><li><p>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；</p></li><li><p>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速计算出哈希值；</p></li></ul><h2 id="应用-7"><a href="#应用-7" class="headerlink" title="应用"></a>应用</h2><ul><li><p>安全加密</p></li><li><p>唯一标识</p></li><li><p>数据校验</p></li><li><p>散列函数</p></li><li><p>负载均衡</p></li><li><p>数据分片</p></li><li><p>分布式存储</p></li></ul><h1 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h1><ul><li><p>一种特殊的散列表；</p></li><li><p>通过数组下标来定位数据，访问效率非常高；</p></li><li><p>每个数字用一个二进制位来表示，数字范围不大的情况下，需要的内存空间非常节省；</p></li></ul><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p><img src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%89%E4%B8%AA%E6%8C%87%E6%A0%87.png" srcset="/img/loading.gif" alt=""></p><p><img src="%E4%B8%89%E7%A7%8D%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 常用集合</title>
    <link href="/2020/07/22/Java%20%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/"/>
    <url>/2020/07/22/Java%20%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p>文章主要归纳介绍 Java 的集合框架与设计结构。包括 Java 提供的主要集合类型（Collections 和 Map）及其对应的数据结构、算法，并考虑不同场景下的具体技术选择。</p><a id="more"></a><h2 id="Java-集合框架设计结构"><a href="#Java-集合框架设计结构" class="headerlink" title="Java 集合框架设计结构"></a>Java 集合框架设计结构</h2><p>Java中提供了丰富的集合接口和类，它们来自于java.util包。Java集合类型分为：Collection和Map，Collection子接口有：Set、Queue和List等接口。每一种集合接口定义和描述了一种数据结构。</p><p><strong>Collection 接口</strong>是所有集合的根，然后扩展开提供了三大类集合，分别是：</p><ul><li><strong>List</strong>，有序集合，提供方便的访问、插入、删除等操作；</li><li><strong>Set</strong>，不允许重复元素，不存在两个对象 equals 返回 true。在需要保证元素唯一性的场景下使用较多；</li><li><strong>Queue/Deque</strong>，除了集合的基本功能，它还支持先入先出FIFO或后入先出LIFO等约束行为。并发包中有BlockingQueue。</li></ul><p><strong>Map</strong>允许按照某个键来访问元素。Map集合由两个集合构成：键集合，值集合。键集合是Set类型，不能有重复的元素。值集合是Collection类型，可以有重复的元素。</p><p>每种集合的通用逻辑，都被抽象到相应的抽象类之中，比如 AbstractList 就集中了各种 List 操作的通用部分。这些集合不是完全孤立的，例如LinkedList 实现了 List 和 Deque。</p><p><img src="java_collection.png" srcset="/img/loading.gif" alt=""></p><p><img src="java_map.png" srcset="/img/loading.gif" alt=""></p><p><strong>注：</strong></p><ul><li>Iterator通用迭代器、ListIterator针对 List 特化的迭代器</li><li>Comparator比较器、Comparable 排序接口</li><li>Collections常用算法类、Arrays静态数组的排序、查找算法</li></ul><h2 id="Java-主要集合类型"><a href="#Java-主要集合类型" class="headerlink" title="Java 主要集合类型"></a>Java 主要集合类型</h2><p>重点关注常用的实现类，掌握对应的数据结构、算法，能够根据不同的场景，进行具体的技术选择。</p><p><img src="java_common_collection.png" srcset="/img/loading.gif" alt=""></p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Vector、ArrayList 和 LinkedList 实现了 List，是<strong>有序集合</strong>。都提供按照位置进行定位、添加或者删除的操作，提供迭代器以遍历其内容等。但因为具体的设计区别，在行为、性能、线程安全等方面，表现又有很大不同。</p><ul><li>Vector 是 Java 早期提供的<strong>线程安全的动态数组</strong>，内部使用<strong>对象数组</strong>来保存数据。如果不需要线程安全，并不建议选择，毕竟同步有额外开销。可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据；</li><li>ArrayList 的应用更加广泛，使用<strong>动态数组</strong>实现，<strong>不是线程安全</strong>的，所以性能要好很多。ArrayList 也可以根据需要调整容量，两者的调整逻辑有所区别，<strong>Vector 在扩容时会提高 1 倍，而 ArrayList 增加 50%；</strong></li><li>LinkedList 是 Java 提供的<strong>双向链表</strong>，不需要像上面两种那样调整容量，但是因为存在额外的前驱和后继节点指针，所以占用的内存比 ArrayList 多一些。任意位置的插入删除很方便，不支持随机取值，只能从一端开始遍历，直到找到查询的对象。它<strong>不是线程安全的。</strong></li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>HashSet、LinkedHashSet 和 TreeSet 实现了Set。特点是<strong>元素不重复</strong>，<strong>存取无序</strong>。</p><ul><li>HashSet 以 HashMap 为基础实现。利用<strong>哈希算法</strong>，理想情况下添加、删除、包含等操作的<strong>时间复杂度为常数</strong>，它不保证有序。</li><li>LinkedHashSet 内部构建了一个记录插入顺序的双向链表，因此提供了<strong>按照插入顺序进行遍历</strong>的能力，也保证常数时间的包含、添加、删除等操作，这些<strong>操作性能略低于 HashSet</strong>，因为需要维护链表的开销；</li><li>TreeSet 默认利用 TreeMap 实现。支持自然顺序访问，包含、添加、删除、等操作相对低效（log(n) ）；</li></ul><p>在遍历元素时，HashSet 性能受自身容量影响，所以初始化时，除非有必要，不然不要将其背后的 HashMap 容量设置过大。而对于 LinkedHashSet，由于其内部链表提供的方便，所以遍历性能只和元素多少有关系。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Hashtable、HashMap、TreeMap 是最常见的 Map 的实现，<strong>以键值对的形式存储和操作数据的集合类型。</strong></p><ul><li>Hashtable 是早期 Java 类库提供的一个哈希表实现，本身<strong>是同步的</strong>，<strong>不支持 null 键和值</strong>，由于同步导致的性能开销，所以已经<strong>很少被推荐使用</strong>；</li><li>HashMap 应用更加广泛，利用哈希表实现。<strong>HashMap 不是同步的，支持 null 键和值等</strong>。通常情况下HashMap 的 put 或 get 操作的时间复杂度为常数。所以它是<strong>绝大部分利用键值对存取场景的首选</strong>，比如，实现一个用户 ID 和用户信息对应的运行时存储结构；<ul><li>大部分使用 Map 的场景，通常就是<strong>放入、访问或者删除</strong>，对顺序没有特别要求，HashMap 在这种情况下基本是最好的选择。</li></ul></li><li>LinkedHashMap 继承于HashMap，是基于HashMap和双向链表来实现的。LinkedHashMap 是有序的，可分为插入顺序和访问顺序。如果是访问顺序，那put和get操作已存在的Entry时，都会<strong>把Entry移动到双向链表的表尾(</strong>其实是先删除再插入)，存取数据时和 HashMap 一样，使用 Entry[] 的方式，双向链表只是为了保证顺序。LinkedHashMap <strong>不是线程安全</strong>的；<ul><li>这种特点适用于一些特定应用场景，例如：构建一个空间占用敏感的资源池，可以自动将最不常被访问的对象释放。那么，表满时需要删除时候就是头部元素。</li></ul></li><li>TreeMap 是基于<strong>红黑树</strong>实现的一种按序访问的 Map，TreeMap能够把它保存的记录根据键进行排序，默认是按键值的升序排序，也可以指定排序的比较器，具体顺序可以由指定的 <strong>Comparator</strong> 决定。用 Iterator 遍历时，得到的记录是排过序的。它的 get、put、remove 操作的时间复杂度是 O(log(n))，所以TreeMap实际使用的比较少。<ul><li>TreeMap 和 LinkedHashMap 都可以保证某种顺序，但二者还是不同的。TreeMap 的整体顺序由键的顺序关系决定，即通过 Comparator 或 Comparable（自然顺序）决定。</li></ul></li></ul><h4 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h4><p>HashMap 的性能表现非常依赖于哈希值的有效性，需要掌握相关内容。</p><h5 id="Java中equals和-的区别"><a href="#Java中equals和-的区别" class="headerlink" title="Java中equals和==的区别"></a>Java中equals和==的区别</h5><ul><li>== 的作用：<ul><li>基本类型：比较的就是值是否相同；</li><li>引用类型：比较的就是地址值是否相同</li></ul></li><li>equals() 的作用：<ul><li>引用类型：默认情况下，比较的是地址值。但是一般来说，意义不大。所以，一些类库重写了这个方法，如String、Integer、Date。这些类当中 equals 有其自身的实现，一般是用来比较对象的成员变量值是否相同，而不再是比较类在堆内存中的存放地址了。</li></ul></li></ul><h5 id="hashCode（）与-equals（）的相关规定"><a href="#hashCode（）与-equals（）的相关规定" class="headerlink" title="hashCode（）与 equals（）的相关规定"></a>hashCode（）与 equals（）的相关规定</h5><ul><li>如果两个对象相等（equals 相等），那么 hashCode 一定相等；</li><li>两个对象相等，对两个对象分别调用 equals 方法都返回 true；</li><li>两个对象有相同的哈希值(hash code)，它们不一定相等；</li><li>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖，所以<strong>重写了 equals 也要重写 hashCode；</strong></li><li>equals 有对称、反射、传递等特性。</li></ul><h4 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h4><p>掌握HashMap 设计与实现的基本原理与方法，对深入理解集合和数据结构有一些帮助。</p><ul><li>HashMap 内部实现基本点分析;</li><li>容量（capacity）和负载系数（load factor）;</li><li>树化 。</li></ul><p>HashMap 内部的结构如下图，它可以看作是<strong>数组和链表结合组成</strong>的复合结构，数组被分为一个个<strong>桶</strong>，通过<strong>哈希值决定键值对在这个数组的寻址</strong>；<strong>哈希值相同的键值对，则以链表形式存储</strong>。需要注意的是，如果链表大小超过阈值（TREEIFY_THRESHOLD, 8），链表就会被改造为树形结构。</p><p><img src="hash_buckets.png" srcset="/img/loading.gif" alt=""></p><h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h5><p>putVal 方法逻辑比较集中，从初始化、扩容到树化都和它有关，阅读源码时需要多加关注。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><span class="hljs-function"><span class="hljs-params">               <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;    HashMap.Node&lt;K,V&gt;[] tab; HashMap.Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)        n = (tab = resize()).length;    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span>            treeifyBin(tab, hash);    &#125;    <span class="hljs-keyword">if</span> (++size &gt; threshold)        resize();&#125;</code></pre><ul><li><p>如果表格是 null，resize 方法会初始化它；</p></li><li><p>resize 方法兼顾两个职责，创建初始存储表格，或者在容量不满足需求的时候，进行扩容resize；</p></li><li><p>在放置新的键值对的过程中，如果++size &gt; threshold，就会发生扩容</p></li><li><p>具体键值对在哈希表中的位置（数组 index）取决于下面的位运算：</p><pre><code class="hljs java">i = (n - <span class="hljs-number">1</span>) &amp; hash</code></pre></li></ul><p>将高位数据移位到低位进行异或运算的原因是：有些数据计算出的哈希值差异主要在高位，而 HashMap 里的哈希寻址是忽略容量以上的高位的，这种处理可以有效避免类似情况下的哈希碰撞。</p><pre><code class="hljs processing"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> hash(<span class="hljs-keyword">Object</span> kye) &#123;    <span class="hljs-built_in">int</span> h;    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">key</span> == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = <span class="hljs-built_in">key</span>.hashCode()) ^ (h &gt;&gt;&gt;<span class="hljs-number">16</span>;&#125;</code></pre><h5 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h5><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;    Node&lt;K,V&gt;[] oldTab = table;    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;    <span class="hljs-keyword">int</span> oldThr = threshold;    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;            threshold = Integer.MAX_VALUE;            <span class="hljs-keyword">return</span> oldTab;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span>        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span>            newCap = oldThr;        <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span>            newCap = DEFAULT_INITIAL_CAPACITY;            newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);        &#125;        <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?                      (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);        &#125;        threshold = newThr;        <span class="hljs-meta">@SuppressWarnings</span>(&#123;<span class="hljs-string">"rawtypes"</span>,<span class="hljs-string">"unchecked"</span>&#125;)            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];        table = newTab;        <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// ....</span>    &#125;        <span class="hljs-keyword">return</span> newTab;</code></pre><ul><li>不考虑极端情况，容量理论最大极限由 MAXIMUM_CAPACITY 指定，数值为 1&lt;&lt;30，也就是 2 的 30 次方；</li><li>门限值 = 负载因子 x 容量，如果构建 HashMap 的时候没有指定，那么依据相应的默认常量值；</li><li>门限通常以倍数进行调整 （newThr = oldThr &lt;&lt; 1），当元素个数超过门限大小时，则调整 Map 大小；</li><li>扩容后，需要将老的数组中的元素重新放置到新的数组，这是扩容的一个主要开销来源。</li></ul><h5 id="容量、负载因子和树化"><a href="#容量、负载因子和树化" class="headerlink" title="容量、负载因子和树化"></a>容量、负载因子和树化</h5><p>容量和负载系数决定了可用的桶的数量：</p><ul><li>空桶太多会浪费空间；</li><li>可用空间较少则会严重影响操作的性能。<ul><li>极端情况下，假设只有一个桶，就退化成了链表，操作的时间复杂度不能保证。</li></ul></li></ul><p>对于<strong>容量</strong>，如果能够知道 HashMap 要存取的键值对数量，可以考虑预先设置合适的容量大小。需要满足：</p><ul><li>负载因子 * 容量 &gt; 元素数量，所以预先设置的容量需要大于 “预估元素数量 / 负载因子”；</li><li>是 2 的幂数；</li></ul><p>对于<strong>负载因子</strong>：</p><ul><li>如果没有特别需求，不要轻易进行更改，因为 JDK 自身的默认负载因子是非常符合通用场景的需求的；</li><li>如果确实需要调整，建议不要设置超过 0.75 的数值，因为会显著增加冲突，降低 HashMap 的性能；</li><li>如果使用太小的负载因子，按照上面的公式，可能会导致频繁的扩容，增加无谓的开销，本身访问性能也会受影响。</li></ul><p><strong>树化</strong>的原因是主要是，在元素放置过程中，如果哈希冲突频繁发生，元素都被放置到同一个桶里，会形成一个比较长的链表，而链表查找的时间复杂度是线性的，严重影响存取性能。树化对应的逻辑主要在 putVal 和 treeifyBin方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> hash)</span> </span>&#123;    <span class="hljs-keyword">int</span> n, index; Node&lt;K,V&gt; e;    <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)        resize();    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">//树化改造逻辑</span>    &#125;&#125;</code></pre><p>结合putVal 和 treeifyBin 这两个方法，可以看到，当 binCount 大于 TREEIFY_THRESHOLD 时：</p><ul><li>如果容量小于 MIN_TREEIFY_CAPACITY，只会进行简单的扩容；</li><li>如果容量大于 MIN_TREEIFY_CAPACITY ，则会进行树化改造。</li></ul><pre><code class="hljs html">static final int TREEIFY_THRESHOLD = 8;static final int UNTREEIFY_THRESHOLD = 6;</code></pre><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>java.util.Collections工具类为集合框架提供了很多有用的方法，这些方法都是静态的，在编程中可以直接调用。</p><h3 id="默认排序算法"><a href="#默认排序算法" class="headerlink" title="默认排序算法"></a>默认排序算法</h3><p>理解 Java 提供的默认排序算法的排序方式以及设计思路：需要区分是 Arrays.sort() 还是 Collections.sort()。对于小数据集，会直接进行二分插入排序。</p><ul><li>Arrays.sort() 对<strong>原始数据类型的数组</strong>，默认升序排序。如果要实现降序排列，需要借助比较器Comparator。</li><li>对于<strong>原始数据类型</strong>，目前使用的是所谓<strong>双轴快速排序</strong>（Dual-Pivot QuickSort），是一种改进的快速排序算法，早期版本是相对传统的快速排序；</li><li>Collections.sort() 对<strong>对象数据类型的List</strong> 进行排序。</li><li>对于<strong>对象数据类型</strong>，目前则是使用<strong>TimSort</strong>，思想上也是一种<strong>归并和二分插入排序</strong>结合的优化排序算法。TimSort 的思路是<strong>查找数据集中已经排好序的分区</strong>，然后<strong>合并这些分区</strong>，达到排序的目的。</li></ul><p>另外，Java 8 引入了<strong>并行排序算法</strong>（直接使用 parallelSort 方法），这是为了充分利用现代多核处理器的计算能力，底层实现基于 fork-join 框架，当处理的数据集比较小的时候，差距不明显，甚至还表现差一点；但是，当数据集增长到数万或百万以上时，提高就非常大了，具体还是取决于处理器和系统环境。</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p><strong>问：</strong>思考一个应用场景，实现一个云计算任务调度系统，可以保证 VIP 客户的任务被优先处理，可以利用哪些数据结构或者标准的集合类型呢？更进一步讲，类似场景大多是基于什么数据结构呢？</p><p><strong>答：</strong>由于任务有前后顺序关系，所以考虑使用<strong>优先级队列</strong>，如PriorityQueue、PriorityBlockingQueue。将VIP用户的优先级设置为最高，优先处理。借鉴操作系统中的调度算法，还可以设计各种公平的优先级选择算法（基于<strong>排队先后顺序、调度任务所需的时间长短</strong>进行排序），与 PriorityQueue 结合使用。</p><p><strong>消息队列</strong>可以对用户请求进行削锋，前台快速响应，后台后续进行处理操作。其他的优化有：利用分布式系统的优点，将VIP用户的请求分发到算力更高的服务器上处理。达到高可用的目的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Java 编程思想</p><p>Java 核心卷</p><p><a href="<https://time.geekbang.org/column/intro/100006701>/">极客时间 - Java精讲</a></p><p><a href="http://c.biancheng.net/java/" target="_blank" rel="noopener">C语言中文网 - Java教程</a></p><p><a href="http://www.justdojava.com/2019/09/16/java-collection-1/" target="_blank" rel="noopener">集合系列 - 初探 java 集合框架图</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Collection</tag>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统基础</title>
    <link href="/2020/07/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>文章介绍计算机操作系统基础。</p><a id="more"></a><h1 id="概念基础"><a href="#概念基础" class="headerlink" title="概念基础"></a>概念基础</h1><h2 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h2><p>操作系统是管理系统资源、控制程序执行、改善人机界面、提供各种服务，并合理组织计算机工作流程和为用户方便而有效地使用计算机提供良好运行环境的最基本的系统软件。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用是一种中介角色，把用户和硬件隔离开来，应用程序只有通过系统调用才可以请求系统服务并使用系统资源。系统调用的作用：</p><ul><li>内核可以基于权限和规则对资源访问进行裁决，保证系统的安全性；</li><li>系统调用对资源进行抽象，提供一致性接口，避免用户在使用资源时发生错误，且使编程效率提高；</li></ul><p>当 CPU 执行程序中预设的由访管指令实现的系统调用时，会产生异常信号，通过中断机制，处理器的状态由用户态转变为核心态，进入操作系统并执行相应的内核函数，以获得操作系统服务；当系统调用执行完毕时，控制返回至发出系统调用的程序，系统调用是应用程序获得操作系统服务的唯一途径。</p><p>内核是一组程序模块，作为可信软件来提供支持进程并发的基本功能和基本操作，通常驻留在内存空间，运行于核心态，具有访问硬件设备和所有主存空间的权限，是仅有的能够执行特权指令的程序。有了内核的支撑，机器功能得到扩展，进程运行环境得到改善，安全性得到保证，系统效率得到提高。</p><h2 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h2><p>fork() 是 UNIX 或类UNIX 中的分叉函数，fork 函数将运行着的程序分成2个（几乎）完全一样的进程，每个进程都启动一个从代码的同一位置开始执行的线程。这两个进程中的线程继续执行，就像是两个用户同时启动了该应用程序的两个副本。</p><p>fork 系统调用用于创建一个新进程，称为子进程，它与进程（称为系统调用fork的进程）同时运行，此进程称为父进程。创建新的子进程后，两个进程将执行 fork() 系统调用之后的下一条指令。子进程使用相同的PC（程序计数器），相同的CPU寄存器，在父进程中使用的相同打开文件。</p><p>由于在复制时复制了父进程的堆栈段，所以两个进程都停留在fork函数中，等待返回。因此fork函数会返回两次，一次是在父进程中返回，另一次是在子进程中返回，这两次的返回值是不一样的。</p><pre><code class="hljs c"><span class="hljs-comment">//一次调用两次返回值，是在各自的地址空间返回，意味着现在有两个基本一样的进程在执行, 无参数。</span><span class="hljs-function"><span class="hljs-keyword">pid_t</span> <span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;</code></pre><p>fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：</p><ul><li>如果成功创建一个子进程，对于父进程来说返回子进程ID；</li><li>如果成功创建一个子进程，对于子进程来说返回值为0；</li><li>如果为-1表示创建失败；</li></ul><p>fork 如何知道一个进程是父进程还是子进程：这涉及到 fork 本身的功能，它的作用是克隆进程，也就是将原先的一个进程再克隆出一个来，克隆出的这个进程就是原进程的子进程，这个子进程和其他的进程没有什么区别，同样拥有自己的独立的地址空间。不同的是子进程是在fork返回之后才开始执行的，就像一把叉子一样，执行 fork 之后，父子进程就分道扬镳了，所以 fork 这个名字就很形象，叉子的意思。</p><h3 id="孤儿进程和僵尸进程"><a href="#孤儿进程和僵尸进程" class="headerlink" title="孤儿进程和僵尸进程"></a>孤儿进程和僵尸进程</h3><p>在UNIX/Linux中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程无法预测子进程什么时候结束。当一个 进程完成它的工作终止之后，它的父进程需要调用 wait() 或者 waitpid() 系统调用取得子进程的终止状态。</p><h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><p><strong>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程</strong>。孤儿进程将被 init 进程(进程号为1)收养，并由 init 进程对它们完成状态收集工作。孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了 init 进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。<strong>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init，而 init 进程会循环地 wait() 它的已经退出的子进程。</strong>这样，当一个孤儿进程结束其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。<strong>因此孤儿进程并不会有什么危害。</strong></p><h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><p><strong>一个进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程</strong>。UNIX 提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息，就可以得到。这种机制就是：在每个进程退出的时候，内核释放该进程所有的资源,包括打开的文件,占用的内存等。但是仍然为其保留一定的信息(包括进程号，退出状态，运行时间等)。直到父进程通过wait / waitpid 来取时才释放。但这样就导致了问题，如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其<strong>进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。</strong></p><h1 id="处理器管理"><a href="#处理器管理" class="headerlink" title="处理器管理"></a>处理器管理</h1><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p><strong>中断是指在程序执行过程中，遇到急需处理的事件时，暂时中止现行程序在CPU上的运行，转而执行相应的事件处理程序，待处理完成后在返回断点或调度其他程序执行。</strong>例如，从磁带上读入一组信息，当发现读入操作有误时，将产生读数据中断，操作系统停止当前的工作，并组织磁带退回重读这一组信息，这样就有可能克服错误。</p><h3 id="强迫性中断和自愿性中断"><a href="#强迫性中断和自愿性中断" class="headerlink" title="强迫性中断和自愿性中断"></a>强迫性中断和自愿性中断</h3><p>按中断事件的性质和激活方式可将中断分成两类：强迫性中断和自愿性中断。</p><ul><li>强迫性中断不是正在运行的程序所期待的，是由随机事件或外部请求信息引起的。强迫性中断事件有以下几种：<ul><li>机器故障中断：机器执行指令过程中硬件可能出现种种事件，例如，电源故障、通路校验错误、主存出错等；</li><li>程序性中断：程序执行过程中可能发生种种例外情况，例如：非操作码错误、定点溢出、除数为0、地址越界；</li><li>外部中断：由计算机系统外部发送中断信号，反映外界对本机的种种要求，例如，时钟中断、控制台中断、它机中断等；</li><li>输入输出中断：来自通道、控制器、设备的中断能够反应I/O操作情况，例如：设备出错、传输结束、启动失败等；</li></ul></li><li>自愿性中断事件是正在运行的程序所期待的，是由于执行“访管指令”而引起的，它表示运行程序对操作系统由某种需求，一旦机器执行访管指令，就会使CPU状态从用户态转向核心态，停止现行程序的执行而转入内核的相应系统调用例程进行处理。例如：要求操作系统协助启动外部设备工作。</li></ul><h3 id="硬中断和软中断"><a href="#硬中断和软中断" class="headerlink" title="硬中断和软中断"></a>硬中断和软中断</h3><p>按中断事件的来源和实现手段划分可以将中断划分为硬中断和软中断。</p><ul><li>硬中断可划分为外中断和内中断：<ul><li>外中断又称中断或异步中断，是指来自处理器之外的信号，包括时钟中断、键盘中断、它机中断和设备中断等。外中断又分为可屏蔽中断和不可屏蔽中断，各个中断具有不同的中断优先级，表示事件的紧急程度，在处理高一级中断时，往往会部分或全部屏蔽低级中断；</li><li>内中断又称异常或同步中断，是指来自处理器内部的中断信号，通常是由于在程序执行过程中，发现与当前指令关联的、不正常的或错误的事件。</li></ul></li><li>软中断：外中断和内中断（中断和异常）要通过硬件设施来产生中断请求，他们都是硬中断。与其对应的，不必由硬件产生中断源而引发的中断称为软中断。软中断利用硬中断中的概念，采用软件方法对中断机制进行模拟，实现宏观上的异步执行。软中断可分为两种：<ul><li>“信号”是一种软中断机制，信号的发送者相当于中断源，而信号的接收者必然是一个进程（相当于CPU）；</li><li>“软件中断”是另一种软件中断机制，其第一个典型应用的例子是 Linux 中的 bottom half，它的升级就是Linux中最复杂、最庞大的软中断子系统 softirq 机制；第二个典型应用例子是 Windows 中由内核发出的Dispatch/DPC 和 APC 等中断，用于启动线程调度。延迟过程调用和异步过程调用的执行；</li></ul></li></ul><h4 id="硬中断和软中断的类比"><a href="#硬中断和软中断的类比" class="headerlink" title="硬中断和软中断的类比"></a>硬中断和软中断的类比</h4><p>“中断”（硬中断）：用于外部设备对CPU的中断（中断正在运行的任何程序），转向中断处理程序执行；</p><p>“异常”（硬中断）：因指令执行不正常而中断CPU（中断正在执行这条指令的程序），转向异常处理程序执行；</p><p>“软件中断”（软中断）：用于硬中断服务程序对内核的中断，在上半部分中发出软件中断（即标记下半部分），使得中断下半部分在适当时刻获得处理；</p><p>“信号”（软中断）：用于内核或进程对某个进程的中断，向进程通知某个特定事件发生或迫使进程执行信号处理程序。</p><h3 id="中断-异常的过程："><a href="#中断-异常的过程：" class="headerlink" title="中断/异常的过程："></a>中断/异常的过程：</h3><ol><li>发现中断源：在中断未被屏蔽的前提下，硬件发现中断/异常事件，并由CPU相应中断/异常请求。当发生多个中断源时，将根据预定的优先级先后相应中断请求；</li><li>保护现场：暂停当前程序的运行，硬件将中断点的现场信息（PSW）保存至核心栈，使得中断处理程序/异常处理程序在运行时，不会破坏中断程序中的有用信息，以便在中断结束后返回源程序继续运行；</li><li>转向中断/异常事件的处理程序：这时处理器状态已从用户态切换至核心态，中断处理程序/异常处理程序开始工作；</li><li>恢复现场：当中断处理结束后，恢复PSW，重新返回中断点以便执行后续指令。</li></ol><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程定义"><a href="#进程定义" class="headerlink" title="进程定义"></a>进程定义</h3><p>进程是操作系统中最基本、最重要的概念，是在多道程序系统出现后，为了刻画系统内部的动态状况、描述运行程序的活动规律而引进的新概念，所有多道程序设计操作系统都建立在进程的基础上。</p><p>从理论的角度看，进程的概念是对当前运行程序的活动规律的抽象；从实现角度看，进程是一种数据结构，用来准确刻画系统动态变化的内在规律，有效地管理和调度在计算机系统主存运行的程序。</p><p>引入进程的目的，一是为了刻画系统的动态性，发挥系统的并发性；二是解决共享性，正确地描述程序的执行状态。</p><p>所以，进程的定义如下：<strong>进程是可并发执行的程序在某个数据集合上的一次计算活动，也是操作系统进行资源分配和保护的基本单位。</strong></p><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>三态模型：</p><ul><li>运行态：进程占用处理器运行的状态；</li><li>就绪态：进行具备运行条件，等待系统分配处理器以便其运行的状态；</li><li>等待态：又称阻塞态或睡眠态，指系统不具备运行条件，正在等待某个事件完成的状态；</li></ul><p>五态模型：</p><p>在很多系统中，增加两个进程状态，新建态和终止态</p><p>新建态：进程被创建时的状态，进程尚未进入就绪状态。创建进程要通过两个步骤，首先，为进程分配所需的资源，建立必要的管理信息，然后，置此进程为就绪态，等待被执行；</p><p>终止态：进程完成任务，到达正常结束点，或因出现无法克服的错误而异常终止，或被操作系统及有终止权限的进程所终止时所处的状态；</p><h3 id="处理器调度算法"><a href="#处理器调度算法" class="headerlink" title="处理器调度算法"></a>处理器调度算法</h3><h4 id="先来先服务（FCFS）"><a href="#先来先服务（FCFS）" class="headerlink" title="先来先服务（FCFS）"></a>先来先服务（FCFS）</h4><ul><li>按作业进入系统后背作业队列的先后次序来挑选作业，先进入系统的作业将优先被挑选进入主存，创建用户进程，分配所需资源，然后移入就绪队列；</li><li>非剥夺式调度算法；</li><li>只顾作业的等待时间，未考虑作业要求服务时间的长短，不利于短作业而优待长作业，不利于I/O繁忙型作业而有利于CPU繁忙型作业；</li><li>FCFS算法同样适用于进程/线程调度，每次从就绪队列中选择最先进入此队列的进程/线程，它一直运行，直至完成或出现等待事件而被阻塞而让出处理器为止；</li></ul><p>需要说明的是，在进行处理器调度时，允许作业调度和进程/线程调度分别采用不同的调度算法，而且往往需要采用不同的调度算法处理这两级调度。</p><h4 id="最短作业优先（SJF）"><a href="#最短作业优先（SJF）" class="headerlink" title="最短作业优先（SJF）"></a>最短作业优先（SJF）</h4><ul><li>以进入系统的作业所要求的CPU运行时间的长短为标准，总是选取预计计算时间最短的作业投入运行；</li><li>非剥夺式调度算法；</li><li>需要预先直到作业所需的CPU运行时间，很难精确估算；忽视作业的等待时间，进入系统时间早但计算时间长的长作业有可能出现饥饿现象；</li><li>SJF也可以用于低级调度，借用作业的估计运行时间作为进程/线程的估计运行时间，调度时从就绪队列中选择一个估计运行时间最短者投入运行。若具有相同的估计运行时间，就对其按照FCFS算法处理；</li></ul><h4 id="最短剩余时间"><a href="#最短剩余时间" class="headerlink" title="最短剩余时间"></a>最短剩余时间</h4><ul><li><p>上面的最短作业优先算法是非剥夺式，可将其改造为剥夺式调度算法；</p></li><li><p>假设当前某进程/线程正在运行，如果有新进程/线程移入就绪队列，若它的所需的CPU运行时间比当前运行进程/线程所需的剩余CPU时间还短，抢占式最短作业优先算法强行剥夺当前执行者的控制权，调度新进程/线程执行，这叫做最短剩余时间优先算法；</p></li></ul><h4 id="响应比最高优先"><a href="#响应比最高优先" class="headerlink" title="响应比最高优先"></a>响应比最高优先</h4><ul><li>响应比最高优先是介于FCFS和SJF算法之间的一种折衷的<strong>非剥夺式算法</strong>，即考虑作业的等待时间，又考虑作业的处理时间，这样既照顾短作业又不会使长作业等待时间过长；</li><li>缺点是每次计算各道作业的响应比会导致一定的时间开销，其性能比SJF略差。等待时间与处理时间之和是系统对作业的响时间，它与处理时间的比值称为响应比。</li></ul><h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><ul><li>根据确定的优先级来选取进程/线程，总是选择就绪队列中的优先级最高者投入运行；</li><li>系统可以预先规定策略：剥夺式与非剥夺式；</li><li>进程/线程的优先级的确定可采用静态式/动态式，基本原则是：正在运行的进程/线程随着占用CPU的时间的增加，逐渐降低其优先级；就绪队列中等待CPU的进程/线程随着等待时间的增加，逐渐提高其优先级，这样可以克服静态优先级饥饿的问题。</li></ul><h4 id="轮转调度"><a href="#轮转调度" class="headerlink" title="轮转调度"></a>轮转调度</h4><ul><li>也称时间片调度算法。调度程序每次把CPU分配给就绪队列队首进程/线程使用规定的时间间隔，称为时间片。就绪队列中每个进程/线程轮流地运行一个时间片，当时间片耗尽，就强迫当前运行的进程/线程让出处理器，转而排列到就绪队列的尾部，等待下一轮调度；</li><li>剥夺式调度；</li><li>系统耗费在进程/线程切换上的开销比较大，这个开销与时间片取值有关；</li></ul><h4 id="多级反馈队列调度"><a href="#多级反馈队列调度" class="headerlink" title="多级反馈队列调度"></a>多级反馈队列调度</h4><ul><li>操作系统建立一个多个就绪队列，每个队列对应一个优先级，第一个队列的优先级最高，其后的队列的优先级逐渐降低；</li><li>较高优先级队列的进程/线程分配给较短的时间片，较低优先级队列的进程/线程分配给较长的时间片，最后一个队列进程/线程按FCFS算法进行调度；</li><li>处理器调度每次先从第一个队列选取执行者，同一队列中的进程/线程按照FCFS原则排队，只有在未选到时，才从较低一级的就绪队列中选取，仅当前面所有队列为空时，才会运行最后一个就绪队列中的进程/线程；</li></ul><h1 id="同步、通信与死锁"><a href="#同步、通信与死锁" class="headerlink" title="同步、通信与死锁"></a>同步、通信与死锁</h1><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程间通信主要包括管道、系统 IPC（包括消息队列、信号量、信号、共享内存等） 、以及套接字 socket。</p><ul><li><p>管道</p><p>管道主要包括无名管道和命名管道：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</p><ul><li>普通管道 PIPE：<ul><li>它是<strong>半双工的</strong>（即数据只能在一个方向上流动），具有固定的读端和写端；</li><li>它只能用于<strong>具有亲缘关系的进程之间的通信</strong>（也是父子进程或者兄弟进程之间）；</li><li>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中；</li></ul></li><li>命名管道 FIFO：<ul><li>FIFO 可以<strong>在无关的进程之间交换数据</strong>；</li><li>FIFO 有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</li></ul></li></ul></li><li><p>系统 IPC</p><ul><li>消息队列<ul><li>消息队列，是消息的链接表，存放在内核中。 一个消息队列由一个标识符（即队列 ID）来标记。<strong>消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点</strong>。具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</li><li>特点<ul><li>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级；</li><li>消息队列独立于发送与接收进程。 进程终止时，消息队列及其内容并不会被删除；</li><li>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取；</li></ul></li></ul></li><li>信号量 semaphore<ul><li>信号量（semaphore） 与已经介绍过的 IPC 结构不同，<strong>它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步</strong>，而不是用于存储进程间通信数据；</li><li>特点<ul><li>信号量用于进程间同步，若要在进程间传递数据需要结合共享内存；</li><li>信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作；</li><li>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数；</li><li>支持信号量组；</li></ul></li></ul></li><li>信号 signal<ul><li>信号是一种比较复杂的通信方式，<strong>用于通知接收进程某个事件已经发生</strong>；</li></ul></li><li>共享内存 Shared Memory<ul><li>它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。 这种方式需要依靠某种同步操作，如互斥锁和信号量等</li><li>特点<ul><li>共享内存是<strong>最快的一种 IPC</strong>，因为进程是直接对内存进行存取；</li><li>因为多个进程可以同时操作，所以需要进行同步；</li><li>信号量 + 共享内存通常结合在一起使用，信号量用来同步对共享内存的访问；</li></ul></li></ul></li><li>套接字 SOCKET<ul><li>与其他通信机制不同的是， SOCKET 可用于<strong>不同主机之间的进程通信</strong>；</li></ul></li></ul></li></ul><h2 id="线程间通信与同步"><a href="#线程间通信与同步" class="headerlink" title="线程间通信与同步"></a>线程间通信与同步</h2><ul><li><p>临界区：通过<strong>多线程的串行化来访问公共资源或一段代码</strong>，速度快，适合控制数据访问；</p></li><li><p>互斥量 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。<strong>因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</strong>；</p></li><li><p>信号量 Semphare：为控制具有有限数量的用户资源而设计的，它<strong>允许多个线程在同一时刻去访问同一个资源</strong>，但一般需要限制同一时刻访问此资源的最大线程数目；</p></li><li><p>事件(信号) Wait/Notify：<strong>通过通知操作的方式来保持多线程同步</strong>，还可以方便的实现多线程优先级的比较操作；</p></li></ul><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程非常类似于线程。但是<strong>协程是协作式多任务的</strong>，而<strong>线程是抢占式多任务的</strong>。这意味着协程提供并发性而非并行性。</p><p>协程超过线程的好处是它们可以用于硬性实时的语境（<strong>在协程之间的切换不需要涉及任何系统调用或任何阻塞调用</strong>），这里不需要用来守卫关键区块的同步性原语（primitive）比如互斥锁、信号量等，并且不需要来自操作系统的支持。</p><p>有可能以一种对调用代码透明的方式，使用抢占式调度的线程实现协程，但是会失去某些利益，特别是对硬性实时操作的适合性和相对廉价的相互之间切换。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁产生"><a href="#死锁产生" class="headerlink" title="死锁产生"></a>死锁产生</h3><ul><li><p>互斥条件：系统中存在临界资源，进程应互斥地使用这些资源；</p></li><li><p>占有和等待条件：进程在请求资源得不到满足而等待时，不释放已占有的资源；</p></li><li><p>不剥夺条件：已被占用的资源只能由属主释放，不允许被其他进程剥夺；</p></li><li><p>循环等待条件：存在循环等待链，其中，每个进程都在链中等待下一个进程所持有的资源，造成这组进程处于永远等待状态；</p></li></ul><p>前三个条件是死锁存在的必要条件，但不是充分条件，第4个条件是前3个条件同时存在时所产生的结果，故条件并不完全独立。但是，单独考虑每个条件是有用的，只要能破坏4个必要条件中的一个，就可以防止死锁。</p><p>解决死锁问题有三种策略和方法：死锁防止、死锁避免、死锁检测和解除。</p><h3 id="死锁防止"><a href="#死锁防止" class="headerlink" title="死锁防止"></a>死锁防止</h3><p>死锁的防止是指系统预先确定资源分配策略，进程按此规定来申请和使用资源，<strong>保证死锁有一个必要条件不会被满足，使得系统不发生死锁</strong>；其缺点是降低系统的并发性质，资源利用率低。</p><h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>死锁避免允许系统中同时存在前3个必要条件，通过合适的资源分配算法确保不会出现进程循环等待链，从而避免死锁。</p><p>死锁避免方法能支持更多的进程并发执行，它不是对进程随意强加规则，而是动态地确定是否分配资源给提出请求的进程。如果一个进程当前请求的资源会导致死锁，系统将拒绝启动该进程；如果一个资源的分配会导致下一步死锁，系统会拒绝本次分配。</p><p>银行家算法是的死锁避免算法，但缺乏实用价值。</p><h3 id="死锁检测与恢复"><a href="#死锁检测与恢复" class="headerlink" title="死锁检测与恢复"></a>死锁检测与恢复</h3><p>对资源的分配加以适当的限制可防止和避免死锁的发生，但是不利于进程对系统资源的充分共享。解决死锁的另一条路径是死锁检测和解除，这种方法对资源的分配不施加任何限制，也不采取死锁避免措施，系统定时地运行死锁检测程序，判断是否已经出现死锁，如果检测到系统已死锁，再采取措施解除它。</p><p>这种方法的难点在于：要确定何时运行死锁检测算法，如果这一算法执行的很频繁，将会浪费处理器时间；如果执行太稀疏，则死锁进程和系统资源会一直被锁定。</p><h1 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h1><p>存储管理是操作系统的重要组成部分，负责管理计算机系统的重要资源-主存储器。由于任何程序和数据必须占用主存空间才能得以执行和处理，因此，存储管理的优劣直接影响操作系统的性能。主存储器对数据的存取比处理器处理数据的速度慢得多，通过高速缓存可以部分缩小差距，但高效的主存管理仍然是操作系统设计中重要课题。</p><p>主存空间一般分为两部分：一部分是<strong>系统区</strong>，用于存放操作系统内核程序和数据结构等，另一部分是<strong>用户区</strong>，用于存放应用程序和数据。存储管理对核心区和用户区都提供相应的支持和管理。尽管现代计算机的主存容量不断增大，但仍不能保证有足够大的空间支持大型应用和系统程序及数据的使用。操作系统的主要任务之一是尽可能方便用户使用和提高主存利用率。存储管理的主要作用如下：</p><ul><li><p>分配和去配：进程可请求对主存区的独占式使用，主存区的请求和释放即主存空间的分配和去配操作由存储管理完成；</p></li><li><p>抽象和映射：主存储器被抽象，使得进程认为分配给他的地址空间是一个大且连续地址所组成的数组，或者把主存储器抽象成二维地址空间，以支持模块化程序设计；同时建立抽象机制支持进程用逻辑地址来映射到物理主存单元，实现地址转换；</p></li><li><p>隔离和共享：系统负责隔离已分配给进程的主存区，互不干扰免遭破坏，确保进程对存储单元的独占式使用，以实现存储保护功能；系统允许多个进程共享存储区，在这种情况下，超越隔离机制并授权进程允许共享访问，达到既能提高主存利用率又能共享主存某区内信息的目的；</p></li><li><p>主存扩容：物理主存容量不应限制应用程序的大小，主存和辅助存储器被抽象为虚拟主存，允许用户的虚拟地址空间大于主存物理地址空间，存储管理自动在不同的存储层次中移动信息；</p></li></ul><h2 id="连续存储管理"><a href="#连续存储管理" class="headerlink" title="连续存储管理"></a>连续存储管理</h2><h3 id="固定分区存储管理"><a href="#固定分区存储管理" class="headerlink" title="固定分区存储管理"></a>固定分区存储管理</h3><p>固定分区存储管理的基本思想是：主存空间被划分成数目固定不变的分区，各分区的大小不等，每个分区只装入一个作业，若多个分区中都装有作业，则它们可以并发执行，这是支持多道程序设计的最简单的存储管理技术。</p><h2 id="地址转换与存储保护"><a href="#地址转换与存储保护" class="headerlink" title="地址转换与存储保护"></a>地址转换与存储保护</h2><p>磁盘中的装载代码模块所使用的是<strong>逻辑地址</strong>，其逻辑地址集合称为进程的逻辑地址空间。逻辑地址可以是一维的，这时逻辑地址限制在从0开始的顺序排列的地址空间内；逻辑地址空间也可以是二维的，这是整个程序被分为若干段，每段都有不同的编号，段内地址从0开始顺序编址。</p><p>物理主存储器从统一的基地址开始顺序编址的存储单元称为<strong>物理地址或绝对地址</strong>，物理地址的总体构成物理地址空间。需要注意的是，物理地址空间是由存储器地址总线扫描出来的空间，其大小取决于实际安装的主存容量。</p><p>把逻辑地址转化为物理地址的过程称为<strong>地址重定位</strong>、地址映射或地址转换。与静态地址重定位相比，<strong>动态地址重定位具有允许程序在主存中移动、便于程序共享和主存利用率高等优点。</strong></p><h2 id="可变分区存储管理"><a href="#可变分区存储管理" class="headerlink" title="可变分区存储管理"></a>可变分区存储管理</h2><p>常用的可变分区分配算法有以下五种：</p><ul><li>最先适应分配算法：最先适应分配算法顺序查找未分配区表或链表，直至找到第一个能满足长度要求的空闲分区为止，分割此分区，一部分分配给作业，另一部分仍为空闲区（若有）；</li><li>下次适应分配算法：下次适应分配算法总是从未分配区的上一次扫描结束处顺序查找未分配区表或链表，直至找到<strong>第一个能满足长度要求的空闲区为止</strong>。这是最先适应分配算法的变种，<strong>能缩短平均查找时间，且存储空间利用率更加均衡，不会导致小空闲区集中于主存储器的一端</strong>；</li><li>最优适应分配算法：最优适应分配算法扫描整个未分配区表或链表，<strong>从空闲区挑选一个能满足用户进程要求的最小的分区进行分配</strong>。此算法保证不会分割更大的区域，使得装入<strong>大作业的要求容易得到满足</strong>。同时，通常把空闲区按长度递增顺序排列，查找时总是从最小的一个空闲区开始，直至找到满足要求的分区为止，此时最优适应分配算法等同于最先适应分配算法。此算法主存利用率好，所找出的分区如果正好满足要求则是最合适的。<strong>如果比所要求的分区略大则分割后使剩下的空闲分很小，难以利用，其查找时间也是最长的</strong>；</li><li>最坏适应分配算法：最坏适应分配算法扫描整个未分配区表或链表，<strong>总是挑选一个最大的空闲区分割给作业使用，其优点是使剩下二点空闲区不至过小，对中小型作业有利</strong>。采用此分配算法可把空闲区按照长度递减顺序排列，查找时只需看第一个分区能否满足进程需求，这样使最坏适应分配算法的查找效率很高，此时，最坏适应分配算法等同于最先适应分配算法；</li><li>快速适应分配算法：快速适应分配算法为那些<strong>经常用到的长度的空闲区设立单独的空闲区链表</strong>；</li></ul><h2 id="分页存储管理"><a href="#分页存储管理" class="headerlink" title="分页存储管理"></a>分页存储管理</h2><p>用分区方式管理存储器，每道程序要求占用主存的一个或多个连续存储区域，<strong>导致主存中产生“碎片”</strong>。有时为了接纳新作业，<strong>往往需要移动已在主存的信息</strong>，这样不仅不方便，而处理器的开销太大。</p><p><strong>采用分页存储管理允许程序存放到若干不相邻的空闲块中，既可免除移动信息工作，又可以充分利用主存空间，消除动态分区法中的”碎片“问题，从而提高主存空间的利用率。</strong></p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>页面：进程逻辑地址空间划分成大小相等的区，每个区称为页面或页，页号从0开始依次编号；</p><p>页框：页框又称页帧，把主存物理地址空间分成大小相等的区，其大小与页面大小相等，每个区是一个物理块或页框，块号从0开始依次编号；</p><p>逻辑地址：分页存储器的逻辑地址由两部分组成，页号和页内偏移，格式为：页号 页内偏移；</p><p><strong>页号表示地址所在页面的编号</strong>，后面部分表示页内偏移。计算机地址总线通常是32位，页面尺寸若规定为12位（页长 4KB），那么，页号共20位，表示地址空间最多包含2^20个页面。</p><p>采用分页存储管理时，逻辑地址是连续的，用户在编制程序时仍使用相对地址，不必考虑如何分页，由硬件地址转换机构和操作系统的管理来决定页面尺寸，从而确定主存分块大小。<strong>进程在主存中的每个页框内的地址是连续的，但页框之间的地址可以不连续</strong>，<strong>进程主存地址由连续到离散的变化为虚拟存储器的实现奠定了基础。</strong></p><p>页表：使用<strong>动态地重定位技术</strong>，让程序在执行时动态地进行地址变换，由于程序以页面为单位进行存储，所以为<strong>每个页面设立一个重定位寄存器，这些重定位寄存器地集合称为页表</strong>。页表是操作系统为进程建立的，是程序页面和主存对应页框的对照表，页表中的每一栏指明程序中的一个页面和分得页框的对应关系。<strong>使用页表的目的是把页面映射为页框。</strong></p><h4 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h4><p>页表可存放在一组寄存器中，地址转换时只要从相应寄存器中取值就可以得到页框号，这样做虽然能加快地址转换，但硬件代价太高；页表也可以放在主存中，这样做可以降低系统开销，但是<strong>按照给定逻辑地址进行读写操作时，至少访问主存两次：一次访问页表，另一次根据物理地址访问指令或存取数据</strong>，这样降低运算速度，比通常执行指令的速度慢一半。</p><p><strong>为了提高运算速度，在硬件中设置相联存储器，用来存放进程最近访问的部分页表项，也称转换后缓冲（Transaction Lookaside Buffer， TLB）或者快表，它是分页存储管理的重要组成部分</strong>。</p><p>快表的存取时间远小于内存，速度快但造价高，故容量较小，只能存放几十个页表项。<strong>快表包含页号和对应的页框号，当把页号交给快表后，它通过并行匹配同时对所有快表项进行比较，如果找到，则立即输出页框号，并形成物理地址；如果找不到，再查找主存中的页表以形成物理地址，同时将页号及页框号登记到快表中，当快表已满且要登记新页时，系统需要淘汰旧的快表项，</strong>最简单的策略就是先进先出，总是淘汰最先登记的页。需要注意的是，快表和高速换粗是不同的，两者再一个系统中可同时使用，前者记录最近转换的页号及页框号，后者保存最近实际访问的指令或者数据副本。</p><h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>现代操作系统普遍支持2^32~2^64B容量的逻辑地址空间，采用分页存储管理时，<strong>页表相当大</strong>。</p><p>以Windows为例，其运行的Intel x86 平台具有32位地址，规定页面4KB（2^12）, 那么4GB（2^32）的逻辑地址空间由1M（2^20）个页组成，若每个页表项占用4B，则需要占用4MB（2^20）连续主存空间来存放页表，这还是一个进程的地址空间。对于地址空间为64位的系统而言，问题会更加复杂。</p><p>为此， <strong>页表和页面一样也需要进行分页</strong>，这就是多级页表的概念。具体做法是：<strong>把整个页表分割成许多小页表，每个小页表称为页表页，其大小与页框长度相同，于是，每个页表页含有若干页表表项</strong>。</p><h2 id="分段存储管理"><a href="#分段存储管理" class="headerlink" title="分段存储管理"></a>分段存储管理</h2><p>促使存储管理方式从固定分区到动态分区，<strong>从分区方式向分页方式发展的主要原因是要提高主存空间利用率</strong>。那么，<strong>分段存储管理的引入主要满足用户（程序员）编程和使用上的要求</strong>，其他存储管理技术难以满足这些要求。</p><p>在分页存储管理中，经链接编辑处理得到一维地址结构的可装配目标模块，这是从0开始编址的单一连续逻辑地址空间，虽然可以把程序划分成页面，但<strong>页面与源程序并不存在逻辑关系，也就难以对源程序以模块为单位进行分配、共享和保护</strong>。事实上，程序更多是采用分段结构，高级语言往往采用模块化程序设计方法。应用程序由若干程序段（模块）组成，例如，由主程序段、子程序段、数据段和工作区段组成，每段都从0开始编址，有各自的名字和长度，且实现不同的功能。</p><p>分段存储管理把进程的逻辑地址空间分成多段，二维逻辑地址形式为：段号 段内位移。<strong>分段存储管理的实现基于可变分区存储管理的原理</strong>。<strong>可变分区以整个作业为单位来划分和连续存放，也就是说，作业在分区内是连续存放的，但独立作业之间不一定连续存放</strong>。而<strong>分段方法是以段位单位来划分和连续存放，为作业的各段分配一个连续的主存空间，而各段之间不一定连续</strong>。在进行存储分配时，应为进入主存的作业建立段表，各段在主存中的情况可由段表来记录，它指出主存中各分段的段号、段起始地址和段长度。在撤销进程时，回收所占用的主存空间，并清除此进程的段表。</p><h2 id="分段和分页的比较"><a href="#分段和分页的比较" class="headerlink" title="分段和分页的比较"></a>分段和分页的比较</h2><p>分段是<strong>信息的逻辑单位由源程序的逻辑结构及含义所决定</strong>，是<strong>用户可见</strong>的，<strong>段长由用户根据需求来决定</strong>，段起始地址可以从任何主存地址开始。在分段方式中，源程序（段号、段内位移）经链接装配后仍保持二维（地址）结构，<strong>引入目的是满足用户模块化程序设计的需要</strong>。</p><p>分页是<strong>信息的物理单位与源程序的逻辑结构无关</strong>，是<strong>用户不可见</strong>的，<strong>页长由系统（硬件）确定</strong>，页面只能从页大小的整数倍地址开始。在分页方式中，源程序（分页、页内位移）经链接装配后变成一维（地址）结构，<strong>引入的目的是实现离散分配并提高主存利用率</strong>。</p><h2 id="虚拟存储管理"><a href="#虚拟存储管理" class="headerlink" title="虚拟存储管理"></a>虚拟存储管理</h2><p><strong>前面介绍的存储管理称为实存管理，必须为进程分配足够的主存空间，装入其全部信息，否则进程无法运行</strong>。把进程的全部信息装入主存后，实际上并非同时使用，有些部分运行一遍，有些部分甚至从来不使用，进程在运行时不用的，或暂时不用的，或某些条件下才用的程序和数据，全部驻留于主存中是对宝贵存储资源的一种浪费，降低主存的利用率。于是，提出新的想法：<strong>不必装入进程的全部信息，仅将当前使用部分先装入主存，其余部分存放在磁盘中，待使用时由系统自动将其装进来，这就是虚拟存储管理技术的基本思路。</strong></p><p>虚拟存储器的定义：<strong>在具有层次结构存储器的计算机系统中，自动实现部分装入和部分替换的功能，能从逻辑上为用户提供一个比物理主存容量大得多的、可寻址的”主存储器“。</strong></p><p><strong>虚拟内存</strong>使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如 RAM）的使用也更有效率。目前，大多数操作系统都使用了虚拟内存，如 Windows 家族的“虚拟内存”；Linux 的“交换空间”等。</p><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>局部性原理表现在以下两个方面：</p><ul><li><p><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着<strong>大量的循环操作</strong>；</p></li><li><p><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为<strong>指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的</strong>；</p></li></ul><p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。</p><p>空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p><h3 id="请求分页虚拟存储管理"><a href="#请求分页虚拟存储管理" class="headerlink" title="请求分页虚拟存储管理"></a>请求分页虚拟存储管理</h3><h4 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h4><p>现代处理器使用的是一种称为虚拟寻址(Virtual Addressing) 的寻址方式。使用虚拟寻址，CPU 需要将逻辑地址翻译成物理地址，这样才能访问到真实的物理内存。完成虚拟地址转换为物理地址转换的硬件是 CPU 中的 MMU。</p><p>注：操作系统的存储管理依靠底层硬件的支撑来完成任务，此硬件称为主存管理部件（Memory Management Unit，MMU），它提供地址转换和存储保护功能，并支持虚拟存储管理和多任务管理。</p><h4 id="虚拟地址空间的作用"><a href="#虚拟地址空间的作用" class="headerlink" title="虚拟地址空间的作用"></a>虚拟地址空间的作用</h4><p>没有虚拟地址空间的时候，<strong>程序直接访问和操作的都是物理内存</strong>，会存在以下问题： </p><ul><li><p>用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃；</p></li><li><p>想要同时运行多个程序比较困难。例如微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这可能会造成微信崩溃；</p></li></ul><p>总结来说：如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难。</p><p>虚拟内存技术使得不同进程在运行过程中， 它所看到的是自己独自占有了当前系统的 4G 内存。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。 事实上，在每个进程创建加载时，内核只是为进程“创建” 了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data 段）拷贝到物理内存中， 只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中， 要动态分配内存，比如 malloc 时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</p><p>请求分页系统、 请求分段系统和请求段页式系统都是针对虚拟内存的， 通过请求实现内存与 外存的信息置换。</p><h5 id="虚拟内存的好处"><a href="#虚拟内存的好处" class="headerlink" title="虚拟内存的好处"></a>虚拟内存的好处</h5><ul><li><p>扩大地址空间；</p></li><li><p>内存保护：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还对特定 的内存地址提供写保护，可以防止代码或数据被恶意篡改；</p></li><li><p>公平内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间；</p></li><li><p>当进程通信时，可采用虚存共享的方式实现；</p></li><li><p>当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存；</p></li><li><p>虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把 CPU 交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高；</p></li><li><p>在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片；</p></li></ul><h5 id="虚拟内存的代价"><a href="#虚拟内存的代价" class="headerlink" title="虚拟内存的代价"></a>虚拟内存的代价</h5><ul><li><p>虚存的管理需要建立很多数据结构，占用额外的内存；</p></li><li><p>虚拟地址到物理地址的转换，增加了指令的执行时间；</p></li><li><p>页面的换入换出需要磁盘 I/O，较为耗时；</p></li><li><p>如果一页中只有一部分数据，会浪费内存。</p></li></ul><h4 id="虚拟内存技术的实现"><a href="#虚拟内存技术的实现" class="headerlink" title="虚拟内存技术的实现"></a>虚拟内存技术的实现</h4><p>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。虚拟内存的实现有以下三种方式：</p><ul><li><p><strong>请求分页存储管理</strong> ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</p></li><li><p><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</p></li><li><p><strong>请求段页式存储管理</strong></p></li></ul><h4 id="请求分页存储与分页存储"><a href="#请求分页存储与分页存储" class="headerlink" title="请求分页存储与分页存储"></a>请求分页存储与分页存储</h4><p>请求分页存储管理建立在分页管理之上，根本区别是是否将程序全部所需的全部地址空间都装入主存，请求分页存储管理不要求将作业全部地址空间同时装入主存，这也是请求分页存储管理可以提供虚拟内存的原因。</p><p>不管是上面那种实现方式，一般都需要：</p><ul><li><p>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</p></li><li><p><strong>缺页中断</strong>：如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序；</p></li><li><p><strong>虚拟地址空间</strong> ：逻辑地址到物理地址的变换；</p></li></ul><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><p>在多道程序的正常运行过程中，属于不同进程的页面被分散存放在准村页框中，当发生缺页中断时，如果已无空闲页框，系统要选择一个驻留页面继进行淘汰。这里讨论的是所有驻留页面都可作为置换对象的情况，而不管页面所属进程的全局页面替换算法。</p><p>注：缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。在这个时候，被内存映射的文件实际上成了一个分页交换文件。</p><h5 id="最佳页面置换算法"><a href="#最佳页面置换算法" class="headerlink" title="最佳页面置换算法"></a>最佳页面置换算法</h5><p>OPT 选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在主存下的若干页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</p><h5 id="先进先出页面置换算法"><a href="#先进先出页面置换算法" class="headerlink" title="先进先出页面置换算法"></a>先进先出页面置换算法</h5><p>FIFO总是淘汰最先调入主存的页面，即选择在主存中驻留时间最久的页面进行淘汰。</p><h5 id="最近最久未使用页面置换算法"><a href="#最近最久未使用页面置换算法" class="headerlink" title="最近最久未使用页面置换算法"></a>最近最久未使用页面置换算法</h5><p>LRU淘汰的页面是在最近一段时间内最久未被访问的那一页，是基于程序局部性原理来考虑的，认为那些刚被使用过的页面可能还要被使用，而那些在较长时间内未被使用的页面可能不会立即被使用。</p><p>LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</p><h5 id="第二次机会页面替换算法"><a href="#第二次机会页面替换算法" class="headerlink" title="第二次机会页面替换算法"></a>第二次机会页面替换算法</h5><p>FIFO算法会把经常使用的页面淘汰掉，为了避免这一点，可对算法继续宁改造，把FIFO算法也页表中的”引用位“结合起来使用，这就是 Second Chance Replacement算法。</p><p>实现思想如下：首先检查FIFO页面队列中的队首，这是最早进入主存的页面，如果其”引用位“是0.那么这个页面既时间长又没有用，选择此页面淘汰，如果是1，说明虽然它进入主存的时间比较早，但最近仍然使用，于是将其引用位清0，并把这个页面移至队尾，把它看作一个新调入的页，再给一次机会。</p><h5 id="时钟轮转"><a href="#时钟轮转" class="headerlink" title="时钟轮转"></a>时钟轮转</h5><p>如果利用标准队列机制构造 FIFO 队列，SCR算法可能会产生频繁的出队和入队，实现代价较大，可采用循环队列机制构造页面队列，形成类似于钟表面的环形表，队列指针相当于钟表面上的指针，指向可能淘汰的页面，这就是时钟页面淘汰算法的得名。此算法和 SCR 本质上没有什么区别，仅仅是实现方法有所改变，仍然要使用页表中的“引用位”，把进程已调入主存的页面链接成循环队列，用指针指向循环队列中下一个将被替换的页面。</p><h5 id="最少使用页面置换算法"><a href="#最少使用页面置换算法" class="headerlink" title="最少使用页面置换算法"></a>最少使用页面置换算法</h5><p>Least Frequently Used 选择在之前时期使用最少的页面作为淘汰页。</p><h1 id="select-与-epoll"><a href="#select-与-epoll" class="headerlink" title="select 与 epoll"></a>select 与 epoll</h1><p>这一块是IO多路复用下的知识。</p><p><strong>I/O多路复用</strong></p><p>IO 复用模型在阻塞 IO 模型上多了一个 select 函数，select 函数有一个参数是文件描述符集合，意思就是对这些的文件描述符进行循环监听，当某个文件描述符就绪的时候，就对这个文件描述符进行处理。</p><p>这种 IO 模型是属于阻塞的 IO。 但是由于它可以对多个文件描述符进行阻塞监听，所以它的效率比阻塞 IO 模型高效。</p><p>IO 多路复用就是我们说的 select，poll，epoll。 select/epoll 的好处就在于单个 process就可以同时处理多个网络连接的 IO。 它的基本原理就是 select，poll，epoll 这个 function 会不断的轮询所负责的所有 socket，当某个 socket 有数据到达了，就通知用户进程。</p><p>当用户进程调用了 select，那么整个进程会被 block，而同时，kernel 会“监视”所有 select负责的 socket，当任何一个 socket 中的数据准备好了，select 就会返回。 这个时候用户进程再调用 read 操作，将数据从 kernel 拷贝到用户进程。</p><p>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符） 其中的任意一个进入读就绪状态，select()函数就可以返回。</p><p>I/O 多路复用和阻塞 I/O 其实并没有太大的不同，事实上，还更差一些。 因为这里需要使用两个 system call (select 和 recvfrom)，而 blocking IO 只调用了一个 system call (recvfrom)。但是，用 select 的优势在于它可以同时处理多个 connection。</p><p>所以，如果处理的连接数不是很高的话，使用 select/epoll 的 web server 不一定比使用multi-threading + blocking IO 的 web server 性能更好，可能延迟还更大。 select/epoll 的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。 ）</p><p>在 IO multiplexing Model 中，实际中，对于每一个 socket，一般都设置成为 non-blocking，但是，如上图所示，整个用户的 process 其实是一直被 block 的。 只不过 process 是被 select这个函数 block，而不是被 socket IO 给 block。</p><p><strong>select</strong></p><p>select：是最初解决IO阻塞问题的方法。用结构体 fd_set 来告诉内核监听多个文件描述符，该结构体被称为描述符集。 由数组来维持哪些描述符被置位了。 对结构体的操作封装在三个宏定义中。 通过轮寻来查找是否有描述符要被处理。</p><p>存在的问题：</p><ol><li>内置数组的形式使得 select 的最大文件数受限与 FD_SIZE；</li><li>每次调用 select 前都要重新初始化描述符集，将 fd 从用户态拷贝到内核态，每次调用select 后，都需要将 fd 从内核态拷贝到用户态；</li><li>轮寻排查当文件描述符个数很多时，效率很低；</li></ol><p><strong>poll</strong></p><p>poll：通过一个可变长度的数组解决了 select 文件描述符受限的问题。 数组中元素是结构体，该结构体保存描述符的信息，每增加一个文件描述符就向数组中加入一个结构体，结构体只需要拷贝一次到内核态。 poll 解决了 select 重复初始化的问题。 轮寻排查的问题未解决。</p><p><strong>epoll</strong></p><p>epoll：轮寻排查所有文件描述符的效率不高，使服务器并发能力受限。 因此，epoll 采用只返回状态发生变化的文件描述符，便解决了轮寻的瓶颈。</p><p>epoll 对文件描述符的操作有两种模式：LT（level trigger） 和 ET（edge trigger） 。 LT模式是默认模式。</p><ol><li><p>LT 模式</p><p>LT(level triggered)是缺省的工作方式，并且同时支持 block 和 no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。 如果你不作任何操作，内核还是会继续通知你的。</p></li><li><p>ET 模式</p><p>ET(edge-triggered)是高速工作方式，只支持 no-block socket。 在这种模式下，当描述符从未就绪变为就绪时，内核通过 epoll 告诉你。 然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个 EWOULDBLOCK 错误） 。 但是请注意，如果一直不对这个 fd 作 IO 操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p><p>ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。 epoll工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p></li><li><p>LT 模式与 ET 模式的区别如下：</p><p>LT 模式：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。 下次调用 epoll_wait 时，会再次响应应用程序并通知此事件。</p><p>ET 模式：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。 如果不处理，下次调用 epoll_wait 时，不会再次响应应用程序并通知此事件。</p></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>操作系统教程第四版 - 高等教育出版社</p><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/operating-system/basis" target="_blank" rel="noopener">JavaGuide - 操作系统</a></p><p><a href="https://www.cnblogs.com/Anker/p/3271773.html" target="_blank" rel="noopener">孤儿进程与僵尸进程总结</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B" target="_blank" rel="noopener">wiki - 协程</a></p><p><a href="https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272" target="_blank" rel="noopener">廖雪峰 - 协程</a></p><p><a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98" target="_blank" rel="noopener">虚拟内存</a></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络基础</title>
    <link href="/2020/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM 基础</title>
    <link href="/2020/07/22/JVM%20%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/22/JVM%20%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>文章对 JVM 做简单的涉猎。</p><a id="more"></a><h2 id="JVM-内存分区"><a href="#JVM-内存分区" class="headerlink" title="JVM 内存分区"></a>JVM 内存分区</h2><p>通常可以把 JVM 内存区域分为下面几个方面，其中，有的区域是以线程为单位，有的区域则是整个 JVM 进程唯一的。</p><ul><li><p>程序计数器（PC，Program Counter Register）：在 JVM 规范中，每个线程都有它自己的程序计数器，并且任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；如果是在执行本地方法，则是未指定值（undefined）；</p></li><li><p>Java 虚拟机栈（Java Virtual Machine Stack）：早期也叫 Java 栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个栈帧（Stack Frame），对应着一次次的 Java 方法调用；</p><ul><li>在一个时间点，只会有一个活动的栈帧，通常叫作当前帧，方法所在的类叫作当前类。如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，成为新的当前帧，一直到它返回结果或者执行结束。JVM 直接对 Java 栈的操作只有两个，就是对栈帧的压栈和出栈；</li><li>栈帧中存储着局部变量表、操作数（operand）栈、动态链接、方法正常退出或者异常退出的定义等。</li></ul></li><li><p>堆（Heap）：Java 内存管理的核心区域，用来放置 Java 对象实例，几乎所有创建的 Java 对象实例都是被直接分配在堆上。堆被所有的线程共享，在虚拟机启动时，指定的 “Xmx” 之类参数就是用来指定最大堆空间等指标；</p><ul><li>堆也是垃圾收集器重点照顾的区域，所以堆内空间还会被不同的垃圾收集器进行进一步的细分，最有名的就是新生代、老年代的划分；</li></ul></li><li><p>方法区（Method Area）：所有线程共享的一块内存区域，存储元（Meta）数据，例如类结构信息，以及对应的运行时常量池、字段、方法代码等；</p><ul><li>由于早期的 Hotspot JVM 实现，习惯称方法区为永久代（Permanent Generation）。Oracle JDK 8 将永久代移除，增加元数据区（Metaspace）；</li></ul></li><li><p>运行时常量池（Run-Time Constant Pool）：方法区的一部分。反编译的类文件结构中有版本号、字段、方法、超类、接口等各种信息，还有一项信息就是常量池。Java 的常量池可以存放各种常量信息，包括编译期生成的各种字面量、运行时决定的符号引用等，所以它比一般语言的符号表存储的信息更加宽泛；</p></li><li><p>本地方法栈（Native Method Stack）：和 Java 虚拟机栈非常相似，支持对本地方法的调用，每个线程都会创建一个。在 Oracle Hotspot JVM 中，本地方法栈和 Java 虚拟机栈是在同一块儿区域，这取决于技术实现，未在规范中强制；</p></li></ul><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>Java 通过引入字节码和 JVM 机制，提供了强大的跨平台能力，理解 Java 的类加载机制是深入 Java 开发的必要条件。一般来说，Java 的类加载过程分为三个主要步骤：加载、链接、初始化，具体行为在Java 虚拟机规范里有非常详细的定义。</p><ul><li>首先是加载阶段，它是 Java 将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象），这里的数据源可能是各种各样的形态，如 jar 文件、class 文件，甚至是网络数据源等；如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError；<ul><li>加载阶段是用户参与的阶段，可以自定义类加载器，去实现自己的类加载过程；</li></ul></li><li>第二阶段是链接，这是核心的步骤，简单说是把原始的类定义信息平滑地转化入 JVM 运行的过程中。这里可进一步细分为三个步骤：<ul><li>验证：这是虚拟机安全的重要保障，JVM 需要核验字节信息是符合 Java 虚拟机规范的，否则就被认为是 VerifyError，这样就防止了恶意信息或者不合规的信息危害 JVM 的运行，验证阶段有可能触发更多 class 的加载；</li><li>准备：创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显式初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的 JVM 指令；</li><li>解析：在这一步会将常量池中的符号引用替换为直接引用。在Java 虚拟机规范中，详细介绍了类、接口、方法和字段等各个方面的解析；</li></ul></li><li>最后是初始化阶段：真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑；</li></ul><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>双亲委派模型，简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载 Java 类型。</p><h2 id="堆内部结构"><a href="#堆内部结构" class="headerlink" title="堆内部结构"></a>堆内部结构</h2><p><img src="JVM%E5%A0%86.png" srcset="/img/loading.gif" alt=""></p><ul><li>新生代是大部分对象创建和销毁的区域，Java 应用中绝大部分对象生命周期都很短暂。其内部又分为 Eden 区域，作为对象初始分配的区域；两个 Survivor，有时候也叫 from、to 区域，被用来放置从 Minor GC 中保留下来的对象；<ul><li>JVM 会随意选取一个 Survivor 区域作为 “to”，然后会在 GC 过程中进行区域间拷贝，也就是将 Eden 中存活下来的对象和 from 区域的对象，拷贝到 “to” 区域。这样设计主要是为了防止内存的碎片化，并进一步清理无用对象；<ul><li>大部分对象创建都是在Eden的，除了个别大对象外；</li><li>Minor GC开始前，to-survivor是空的，from-survivor是由对象的；</li><li>Minor GC后，Eden的存活对象都copy到to-survivor中，from-survivor的存活对象也复制to-survivor中。其中所有对象的年龄+1；</li><li>from-survivor清空，成为新的to-survivor，带有对象的to-survivor变成新的from-survivor。重复回到步骤2；</li></ul></li><li>从内存模型而不是垃圾收集的角度，对 Eden 区域继续进行划分，Hotspot JVM 还有一个概念叫做 Thread Local Allocation Buffer（TLAB），OpenJDK 衍生出来的 JVM 一般都提供了 TLAB 的设计。这是 JVM 为每个线程分配的一个私有缓存区域，否则多线程同时分配内存时，为避免操作同一地址，可能需要使用加锁等机制，影响分配速度，TLAB 仍然在堆上，它分配在 Eden 区域内。其内部结构比较直观易懂，start、end 是起始地址，top（指针）表示已经分配到哪里了。所以分配新对象，JVM 就会移动 top，当 top 和 end 相遇时，即表示该缓存已满，JVM 会试图再从 Eden 里分配一块；</li></ul></li><li>老年代放置长生命周期的对象，通常都是从 Survivor 区域拷贝过来的对象。不过也有特殊情况，普通的对象会被分配在 TLAB 上；如果对象较大，JVM 会试图直接分配在 Eden 其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM 就会直接分配到老年代；</li><li>永久代这部分是早期 Hotspot JVM 的方法区实现方式，储存 Java 类元数据、常量池、Intern 字符串缓存，JDK 8 之后删除这部分；</li></ul><h3 id="JVM-堆的参数"><a href="#JVM-堆的参数" class="headerlink" title="JVM 堆的参数"></a>JVM 堆的参数</h3><p>利用 JVM 参数，设置堆和内部区域的大小：</p><ul><li><p>最大堆体积</p><pre><code class="hljs java">-Xmx value</code></pre></li></ul><ul><li><p>初始的最小堆体积</p><pre><code class="hljs java">-Xms value</code></pre></li></ul><ul><li><p>老年代和新生代的比例，默认情况下，这个数值是 2，意味着老年代是新生代的 2 倍大；换句话说，新生代是堆大小的 1/3；</p><pre><code class="hljs java">-XX:NewRatio = value</code></pre></li></ul><ul><li><p>可以不用比例的方式调整新生代的大小，指定下面的参数，设定具体的内存大小数值；</p><pre><code class="hljs java">-XX:NewSize = value</code></pre></li></ul><ul><li><p>Eden 和 Survivor 的大小是按照比例设置的，如果 SurvivorRatio 是 8，那么 Survivor 区域就是 Eden 的 1/8 大小，也就是新生代的 1/10，因为 YoungGen=Eden + 2*Survivor，JVM 参数格式是</p><pre><code class="hljs java">-XX:SurvivorRatio = value</code></pre></li></ul><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><h3 id="垃圾收集的原理"><a href="#垃圾收集的原理" class="headerlink" title="垃圾收集的原理"></a>垃圾收集的原理</h3><p>自动垃圾收集的前提是清楚哪些内存可以被释放。这一点可以结合 Java 类加载和内存结构思考。</p><p>主要涉及两个方面：1）最主要部分就是对象实例，都是存储在堆上的；2）方法区中的元数据等信息，例如类型不再使用，卸载该 Java 类是合理的；</p><p>对象实例收集主要使用两种基本算法，引用计数和可达性分析。</p><ul><li>引用计数算法：为对象添加一个引用计数，记录对象被引用的情况，如果计数为 0，即表示对象可回收。这是很多语言的资源回收选择，例如Python，它同时支持引用计数和垃圾收集机制。根据场景择优使用，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。Java 没有选择引用计数，因为其存在一个基本的难题，即很难处理循环引用关系；</li><li>可达性分析：Java使用这种方法。这种类型的垃圾收集通常叫作追踪性垃圾收集（Tracing Garbage Collection）。其原理简单来说，就是将对象及其引用关系看作一个图，选定活动的对象作为 GC Roots，然后跟踪引用链条，如果一个对象和 GC Roots 之间不可达，也就是不存在引用链条，那么可以认为是可回收对象。JVM 会把虚拟机栈和本地方法栈中正在引用的对象、静态属性引用的对象和常量，作为 GC Roots；</li></ul><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p>对于常见的垃圾收集算法，做到总体上有个了解，理解相应的原理和优缺点。实际 GC 实现过程要复杂的多，目前还在发展中的前沿 GC 都是复合算法，并且并行和并发兼备。</p><ul><li><p>复制（Copying）算法：新生代 GC 基本都是基于复制算法，将活着的对象复制到 to 区域，拷贝过程中将对象顺序放置，就可以避免内存碎片化。这么做的代价是，如果要进行复制，就要提前预留内存空间，有一定的浪费；另外，对于 G1 这种分拆成为大量 region 的 GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用方面还是时间上，都有一定的开销；</p></li><li><p>标记 - 清除（Mark-Sweep）算法：首先进行标记工作，标识出所有要回收的对象，然后进行清除。这么做除了标记、清除过程效率有限，另外就是不可避免的出现碎片化问题，这就导致其不适合特别大的堆；否则一旦出现 Full GC，暂停时间可能无法接受；</p></li><li><p>标记 - 整理（Mark-Compact）：类似于标记 - 清除，但为避免内存碎片化，它会在清理过程中将对象移动，以确保移动后的对象占用连续的内存空间。</p></li></ul><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><h4 id="Serial-GC"><a href="#Serial-GC" class="headerlink" title="Serial GC"></a>Serial GC</h4><p>最古老的垃圾收集器，“Serial” 体现在其收集工作是单线程的，并且在进行垃圾收集过程中，会进入臭名昭著的 “Stop-The-World” 状态。当然，其单线程设计也意味着精简的 GC 实现，无需维护复杂的数据结构，初始化也简单，所以一直是 Client 模式下 JVM 的默认选项。从年代的角度，通常将其老年代实现单独称作 Serial Old，它采用了标记 - 整理（Mark-Compact）算法，区别于新生代的复制算法。Serial GC 的对应 JVM 参数是：</p><pre><code class="hljs java">-XX:+UseSerialGC</code></pre><h4 id="CMS-GC"><a href="#CMS-GC" class="headerlink" title="CMS GC"></a>CMS GC</h4><p>Concurrent Mark Sweep GC 基于标记 - 清除（Mark-Sweep）算法，设计目标是尽量减少停顿时间，这一点对于 Web 等反应时间敏感的应用非常重要，至今仍然有很多系统使用 CMS GC。但是，CMS 采用的标记 - 清除算法，存在着内存碎片化问题，所以难以避免在长时间运行等情况下发生 full GC，导致恶劣的停顿。此外，既然强调了并发（Concurrent），CMS 会占用更多 CPU 资源，并和用户线程争抢。</p><h4 id="Parallel-GC"><a href="#Parallel-GC" class="headerlink" title="Parallel GC"></a>Parallel GC</h4><p>在早期 JDK 8 等版本中，它是 server 模式 JVM 的默认 GC 选择，也被称作是吞吐量优先的 GC。它的算法和 Serial GC 比较相似，尽管实现要复杂的多，其特点是新生代和老年代 GC 都是并行进行的，在常见的服务器环境中更加高效。开启选项是：</p><pre><code class="hljs java">-XX:+UseParallelGC</code></pre><p>另外，Parallel GC 引入了开发者友好的配置项，可以直接设置暂停时间或吞吐量等目标，JVM 会自动进行适应性调整，例如下面参数：</p><pre><code class="hljs java">-XX:MaxGCPauseMillis=value-XX:GCTimeRatio=N  <span class="hljs-comment">// GC时间和用户时间比例 = 1 / (N+1)</span></code></pre><h4 id="G1-GC"><a href="#G1-GC" class="headerlink" title="G1 GC"></a>G1 GC</h4><p>一种兼顾吞吐量和停顿时间的 GC 实现，是 Oracle JDK 9 以后的默认 GC 选项。G1 可以直观的设定停顿时间的目标，相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。</p><p>G1 GC 仍然存在着年代的概念，但是其内存结构并不是简单的条带式划分，而是类似棋盘的一个个 region。Region 之间是复制算法，但整体上实际可看作是标记 - 整理（Mark-Compact）算法，可以有效地避免内存碎片，尤其是当 Java 堆非常大的时候，G1 的优势更加明显。G1 吞吐量和停顿表现都非常不错，并且仍然在不断地完善。与此同时，CMS 已经在 JDK 9 中被标记为废弃（deprecated），所以 G1 GC 值得你深入掌握。</p><h3 id="垃圾收集过程的理解"><a href="#垃圾收集过程的理解" class="headerlink" title="垃圾收集过程的理解"></a>垃圾收集过程的理解</h3><p>在垃圾收集的过程，Eden、Survivor、Tenured 等区域的变化取决于具体的 GC 方式，需要了解通常的垃圾收集的流程。</p><ol><li><p>Java 应用不断创建对象，通常都是分配在 Eden 区域，当其空间占用达到一定阈值时，触发 minor GC。仍然被引用的对象（绿色方块）存活下来，被复制到 JVM 选择的 Survivor 区域，而没有被引用的对象（黄色方块）则被回收。注意，存活对象标记了“数字 1”，这是为了表明对象的存活时间；</p><p><img src="gc_progress_pic1.png" srcset="/img/loading.gif" alt=""></p></li><li><p>经过一次 Minor GC，Eden 就会空闲下来，直到再次达到 Minor GC 触发条件，这时候，另外一个 Survivor 区域则会成为 to 区域，Eden 区域的存活对象和 From 区域对象，都会被复制到 to 区域，并且存活的年龄计数会被加 1；</p><p><img src="gc_progress_pic2.png" srcset="/img/loading.gif" alt=""></p></li><li><p>类似第二步的过程会发生很多次，直到有对象年龄计数达到阈值，这时候就会发生所谓的晋升（Promotion）过程，如下图所示，超过阈值的对象会被晋升到老年代。这个阈值是可以通过参数指定：</p><pre><code class="hljs java">-XX:MaxTenuringThreshold=&lt;N&gt;</code></pre><p><img src="gc_progress_pic3.png" srcset="/img/loading.gif" alt=""></p></li></ol><p>后面就是老年代 GC，具体取决于选择的 GC 选项，对应不同的算法。下面是一个简单标记 - 整理算法过程示意图，老年代中的无用对象被清除后， GC 会将对象进行整理，以防止内存碎片化。</p><p><img src="gc_progress_pic4.png" srcset="/img/loading.gif" alt=""></p><p>通常把老年代 GC 叫作 Major GC，对整个堆进行清理的操作叫作 Full GC，但是这个也没有那么绝对，因为不同的老年代 GC 算法其实表现差异很大，例如，对于 CMS，“concurrent” 就体现在清理工作是与工作线程一起并发运行的。</p><p>GC 仍然处于飞速发展之中，目前的默认选项 G1 GC 在不断的进行改进，原来的很多缺点，例如串行的 Full GC、Card Table 扫描的低效等问题，都已经被大幅改进，比如，在 JDK 10 以后，Full GC 已经是并行运行，很多场景下其表现还略优于 Parallel GC 的并行 Full GC 实现。</p><p>即使是 Serial GC，虽然比较古老，但是其简单的设计和实现未必就是过时的，它本身的开销，不管是 GC 相关数据结构的开销，还是线程的开销，都非常小。随着云计算的兴起，在 Serverless 等新的应用场景下，Serial GC 有了新的应用。</p><p>对于 CMS GC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但是已经被标记为废弃，如果没有组织主动承担 CMS 的维护，很有可能会在未来版本移除。</p><h3 id="垃圾收集调优"><a href="#垃圾收集调优" class="headerlink" title="垃圾收集调优"></a>垃圾收集调优</h3><p>调优是针对特定场景、特定目的的，对于 GC 调优，首先要明确调优的目标。从性能的角度看，通常关注三个方面：内存占用（footprint）、延时（latency）和吞吐量（throughput）。大多数情况下调优会侧重于其中一个或者两个方面的目标，很少有情况可以兼顾三个不同的角度。当然，也可能需要考虑其他 GC 相关的场景，例如，1）OOM 可能与不合理的 GC 参数有关；2）对应用启动速度方面的有特定的需求。</p><p>基本的调优思路和步骤可以总结为：</p><ul><li><p>理解应用需求和问题，确定调优目标。假设开发了一个应用服务，但发现偶尔会出现性能抖动，出现较长的服务停顿。评估用户可接受的响应时间和业务量，将目标简化为，希望 GC 暂停尽量控制在 200ms 以内，并且保证一定标准的吞吐量；</p></li><li><p>掌握 JVM 和 GC 的状态，定位具体的问题，确定真的有 GC 调优的必要。具体有很多方法，比如，通过 jstat 等工具查看 GC 等相关状态，可以开启 GC 日志，或者是利用操作系统提供的诊断工具等。例如，通过追踪 GC 日志，查找是不是 GC 在特定时间发生了长时间的暂停，进而导致了应用响应不及时；</p></li><li><p>思考选择的 GC 类型是否符合应用特征，如果是，具体问题表现在哪里，是 Minor GC 过长，还是 Mixed GC 等出现异常停顿情况；如果不是，考虑切换到什么类型，如 CMS 和 G1 都是更侧重于低延迟的 GC 选项；</p></li><li><p>通过分析确定具体调整的参数或者软硬件配置；</p></li><li><p>验证是否达到调优目标，如果达到目标，即可以考虑结束调优；否则，重复完成分析、调整、验证这个过程；</p></li></ul><h2 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h2><p>通俗来说 OOM 就是 JVM 内存不够用了。Javadoc 对 OutOfMemoryError 的解释是：没有空闲内存，并且垃圾收集器也无法提供更多内存。这隐含着一层意思：在抛出 OutOfMemoryError 之前，通常会触发垃圾收集器，尽其所能去清理出空间，例如：</p><ul><li><p>引用机制分析中说到的 JVM 会去尝试回收软引用指向的对象等；</p></li><li><p>在 java.nio.BIts.reserveMemory() 方法中，能看到 System.gc() 会被调用，以清理空间。这也是为什么大量使用 NIO 的 Direct Buffer 时，通常不加下面的参数，毕竟是个最后的尝试，有可能避免一定的内存不足问题；</p><pre><code class="hljs java">-XX:+DisableExplicitGC</code></pre></li></ul><p>也不是任何情况下垃圾收集器都会被触发，比如分配一个超大对象，比如一个大数组，超过堆的最大值，JVM 可以判断出垃圾收集并不能解决这个问题，所以直接抛出 OutOfMemoryError。除了程序计数器，其他区域都有可能会因为可能的空间不足发生 OutOfMemoryError，简单总结如下：</p><ul><li><p>堆内存不足是最常见的 OOM 原因之一，抛出的错误信息是 “java.lang.OutOfMemoryError: Java heap space”，原因可能千奇百怪，例如：1）可能存在内存泄漏问题；2）可能是堆的大小不合理，比如要处理比较大的数据量，但是没有显式指定 JVM 堆大小或者指定数值偏小；2）JVM 处理引用不及时，导致堆积起来，内存无法释放等；</p></li><li><p>Java 虚拟机栈和本地方法栈：如果程序不断的进行递归调用，没有退出条件，就会导致不断地进行压栈。类似这种情况，JVM 会抛出 StackOverFlowError；如果 JVM 试图去扩展栈空间的时候失败，则会抛出 OutOfMemoryError；</p></li><li><p>老版本的 Oracle JDK 中，永久代的大小是有限的，并且 JVM 对永久代垃圾回收（如常量池回收、卸载不再需要的类型）不积极，所以在不断添加新类型的时候，永久代出现 OutOfMemoryError 也比较多见，尤其是在运行时存在大量动态类型生成的场景；类似 Intern 字符串缓存占用太多空间，也会导致 OOM 问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError: PermGen space”；</p></li><li><p>元数据区引入之后，方法区内存已经不再那么窘迫，相应的 OOM 有所改善，出现 OOM 后异常信息变成了：“java.lang.OutOfMemoryError: Metaspace”；</p></li><li><p>直接内存不足，也会导致 OOM；</p></li></ul><h3 id="自测题"><a href="#自测题" class="headerlink" title="自测题"></a>自测题</h3><p>1.进程和线程的关系，哪些资源是私有的，哪些是公有的</p><p>2.简单说说 Java Object 的方法</p><p>3.new 一个对象的过程，简单说说对象创建到消亡的过程。</p><p>4.详细说说类加载的过程，静态代码块执行在哪个阶段。</p><p>5.说一说打破双亲委托机制原理，以及常用场景。</p><p>6.如何判断一个对象需要回收。</p><p>7.GC 工作原理，简单说说 CMS 和 G1，比较 CMS 和 G1。</p><p>8.如果对象大部分都是存活的，少部分需要清除，应当用什么算法。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Java 核心技术精讲 - 极客时间</p><p><a href="https://blog.csdn.net/a525390802/article/details/80509457" target="_blank" rel="noopener">JVM之内存模型JMM中本地内存的理解</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 多线程基础</title>
    <link href="/2020/07/22/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/22/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>并发成为现代软件开发的基础能力，Java 精心设计的高效并发机制，是构建大规模应用的基础之一。本文介绍 Java 并发编程基础知识。主要内容为 线程生命周期、如何实现线程、synchronized与锁、volatile、线程池、并发包、CAS与原子操作。</p><a id="more"></a><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是<strong>应用程序在内存中分配的空间，也就是正在运行的程序</strong>，各个进程之间互不干扰。同时进程保存着程序每一个时刻运行的状态。进程的出现，使操作系统的性能大大提升，但是如果一个进程在一段时间只执行一个任务，那么当进程有多个子任务时，只能逐个执行这些子任务，效率较低。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>为了提高 CPU 和 IO 设备的综合利用率，线程个概念被提出并应用。线程是一个比进程更小的执行单位，一个进程包含了多个线程，同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，而<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>是私有的，每个线程负责一个单独的子任务。</p><h2 id="进程和线程的异同"><a href="#进程和线程的异同" class="headerlink" title="进程和线程的异同"></a>进程和线程的异同</h2><ul><li><p><strong>进程是操作系统进行资源分配的基本单位</strong>，<strong>线程是系统调度的最小单元</strong>；</p></li><li><p>线程是程序执行的最小单位，更加轻量级，线程间的切换和调度的成本远远小于进程。多线程可以在多核 CPU 上同时运行，减少了线程上下文切换的开销；</p></li><li><p>多线程并发编程是高并发系统的基础，好多线程机制可以提高系统整体的并发能力及性能；</p></li><li><p>一个进程可以包含多个线程，线程作为任务的真正执行者，有<strong>自己的栈、寄存器、本地存储（Thread Local）</strong>等，但是会<strong>和进程内其他线程共享文件描述符、虚拟地址空间等</strong>；</p></li><li><p>Java 中进程的内存占用如下图所示</p><p><img src="JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86.png" srcset="/img/loading.gif" alt=""></p></li></ul><h1 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h1><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>Java 5 以后，线程生命周期的不同状态被明确定义在其公共内部枚举类型 java.lang.Thread.State 中，分别是：</p><ul><li><p>新建（<strong>NEW</strong>），表示线程被创建出来还<strong>没真正启动</strong>的状态，可以认为它是个 Java 内部状态；</p></li><li><p>就绪（<strong>RUNNABLE</strong>），表示该线程已经在 JVM 中执行，当然由于执行需要计算资源，它<strong>可能是正在运行</strong>，也可能还在<strong>等待系统分配给它 CPU 片段，在就绪队列里面排队</strong>。在其他一些分析中，会额外区分一种状态 <strong>RUNNING</strong>，但是从 Java API 的角度，并不能表示出来；</p></li><li><p>阻塞（<strong>BLOCKED</strong>），这个状态和同步非常相关，<strong>阻塞表示线程在等待 Monitor lock</strong>。比如，线程试图<strong>通过 synchronized 去获取某个锁</strong>，但是其他线程已经独占了，那么当前线程就会处于阻塞状态；</p></li><li><p>等待（<strong>WAITING</strong>），表示正在<strong>等待其他线程采取某些操作</strong>。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（<strong>wait</strong>），另外的生产者线程去准备任务数据，然后通过类似 <strong>notify</strong> 等动作，通知消费线程可以继续工作了。<strong>Thread.join() 也会令线程进入等待状态</strong>。计时等待（<strong>TIMED_WAIT</strong>），其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如 <strong>wait 或 join 等方法的指定超时</strong>版本，如下面示例：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;</code></pre></li><li><p>终止（<strong>TERMINATED</strong>），不管是<strong>意外退出还是正常执行结束，线程已经完成使命，终止运行</strong>。第二次调用 start() 方法的时候，线程可能处于终止或者其他（非 NEW）状态，但是不论如何，都<strong>不可以再次启动</strong>。</p></li></ul><h2 id="线程操作"><a href="#线程操作" class="headerlink" title="线程操作"></a>线程操作</h2><ul><li>start()：启动线程并执行相应的 run() 方法；</li><li>run()：子线程要执行的逻辑代码在 run() 中完成；</li><li>sleep()：让当前线程停止执行，把 CPU 让给其他线程执行，但<strong>不会释放对象锁和监控的状态</strong>，到了指定时间后线程又会自动恢复运行状态；<ul><li>注：线程睡眠到期自动苏醒，并返回到<strong>可运行状态</strong>，不是运行状态。sleep() 中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始执行；</li></ul></li><li>wait()：使一个线程处于等待（阻塞）状态，并且<strong>释放所持有的对象的锁</strong>；</li><li>join()：t.join() 方法只会使主线程（调用 t.join() 的线程）进入等待池并等待 t线程 执行完毕后才会被唤醒。不影响同一时刻处在运行状态的其他线程；<ul><li>使用场景示例：主线程创建并启动了线程，如果子线程中药进行大量耗时运算，主线程往往会早于子线程结束之前结束。如果主线程想等待子线程执行完成之后再结束，比如主线程要获取子线程处理的数据，就要用到 join() 方法；</li></ul></li><li>yield()：告诉调度器主动让出 CPU；<ul><li>注：让出 CPU 不代表当前线程不执行了。当前线程让出 CPU 后，还会进行 CPU 资源的争夺，但是不保证一定能够再次分配到；</li></ul></li><li>getPriority()：获取当前线程的优先级；<ul><li>注：两个等待的线程，优先级高的线程容易被 CPU 执行。优先级分为1~10等级，默认优先级是5；</li></ul></li><li>setPriority()：设置线程的优先级；</li><li>getId()：取得线程唯一标识；</li><li>isAlive()：判断当前线程是否处于活动状态，活动状态就是已经启动尚未终止；</li><li>currentThread()：返回代码段正在被哪个线程调用；</li><li>resume()、stop()、suspend() 方法被标记为过时，在 JDK 最新版本中，destory/stop 方法将被移除；</li><li>基类 Object 提供了一些基础的 wait() / notify() / notifyAll() 方法；<ul><li>如果持有某个对象的 Monitor 锁，调用 wait 会让当前线程处于等待状态，直到其他线程 notify 或者 notifyAll。所以，这些方法本质上是提供了 Monitor 的获取和释放的能力，是基本的线程间通信方式；</li></ul></li><li>并发类库中的工具，比如 CountDownLatch.await() 会让当前线程进入等待状态，直到 latch 被计数为 0，这可以看作是线程间通信的 Signal；</li></ul><h1 id="Java-中如何实现线程"><a href="#Java-中如何实现线程" class="headerlink" title="Java 中如何实现线程"></a>Java 中如何实现线程</h1><h2 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h2><ul><li><strong>创建一个任务类继承 Thread 类</strong>，Thread类实现了Runnable接口，所以自定义的任务类也实现了Runnable接口；<ul><li>扩展 java.lang.Thread 类来创建线程，java.lang.Thread 类主要有两个方法：<ul><li>start()：调用自定义对象的start()方法，可以启动线程；</li><li>run()：run()方法定义了具体的任务代码或处理逻辑，Thread 的子类应该重写run()方法；</li></ul></li><li>创建一个任务类对象，可以用 Thread 或者 Runnable 作为自定义的变量类型；</li><li>调用自定义对象的 start() 方法，启动一个线程；</li></ul></li><li><strong>定义一个任务类实现 Runnable 接口</strong>；<ul><li>实现 Runnable 接口中的 run() 方法；</li><li>定义了任务类后，为任务类创建一个任务对象；</li><li>任务必须在线程中执行，创建一个 Thread 类的对象，将前面创建的实现了 Runnable 接口的<strong>任务类对象作为参数传递给Thread类的构造方法</strong>；</li><li>调用Thread类对象的 start() 方法，启动一个线程。</li></ul></li></ul><h1 id="synchronized-与锁"><a href="#synchronized-与锁" class="headerlink" title="synchronized 与锁"></a>synchronized 与锁</h1><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>线程安全是一个多线程环境下<strong>正确性的概念</strong>，也就是保证多线程环境下<strong>共享的</strong>、<strong>可修改</strong>的<strong>状态</strong>的正确性，这里的状态反映在程序中其实可以看作是<strong>数据</strong>。换个角度来看，如果状态不是共享的，或者不是可修改的，也就不存在线程安全问题。线程安全需要保证几个基本特性：</p><ul><li>原子性：相关操作不会中途被其他线程干扰，一般通过<strong>同步机制</strong>实现；</li><li>可见性：一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为<strong>将线程本地状态反映到主内存上</strong>，<strong>volatile</strong> 可以负责保证可见性的；</li><li>有序性：保证线程内串行语义，<strong>避免指令重排</strong>等； </li></ul><h2 id="synchronized-与-ReentrantLock"><a href="#synchronized-与-ReentrantLock" class="headerlink" title="synchronized 与 ReentrantLock"></a>synchronized 与 ReentrantLock</h2><p>synchronized 是 Java 内建的同步机制，所以也称为 Intrinsic Locking，它提供了互斥的语义和可见性，<strong>当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在那里</strong>。</p><ul><li>Java 5 以前，synchronized 是仅有的同步手段，在代码中，synchronized 可以用来<strong>修饰方法</strong>，也可以使用在特定的<strong>代码块</strong>儿上，<strong>本质上 synchronized 方法等同于把方法全部语句用 synchronized 块包起</strong>；</li><li>synchronized 依赖于 <strong>JVM</strong>，ReentrantLock 依赖于 <strong>API</strong>，synchronized 是依赖于 JVM 实现的，没有直接暴露给用户；ReentrantLock 是 JDK 层面实现的（需要 lock() 和 unlock() 方法配合 try/finally 来完成），所以可以查看它的源代码；</li><li>ReentrantLock，是 Java 5 提供的锁实现，语义和 synchronized 基本相同。再入锁通过代码直接调用 lock() 方法获取，代码书写也更加灵活。ReentrantLock 提供了很多实用的方法，能够实现很多 synchronized 无法做到的<strong>细节控制</strong>，比如可以控制 fairness，也就是<strong>公平性</strong>，或者利用<strong>定义条件</strong>等。但是，编码中也需要注意，必须要<strong>明确调用 unlock() 方法释放</strong>，不然就会一直持有该锁；<ul><li>与 synchronized 相比，ReentrantLock 增加了一些高级功能，主要有三点：等待可中断；可实现公平锁；可实现选择性通知（锁可以绑定多个条件）；</li></ul></li><li>synchronized 和 ReentrantLock 的性能不能一概而论，早期版本 synchronized 在很多场景下性能相差较大，在后续版本进行了较多改进，在低竞争场景中表现可能优于 ReentrantLock；</li></ul><h2 id="syschronized-实现原理"><a href="#syschronized-实现原理" class="headerlink" title="syschronized 实现原理"></a>syschronized 实现原理</h2><p>synchronized 代码块由一对 monitorenter / monitorexit 指令实现，Monitor 对象是同步的基本实现单元。</p><ul><li>Java 6 之前，Monitor 的实现完全依靠<strong>操作系统内部的互斥锁</strong>，因为需要进行<strong>用户态到内核态的切换</strong>，所以同步操作是一个<strong>重量级操作</strong>；</li></ul><h2 id="锁的升级、降级"><a href="#锁的升级、降级" class="headerlink" title="锁的升级、降级"></a>锁的升级、降级</h2><ul><li>现代的（Oracle）JDK 中，JVM 对此进行了改进，提供了<strong>三种不同的 Monitor 实现</strong>，也就是常说的三种不同的锁：<strong>偏斜锁</strong>（Biased Locking）、<strong>轻量级锁</strong>和<strong>重量级锁</strong>，大大改进了其性能；</li><li>锁的升级、降级，指的是 <strong>JVM 优化 synchronized 运行的机制</strong>，当 JVM 检测到不同的竞争状况时，会<strong>自动切换到适合的锁实现</strong>，这种切换就是锁的升级、降级；</li><li>当<strong>没有竞争</strong>出现时，默认会使用偏斜锁。JVM 会利用 <strong>CAS 操作</strong>（compare and swap），在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，<strong>大部分对象生命周期中最多会被一个线程锁定</strong>，使用<strong>偏斜锁可以降低无竞争开销</strong>；</li><li>如果有<strong>另外的线程试图锁定某个已经被偏斜过的对象</strong>，JVM 就需要撤销（revoke）偏斜锁，并切换到<strong>轻量级锁实现</strong>。轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，<strong>如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁；</strong></li><li>有的观点认为 Java 不会进行锁降级。有的观点认为，锁降级是会发生的，当 <strong>JVM 进入安全点</strong>（SafePoint）的时候，会检查是否有闲置的 Monitor，然后试图进行降级。</li></ul><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个共享变量的值，而另外一个线程还继续使用它的本地内存中共享变量的副本，造成<strong>数据的不一致</strong>。</p><p>注：在多个线程之间能够被共享的变量被称为共享变量。共享变量包括所有的实例变量，静态变量和数组元素。他们都被存放在堆内存中，volatile 只作用于共享变量。</p><h2 id="volatile-定义"><a href="#volatile-定义" class="headerlink" title="volatile 定义"></a>volatile 定义</h2><p>java 编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java 语言提供了 volatile，在某些情况下比锁更加方便。如果一个字段被声明成 volatile，java 线程内存模型确保所有线程看到这个变量的值是一致的。</p><p>Volatile 是<strong>轻量级的 synchronized</strong>，它在多处理器开发中保证了共享变量的“<strong>可见性</strong>”。可见性指的是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h2><p>池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。线程池提供了一种限制和管理资源的技术。 每个线程池维护一些基本统计信息，例如已完成任务的数量。</p><ul><li><strong>降低资源消耗</strong>：通过重复利用已创建的线程降低线程创建和销毁造成的消耗；</li><li>*<em>提高响应速度 *</em>：当任务到达时，任务可以不需要的等待线程的创建就能立即执行；</li><li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控；</li></ul><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>通常开发者可以利用 Executors 提供的通用线程池创建方法，创建不同配置的线程池，主要区别在于不同的 ExecutorService 类型或者不同的初始参数。Executors 目前提供了 5 种不同的线程池创建配置：</p><ul><li>newCachedThreadPool()：<strong>用来处理大量短时间工作任务的线程池</strong>，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</li><li>newFixedThreadPool(int nThreads)：<strong>重用指定数目（nThreads）的线程，底层使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的</strong>。如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；</li><li>newSingleThreadExecutor()：<strong>工作线程数目被限制为 1</strong>，操作一个无界的工作队列，<strong>保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态</strong>，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；</li><li>newSingleThreadScheduledExecutor() 和 newScheduledThreadPool(int corePoolSize)：创建的是个 ScheduledExecutorService，可以进行<strong>定时或周期性的工作调度</strong>，区别在于单一工作线程还是多个工作线程；</li><li>newWorkStealingPool(int parallelism)：Java 8 加入这个创建方法，内部会构建ForkJoinPool，利用Work-Stealing算法，<strong>并行地处理任务，不保证处理顺序</strong>；</li></ul><p>注：</p><ul><li>newFixedThreadPool 和 newSingleThreadExecutor：允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致OOM。</li><li>newCachedThreadPool 和 newScheduledThreadPool：允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</li></ul><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><h3 id="线程池创建"><a href="#线程池创建" class="headerlink" title="线程池创建"></a>线程池创建</h3><p>可以通过 ThreadPoolExecutor 创建一个线程池。</p><pre><code class="hljs java"><span class="hljs-keyword">new</span>  ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, handler);</code></pre><ul><li>corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，<strong>即使其他空闲的基本线程能够执行新任务也会创建线程</strong>，等到<strong>需要执行的任务数大于线程池基本大小</strong>时就不再创建。如果调用了线程池的 prestartAllCoreThreads 方法，线程池会提前创建并启动所有基本线程；</li><li>runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列：<ul><li>ArrayBlockingQueue：基于数组结构的有界阻塞队列，按 FIFO 原则对元素排序；</li><li>LinkedBlockingQueue：基于链表结构的阻塞队列，按 FIFO 原则对元素排序，吞吐量通常高于 ArrayBlockingQueue。静态工厂方法 Executors.newFixedThreadPool() 使用了这个队列；</li><li>SynchronousQueue：不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 LinkedBlockingQueue，静态工厂方法 Executors.newCachedThreadPool 使用了这个队列；</li><li>PriorityBlockingQueue：具有优先级的无界阻塞队列；</li></ul></li><li>maximumPoolSize（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果；</li><li>ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字；</li><li>RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是 AbortPolicy，表示无法处理新任务时抛出异常。以下是 JDK1.5 提供的四种策略：<ul><li>AbortPolicy：直接抛出异常；</li><li>CallerRunsPolicy：只用调用者所在线程来运行任务；</li><li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务；</li><li>DiscardPolicy：不处理，丢弃掉；</li><li>也可以根据应用场景需要来实现 RejectedExecutionHandler 接口自定义策略。如记录日志或持久化不能处理的任务；</li></ul></li><li>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率；</li><li>TimeUnit（线程活动保持时间的单位）：可选的单位有天，小时，分钟，毫秒，微秒 (千分之一毫秒) 和毫微秒 (千分之一微秒)；</li></ul><h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><p>可以通过 execute() 和 submit() 方法向线程池提交任务。</p><ul><li><p>execute() 用于提交不需要返回值的任务，无法判断任务是否被线程池执行成功；</p><pre><code class="hljs java">threadsPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-comment">// TODO Auto-generated method stub</span>            &#125;        &#125;);</code></pre></li></ul><ul><li><p>submit() 方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get() 方法获取返回值，get() 方法会阻塞当前线程直到任务完成，而 get(long timeout，TimeUnit unit) 方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完；</p><pre><code class="hljs java">Future&lt;Object&gt; future = executor.submit(harReturnValuetask);<span class="hljs-keyword">try</span> &#123;     Object s = future.get();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;    <span class="hljs-comment">// 处理中断异常 </span>&#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;    <span class="hljs-comment">// 处理无法执行任务异常 </span>&#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-comment">// 关闭线程池 </span>    executor.shutdown();&#125;</code></pre></li></ul><h3 id="线程池关闭"><a href="#线程池关闭" class="headerlink" title="线程池关闭"></a>线程池关闭</h3><p>可以通过调用线程池的 shutdown 或 shutdownNow 方法来关闭线程池，它们的原理是遍历线程池中的工作线程，然后逐个调用线程的 interrupt 方法来中断线程，所以无法响应中断的任务可能永远无法终止。</p><ul><li>shutdownNow 首先将线程池的状态设置成 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表；</li><li>shutdown 只是将线程池的状态设置成 SHUTDOWN 状态，然后中断所有没有正在执行任务的线程；</li></ul><p>只要调用了这两个关闭方法的其中一个，isShutdown 方法就会返回 true。当所有的任务都已关闭后, 才表示线程池关闭成功，这时调用 isTerminaed 方法会返回 true。至于调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定。通常调用 shutdown 来关闭线程池，如果任务不一定要执行完，则可以调用 shutdownNow。</p><h3 id="线程池工作流程"><a href="#线程池工作流程" class="headerlink" title="线程池工作流程"></a>线程池工作流程</h3><p>线程池的主要工作流程如下图所示：</p><p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg" srcset="/img/loading.gif" alt=""></p><p>当提交一个新任务到线程池时，线程池的处理流程如下：</p><ol><li>首先线程池判断<strong>基本线程池</strong>是否已满？没满，创建一个工作线程来执行任务，否则：</li><li>其次线程池判断<strong>工作队列</strong>是否已满？没满，则将新提交的任务存储在工作队列里，否则：</li><li>最后线程池判断<strong>整个线程池</strong>是否已满？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务；</li></ol><p>源码分析部分以及下面的线程池配置部分可以参见方腾飞老师<a href="https://www.infoq.cn/article/java-threadPool" target="_blank" rel="noopener">JAVA 线程池的分析和使用</a>的博客，以及 <a href="https://snailclimb.gitee.io/javaguide/#/docs/java/Multithread/JavaConcurrencyAdvancedCommonInterviewQuestions?id=_41-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8%e7%ba%bf%e7%a8%8b%e6%b1%a0%ef%bc%9f" target="_blank" rel="noopener">JavaGuide的线程池总结</a>。</p><h3 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h3><p>合理的配置线程池，需要从以下几个角度分析任务特性：</p><ol><li>任务的性质：CPU 密集型任务，IO 密集型任务和混合型任务。</li><li>任务的优先级：高，中和低。</li><li>任务的执行时间：长，中和短。</li><li>任务的依赖性：是否依赖其他系统资源，如数据库连接。</li></ol><h1 id="Java-并发包"><a href="#Java-并发包" class="headerlink" title="Java 并发包"></a>Java 并发包</h1><p>Java 提供了不同层面的线程安全支持。在传统集合框架内部，除了 <strong>Vector、Stack、Hashtable</strong> 等同步容器，还提供了<strong>同步包装器</strong>（Synchronized Wrapper），可以调用 Collections 工具类提供的包装方法，获取一个同步的包装容器（如 Collections.synchronizedMap），但是它们都是利用<strong>粗粒度的同步方式</strong>，<strong>高并发下性能较低</strong>。</p><p>鉴于Java 集合框架的典型容器类绝大多数都不是线程安全的且性能较低，Java 提供了并发包，为高度并发需求提供了更加全面的工具支持。</p><ul><li>各种并发容器，如 ConcurrentHashMap、CopyOnWriteArrayList；</li><li>各种线程安全队列（Queue/Deque），如 ArrayBlockingQueue、SynchronousQueue；</li><li>各种有序容器的线程安全版本等；</li></ul><p>线程安全的实现方式有简单的 <strong>synchronize</strong> 方式，也有更加精细化的，比如<strong>基于分离锁实现的 ConcurrentHashMap</strong> 等并发实现等。具体选择要看开发的场景需求。</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p><strong>Java 1.6</strong> 版本的ConcurrentHashMap：</p><p>ConcurrentHashMap 由 Segment 数组结构和 HashEntry 数组结构组成。Segment 是一种可重入锁 ReentrantLock，在 ConcurrentHashMap 里扮演锁的角色，<strong>HashEntry 则用于存储键值对数据</strong>。<strong>一个 ConcurrentHashMap 里包含一个 Segment 数组</strong>，Segment 的结构和 HashMap 类似，是一种数组和链表结构， <strong>一个 Segment 里包含一个 HashEntry 数组</strong>，每个 HashEntry 是一个链表结构的元素， 每个 Segment 守护者一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁。结构如下图所示：</p><p><img src="ConcurrentHashMap.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>Java 8</strong> 和之后的版本中，ConcurrentHashMap：</p><ul><li>总体结构上，它的内部存储和 HashMap 结构非常相似，同样是大的桶（bucket）数组，内部也是的链表结构，同步的粒度要更细致一些（锁的颗粒度，是加在链表头上的）；</li><li>内部仍然有 Segment 定义，但仅仅是为了保证序列化时的兼容性，不再有任何结构上的用处；</li><li>因为不再使用 Segment，初始化操作大大简化，修改为 lazy-load 形式，这样可以有效避免初始开销；</li><li>数据存储利用 volatile 来保证可见性；</li><li>使用 CAS 等操作，在特定场景进行无锁并发操作；</li><li>使用 Unsafe、LongAdder 之类底层手段，进行极端情况的优化。</li></ul><h2 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h2><p>队列是非常重要的数据结构，日常开发中很多线程间数据传递都要依赖于它，Executor 框架提供的各种线程池，同样无法离开队列。</p><p>实现一个线程安全的队列有两种实现方式：一种是使用阻塞算法，另一种是使用非阻塞算法。使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现，而非阻塞的实现方式则可以使用循环 CAS 的方式来实现。线程安全队列 ConcurrentLinkedQueue 是使用非阻塞的方式来实现的。</p><h3 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h3><h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><p>对于 ConcurrentLinkedQueue 的方法实现可以参见<a href="https://juejin.im/post/5aeeae756fb9a07ab11112af#heading-0" target="_blank" rel="noopener">并发容器之 ConcurrentLinkedQueue</a> 这篇文章。</p><ul><li><p>Concurrent 类型基于 <strong>lock-free</strong>，在常见的多线程访问场景，一般可以<strong>提供较高吞吐量</strong>；</p></li><li><p><strong>Concurrent</strong> 类型没有类似 <strong>CopyOnWrite</strong> 之类容器相对较重的<strong>修改开销</strong>；</p></li><li><p>Concurrent 往往提供了<strong>较低的遍历一致性</strong>。可以这样理解所谓的弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历；</p></li><li><p>同步容器 ”<strong>fail-fast</strong>”：检测到容器在遍历过程中发生了修改，则抛出 ConcurrentModificationException，不再继续遍历；</p></li><li><p>弱一致性的另外一个体现是，<strong>size 等操作准确性是有限的</strong>，未必是 100% 准确；</p></li><li><p>与此同时，<strong>读取的性能</strong>具有一定的不确定性；</p></li></ul><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p>对于阻塞队列，更加详细的介绍和分析参见 <a href="https://www.infoq.cn/article/java-blocking-queue" target="_blank" rel="noopener">Java 中的阻塞队列</a> 。</p><h2 id="CopyOnWrite"><a href="#CopyOnWrite" class="headerlink" title="CopyOnWrite"></a>CopyOnWrite</h2><p>CopyOnWrite 的原理是：任何修改操作，如 add、set、remove，都会拷贝原数组，修改后替换原来的数组，通过这种防御性的方式，实现另类的线程安全。适合<strong>读多写少的操作</strong>，不然修改的开销是比较高的。</p><p>这样做的好处在于，可以在并发的场景下对容器进行”读操作”而不需要”加锁”，从而达到读写分离的目的。从JDK 1.5 开始 Java 并发包里提供了两个使用 CopyOnWrite 机制实现的并发容器 ，分别是CopyOnWriteArrayList和CopyOnWriteArraySet 。CopyOnWriteArraySet 是通过包装了 CopyOnWriteArrayList 来实现的。</p><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>CopyOnWriteArrayList 经常被用于“读多写少”的并发场景，因为 CopyOnWriteArrayList 无需任何同步措施，增强了读的性能。Java 中遍历非线程安全的 List（如：ArrayList和 LinkedList）的时候，若中途有别的线程对List容器进行修改，会抛出ConcurrentModificationException异常。CopyOnWriteArrayList由于其”读写分离”，遍历和修改操作分别作用在不同的List容器，所以在使用迭代器遍历的时候，不会抛出异常。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>CopyOnWriteArrayList每次执行写操作都会将原容器进行拷贝了一份，数据量大的时候，内存会存在较大的压力，可能会引起频繁Full GC（ZGC没有使用Full GC）；<ul><li>比如对象占用的内存200M左右，再写入100M数据进去，内存就会多占用300M；</li></ul></li><li>CopyOnWriteArrayList 由于实现的原因，写和读分别作用在不同新老容器上，写操作执行过程中，读不会阻塞，但读取到的却是老容器的数据；</li></ul><h4 id="操作分析"><a href="#操作分析" class="headerlink" title="操作分析"></a>操作分析</h4><p>CopyOnWriteArrayList 的源码分析可以参见<a href="https://redspider.gitbook.io/concurrent/di-san-pian-jdk-gong-ju-pian/16#16-2-copyonwritearraylist" target="_blank" rel="noopener">代码分析</a>。</p><ul><li>CopyOnWriteArrayList 的 add 操作是先把原容器进行copy，然后在新的副本上进行“写操作”，最后再切换引用，在此过程中是加了锁的；</li><li>remove 操作的逻辑是将要删除元素之外的其他元素拷贝到新的副本中，然后切换引用，再将原容器的引用指向新的副本中，因为 remove 操作也是写操作，所以也是要加锁的；</li><li>get 操作是“读操作”，没有加锁，直接读取；</li></ul><h2 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h2><p> Java 并发包提供了<strong>比 synchronized 更加高级的各种同步结构</strong>，包括 CountDownLatch、CyclicBarrier、Semaphore 等，可以实现更加丰富的多线程操作，比如利用 Semaphore 作为资源控制器，限制同时进行工作的线程数量；</p><ul><li><p>Semaphore，Java 版本的<strong>信号量的实现</strong>。</p></li><li><p>CountDownLatch，也叫做闭锁，<strong>允许一个或多个线程等待某些操作完成后再执行</strong>；</p></li><li><p>CyclicBarrier，一种辅助性的同步结构，<strong>允许多个线程等待到达某个屏障</strong>；</p></li></ul><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Java 提供了经典信号量（Semaphore）的实现，它通过控制一定数量的允许（permit）的方式，来达到限制通用资源访问的目的。类比如下场景：在车站、机场等出租车时，当很多空出租车就位时，为防止过度拥挤，调度员指挥排队等待坐车的队伍一次进来 5 个人上车，等这 5 个人坐车出发，再放进去下一批，这和 Semaphore 的工作原理有些类似。Semaphore 可以理解为<strong>计数器</strong>，其<strong>基本逻辑基于 acquire/release</strong>，没有太复杂的同步逻辑。</p><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p><a href="https://www.jianshu.com/p/03f5d1b02bb8" target="_blank" rel="noopener">参考：白话Java并发工具类</a></p><p>在多线程协作完成业务功能时，有时候需要等待其他多个线程完成任务之后，主线程才能继续往下执行业务功能，在这种的业务场景下，通常可以使用Thread类的join方法，让主线程等待被join的线程执行完之后，主线程才能继续往下执行。当然，使用线程间消息通信机制也可以完成。java并发工具类中提供了类似“倒计时”这样的工具类，可以十分方便的完成这种业务场景。</p><p>CountDownLatch内部会维护一个初始值为线程数量的计数器，主线程执行await方法，如果计数器大于0，则阻塞等待。当一个线程完成任务后，计数器值减1。当计数器为0时，表示所有的线程已经完成任务，等待的主线程被唤醒继续执行。</p><h4 id="CountDownLatch主要方法"><a href="#CountDownLatch主要方法" class="headerlink" title="CountDownLatch主要方法"></a>CountDownLatch主要方法</h4><ul><li>await() throws InterruptedException：调用该方法的线程等到构造方法传入的N减到0的时候，才能继续往下执行；</li><li>await(long timeout, TimeUnit unit)：与上面的await方法功能一致，加上时间限制，调用该方法的线程等到指定的timeout时间后，不管N是否减至为0，都会继续往下执行；</li><li>countDown()：使CountDownLatch初始值N减1；</li><li>long getCount()：获取当前CountDownLatch维护的值；</li></ul><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>CyclicBarrier也是一种多线程并发控制的实用工具，和CountDownLatch一样具有等待计数的功能。CyclicBarrier在使用一次后，下面依然有效，可以继续当做计数器使用，这是与CountDownLatch的区别之一。</p><h3 id="CountDownLatch-与-CyclicBarrier-异同"><a href="#CountDownLatch-与-CyclicBarrier-异同" class="headerlink" title="CountDownLatch 与 CyclicBarrier 异同"></a>CountDownLatch 与 CyclicBarrier 异同</h3><ul><li>CountDownLatch 是不可以重置的，所以<strong>无法重用</strong>；而 CyclicBarrier 则没有这种限制，<strong>可以重用</strong>；</li><li>CountDownLatch 的基本操作组合是 <strong>countDown/await</strong>。调用 await 的线程阻塞等待 countDown 足够的次数，不管是在一个线程还是多个线程里 countDown，只要次数足够即可。<strong>CountDownLatch 操作的是事件</strong>；</li><li>CyclicBarrier 的基本操作组合，则就是 <strong>await</strong>，当所有的伙伴（parties）<strong>都调用了 await</strong>，才会继续进行任务，并<strong>自动进行重置</strong>。注意，正常情况下，CyclicBarrier 的重置都是自动发生的，如果调用 reset 方法，但还有线程在等待，就会导致等待线程被打扰，抛出 BrokenBarrierException 异常。<strong>CyclicBarrier 侧重点是线程，而不是调用事件</strong>，它的典型应用场景是<strong>用来等待并发线程结束</strong>。</li></ul><h3 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h3><p>Java 并发类库还提供了Phaser，功能与 CountDownLatch 很接近，但是它<strong>允许线程动态地注册到 Phaser 上面</strong>，而 CountDownLatch 显然是不能动态设置的。Phaser 的设计初衷是，实现多个线程类似步骤、阶段场景的协调，线程注册等待屏障条件触发，进而协调彼此间行动。</p><h1 id="CAS-与原子操作"><a href="#CAS-与原子操作" class="headerlink" title="CAS 与原子操作"></a>CAS 与原子操作</h1><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁是一种特定的程序状态，实体之间由于循环依赖导致彼此一直处于等待之中，没有任何个体可以继续前进。死锁不仅仅是在线程之间会发生，存在资源独占的进程之间同样也可能出现死锁。通常来说，大多关注多线程场景中的死锁。两个或多个线程之间，由于互相持有对方需要的锁，而永久处于阻塞的状态。</p><p>定位死锁最常见的方式就是利用 jstack 等工具获取线程栈，然后定位互相之间的依赖关系，进而找到死锁。如果是比较明显的死锁，往往 jstack 等就能直接定位，类似 JConsole 甚至可以在图形界面进行有限的死锁检测。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLockSample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;  <span class="hljs-keyword">private</span> String first;  <span class="hljs-keyword">private</span> String second;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DeadLockSample</span><span class="hljs-params">(String name, String first, String second)</span> </span>&#123;      <span class="hljs-keyword">super</span>(name);      <span class="hljs-keyword">this</span>.first = first;      <span class="hljs-keyword">this</span>.second = second;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">synchronized</span> (first) &#123;          System.out.println(<span class="hljs-keyword">this</span>.getName() + <span class="hljs-string">" obtained: "</span> + first);          <span class="hljs-keyword">try</span> &#123;              Thread.sleep(<span class="hljs-number">1000L</span>);              <span class="hljs-keyword">synchronized</span> (second) &#123;                  System.out.println(<span class="hljs-keyword">this</span>.getName() + <span class="hljs-string">" obtained: "</span> + second);              &#125;          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;              <span class="hljs-comment">// Do nothing</span>          &#125;      &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;      String lockA = <span class="hljs-string">"lockA"</span>;      String lockB = <span class="hljs-string">"lockB"</span>;      DeadLockSample t1 = <span class="hljs-keyword">new</span> DeadLockSample(<span class="hljs-string">"Thread1"</span>, lockA, lockB);      DeadLockSample t2 = <span class="hljs-keyword">new</span> DeadLockSample(<span class="hljs-string">"Thread2"</span>, lockB, lockA);      t1.start();      t2.start();      t1.join();      t2.join();  &#125;&#125;</code></pre><h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h2><p>锁可以从不同的角度分类。其中，乐观锁和悲观锁是一种分类方式。</p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁就是常说的锁。悲观锁总是认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁又称为“无锁”。乐观锁总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。而一旦多个线程发生冲突，乐观锁通常使用 CAS 来保证线程执行的安全性。由于无锁操作中没有锁的存在，因此不可能出现死锁的情况。</p><p>悲观锁多用于”<strong>写多读少</strong>“的环境，避免频繁失败和重试影响性能。乐观锁多用于“<strong>读多写少</strong>“的环境，避免频繁加锁影响性能。</p><h2 id="CAS-定义"><a href="#CAS-定义" class="headerlink" title="CAS 定义"></a>CAS 定义</h2><p><strong>比较并交换(compare and swap, CAS)</strong>，是原子操作的一种，可用于在多线程编程中<strong>实现不被打断的数据交换操作</strong>，从而<strong>避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题</strong>。 该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。</p><ul><li><strong>记录下</strong>某块内存中的旧值；</li><li>对旧值<strong>进行一系列的操作</strong>后得到新值；</li><li>通过CAS操作将新值与旧值进行交换：<ul><li>如果这块内存的值在这期间内没被修改过，则旧值会与内存中的数据相同，这时CAS操作将会成功执行，使内存中的数据变为新值；</li><li>如果内存中的值在这期间内被修改过，则一般来说旧值会与内存中的数据不同，这时CAS操作将会失败，新值将不会被写入内存。</li></ul></li></ul><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cas</span><span class="hljs-params">(<span class="hljs-keyword">long</span> *addr, <span class="hljs-keyword">long</span> old, <span class="hljs-keyword">long</span> <span class="hljs-keyword">new</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">/* Executes atomically. */</span>    <span class="hljs-keyword">if</span>(*addr != old)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    *addr = <span class="hljs-keyword">new</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre><h3 id="Java-实现CAS的原理"><a href="#Java-实现CAS的原理" class="headerlink" title="Java 实现CAS的原理"></a>Java 实现CAS的原理</h3><p>CAS 是一种原子操作。在 Java 中，如果一个方法是native的，那 Java 就不负责具体实现它，而是交给底层的JVM使用 C 或者 C++ 实现。在 Java 中，Unsafe 类里面是一些native方法，其中有几个关于 CAS。这些方法都是都是public native的。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapObject</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset,Object expected, Object x)</span></span>;<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapInt</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset,<span class="hljs-keyword">int</span> expected,<span class="hljs-keyword">int</span> x)</span></span>;<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapLong</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset,<span class="hljs-keyword">long</span> expected,<span class="hljs-keyword">long</span> x)</span></span>;</code></pre><p>Unsafe 中对 CAS 的实现使用 C++，它的具体实现和操作系统、CPU都有关系。</p><p>Linux的 x86 下主要通过cmpxchgl这个指令在 CPU 级完成CAS操作，但在多处理器情况下必须使用lock指令加锁来完成。</p><p>Unsafe类里面还有其它方法用于不同的用途。比如支持线程挂起和恢复的park和unpark， LockSupport类底层就是调用了这两个方法。还有支持反射操作的 allocateInstance() 方法。</p><h3 id="CAS-实现原子操作的三个问题"><a href="#CAS-实现原子操作的三个问题" class="headerlink" title="CAS 实现原子操作的三个问题"></a>CAS 实现原子操作的三个问题</h3><h4 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h4><p>ABA问题，就是一个值原来是A，变成了B，又变回了A。这个时候使用CAS是检查不出变化的，但实际上却被更新了两次。</p><p>ABA问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。JDK 1.5 开始，JDK 的 atomic 包里提供了一个类AtomicStampedReference 类来解决ABA问题。这个类的 compareAndSet 方法的作用是：</p><ul><li>首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志；</li><li>如果二者都相等，才使用 CAS 设置为新的值和标志。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(V   expectedReference,</span></span><span class="hljs-function"><span class="hljs-params">                             V   newReference,</span></span><span class="hljs-function"><span class="hljs-params">                             <span class="hljs-keyword">int</span> expectedStamp,</span></span><span class="hljs-function"><span class="hljs-params">                             <span class="hljs-keyword">int</span> newStamp)</span> </span>&#123;    Pair&lt;V&gt; current = pair;    <span class="hljs-keyword">return</span>        expectedReference == current.reference &amp;&amp;        expectedStamp == current.stamp &amp;&amp;        ((newReference == current.reference &amp;&amp;          newStamp == current.stamp) ||         casPair(current, Pair.of(newReference, newStamp)));&#125;</code></pre><h4 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h4><p>CAS多与自旋结合。如果 CAS 自旋长时间不成功，CPU 资源的开销很大。</p><p>解决思路是让 JVM 支持处理器提供的 <strong>pause 指令</strong>。pause 指令能让自旋失败时 CPU 睡眠一小段时间再继续自旋，从而使得读操作的频率低很多，为解决内存顺序冲突而导致的CPU流水线重排的代价也会小很多。</p><h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>竞争锁的失败的线程，并不会真实的在操作系统层面挂起等待，JVM 会让线程做几个空循环（基于预测在不久的将来就能获得），经过若干次循环后，如果可以获得锁，那么进入临界区，如果还不能获得锁，才会真实的将线程在操作系统层面进行挂起。</p><p>自旋锁适用场景：自旋锁可以减少线程的阻塞，对于锁竞争不激烈，且占用锁时间非常短的代码块来说，性能有较大的提升，因为自旋的消耗会小于线程阻塞挂起操作的消耗。反之，如果锁的竞争激烈，或者持锁的线程需要长时间占用锁执行同步块，就不适合使用自旋锁，因为自旋锁在获取锁前一直都是占用 CPU 做无用功，线程自旋的消耗大于线程阻塞挂起操作的消耗，造成 CPU 的浪费。</p><h4 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h4><p>CAS可以保证单个共享变量的原子操作，对于多个共享变量，CAS无法保证原子性。</p><ul><li><p>JDK 1.5 开始提供了 AtomicReference 类，保证对象之间的原子性。所以可以把多个（共享）变量封装进一个对象，然后通过 AtomicReference 类保证引用对象之间的原子性。</p></li><li><p>使用锁：锁内的临界区代码可以保证只有当前线程能操作；</p></li></ul><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h4 id="synchronized-和-volatile-的区别"><a href="#synchronized-和-volatile-的区别" class="headerlink" title="synchronized 和 volatile 的区别"></a>synchronized 和 volatile 的区别</h4><ul><li>synchronized 关键字解决的是<strong>多个线程之间访问资源的同步性</strong>；</li><li><strong>volatile 关键字</strong>是<strong>线程同步</strong>的<strong>轻量级</strong>实现，因为它不会引起线程上下文的切换和调度，所以比 synchronized 的<strong>使用和执行成本会更低</strong>，<strong>性能</strong>比 synchronized 好；</li><li>volatile 只能用于<strong>变量</strong>，synchronized 关键字可以修饰<strong>方法以及代码块</strong>；</li><li>多线程访问 volatile 关键字<strong>不会发生阻塞</strong>，synchronized 关键字<strong>可能会发生阻塞</strong>；</li><li>volatile 关键字能保证<strong>数据的可见性</strong>，但<strong>不能保证数据的原子性</strong>，synchronized 关键字两者都能保证。</li></ul><h4 id="sleep-和-wait-方法异同"><a href="#sleep-和-wait-方法异同" class="headerlink" title="sleep() 和 wait() 方法异同"></a>sleep() 和 wait() 方法异同</h4><ul><li>都可以暂停线程的执行；</li><li>最主要的区别在于：<strong>sleep() 方法没有释放锁，而 wait() 方法释放了锁</strong>； </li><li>wait() 通常被用于<strong>线程间交互/通信</strong>，sleep() 通常被用于<strong>暂停执行</strong>；</li><li>wait() 方法被调用后，线程<strong>不会自动苏醒</strong>，需要别的线程调用同一个对象上的 <strong>notify() 或者 notifyAll() 方法</strong>；sleep() 方法执行完成后，线程会<strong>自动苏醒</strong>。或者可以使用 <strong>wait(long timeout) 超时后线程会自动苏醒</strong>；</li></ul><h4 id="start-方法会执行-run-，为什么不直接调用-run-方法"><a href="#start-方法会执行-run-，为什么不直接调用-run-方法" class="headerlink" title="start() 方法会执行 run()，为什么不直接调用 run() 方法"></a>start() 方法会执行 run()，为什么不直接调用 run() 方法</h4><ul><li>new 一个 Thread，线程进入了新建状态；</li><li>调用 start() 方法，会启动一个线程并使线程进入了<strong>就绪状态</strong>，当分配到时间片后就可以开始运行；<ul><li>start() 会执行线程的相应<strong>准备工作</strong>，然后自动执行 run() 方法的内容，这是真正的多线程工作；</li></ul></li><li>直接执行 run() 方法，会将 run() 其当成 main 线程下的一个<strong>普通方法</strong>去执行，并不会在某个线程中执行它，所以这并<strong>不是多线程工作</strong>；</li></ul><p><strong>总结： 调用 start() 方法方可启动线程并使线程进入就绪状态，而 run() 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</strong></p><h4 id="AtomicInteger-底层实现原理"><a href="#AtomicInteger-底层实现原理" class="headerlink" title="AtomicInteger 底层实现原理"></a>AtomicInteger 底层实现原理</h4><p>AtomicIntger 是对 int 类型的一个封装，提供原子性的访问和更新操作，其原子性操作的实现是基于 CAS（compare-and-swap）技术。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>JDK1.8 源码</p><p>Java 并发编程实战</p><p><a href="https://betterzero.net/2020/07/22/Java%20%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/%3Chttps://time.geekbang.org/column/intro/100006701%3E/">极客时间 - Java精讲</a></p><p><a href="https://www.infoq.cn/profile/1277812/publish" target="_blank" rel="noopener">方腾飞InfoQ并发系列文章</a></p><p><a href="https://redspider.gitbook.io/concurrent/readme" target="_blank" rel="noopener">深入浅出Java多线程</a></p><p><a href="http://www.51gjie.com/java/717.html" target="_blank" rel="noopener">javaschool</a></p><p><a href="https://cloud.tencent.com/developer/article/1497826" target="_blank" rel="noopener">一次Java线程池误用引发的线上血案和总结</a> </p><p><a href="https://blog.csdn.net/u014209205/article/details/80598209" target="_blank" rel="noopener">JAVA Future类详解</a></p><p><a href="https://www.infoq.cn/article/ftf-java-volatile/" target="_blank" rel="noopener">聊聊并发（一）—深入分析 Volatile 的实现原理</a></p><p><a href="https://blog.csdn.net/a525390802/article/details/80509457" target="_blank" rel="noopener">JVM之内存模型JMM中本地内存的理解</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java OOP一些理解</title>
    <link href="/2020/07/22/Java%20OOP%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <url>/2020/07/22/Java%20OOP%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>文章介绍面向对象编程的基础概念，主要关于其特性、优势，以及 OOP 的使用方法与误区。</p><a id="more"></a><h1 id="面向过程编程及面向过程编程语言"><a href="#面向过程编程及面向过程编程语言" class="headerlink" title="面向过程编程及面向过程编程语言"></a>面向过程编程及面向过程编程语言</h1><p>面向过程编程<strong>以过程（或方法）作为组织代码的基本单元</strong>。它最主要的特点就是<strong>数据和方法相分离</strong>。面向过程编程语言最大的特点就是不支持丰富的<strong>面向对象编程特性</strong>，比如继承、多态、封装。</p><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>面向对象编程<strong>以类为组织代码的基本单元</strong>，一般来说，它具有以下优势。</p><ul><li>对于<strong>大规模复杂的程序的开发</strong>，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程更能应对这种复杂类型的程序开发；</li><li>面向对象编程具有更加<strong>丰富的特性</strong>，如封装、抽象、继承、多态。代码易扩展、易复用、易维护；</li></ul><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="访问权限控制"><a href="#访问权限控制" class="headerlink" title="访问权限控制"></a>访问权限控制</h3><p>封装主要关于<strong>信息隐藏、数据保护</strong>。编程语言需要提供<strong>访问权限控制</strong>这样的语法机制来支持。Java 使用访问控制符来保护对<strong>类、变量、方法和构造方法</strong>的访问。Java 支持 4 种不同的访问权限：</p><ul><li><strong>private</strong> : 访问权限限制的最窄的修饰符。同一类内可见。使用对象：变量、方法。 <strong>不能修饰类（外部类）</strong></li><li><strong>default</strong> (默认）: 通常称为“默认访问权限“或者“包访问权限”，不使用任何修饰符。同一包内可见。使用对象：类、接口、变量、方法。</li><li><strong>protected</strong> : 介于public 和 private 之间的一种访问修饰符。同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>不能修饰类（外部类）</strong>。</li><li><strong>public</strong> : 访问限制最宽的修饰符。允许跨包访问，所有类可见。使用对象：类、接口、变量、方法</li></ul><h3 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h3><p>如果对类中属性的访问不做限制，任何代码都可以访问、修改类中的属性，虽然看起来更加灵活，但是<strong>过度灵活也意味着不可控</strong>。属性可以随意被修改，修改逻辑可能散落在代码中的各个角落，影响代码的<strong>可读性、可维护性</strong>。</p><p>通过有限的方法，暴露必要的操作，能<strong>提高类的易用性</strong>。如果把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就要对业务细节有足够的了解。这对于调用者来说也是一种负担。如果将属性<strong>封装</strong>起来，只暴露必要的<strong>方法</strong>给调用者使用，调用者就不需要了解太多的业务细节，可以降低使用成本，减少用错的概率。</p><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p><strong>抽象关注的是如何隐藏方法的具体实现</strong>，让调用者只需要关心方法提供了哪些功能，不需要知道实现细节。</p><p>面向对象编程常常借助编程语言提供的<strong>接口</strong>或者<strong>抽象类</strong>这两种语法机制实现抽象这一特性。</p><p><strong>抽象有时候会被排除在面向对象特性之外</strong>。因为抽象是一个非常通用的设计思想，不单单用在面向对象编程中，也可以用来指导架构设计等。这个特性也并不需要编程语言提供特殊的语法机制来支持，只需要提供“函数”这一语法机制，就可以实现抽象特性。</p><h3 id="抽象的意义"><a href="#抽象的意义" class="headerlink" title="抽象的意义"></a>抽象的意义</h3><p>面对复杂的系统，人脑能承受的信息是有限的，所以要忽略一些非关键的实现细节。抽象作为一种<strong>只关注功能点不关注实现</strong>的设计思路，可以过滤掉非必要的信息。</p><p>抽象作为一个非常宽泛的<strong>设计思想</strong>，在代码设计中起到重要的指导作用。很多设计原则都体现了抽象这种设计思想，比如<strong>基于接口而非实现编程</strong>、<strong>开闭原则</strong>（对扩展开放、对修改关闭）、<strong>代码解耦</strong>（降低代码的耦合性）等。</p><p>换一个角度考虑，定义类的方法的时候，不要暴露太多的实现细节，以保证在修改方法的实现的时候，不用再修改其定义。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承用来表示<strong>类之间的 is-a 关系</strong>，比如猫是一种哺乳动物。继承可以分为两种模式，<strong>单继承和多继承</strong>。</p><p>Java 使用 <strong>extends</strong> 关键字来实现继承，C++ 使用冒号（class B : public A），Python 使用 paraentheses()。有些编程语言只支持单继承，不支持多重继承，比如 Java。有些编程语言两种方式都支持，比如 C++、Python。</p><h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><p>多重继承存在钻石问题，即菱形继承。假设类 B 和类 C 继承自类 A，都重写了类 A 中的同一个方法，而类 D 同时继承了类 B 和类 C，那么此时类 D 会继承 B、C 的方法，那对于 B、C 重写的 A 中的方法，类 D 继承哪一个就无法确定。</p><p>Java支持多接口实现，因为接口中的方法是抽象的，即便一个类实现了多个接口，且这些接口中存在同名方法，但在实现接口的时候，这个同名方法需要由这个实现类自己来实现，所以避免了二义性的问题。</p><h3 id="继承的意义"><a href="#继承的意义" class="headerlink" title="继承的意义"></a>继承的意义</h3><p>继承最大的优点是<strong>代码复用</strong>。假如两个类有一些相同的属性和方法，就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。两个子类可以重用父类中的代码。不过，通过其他方式，比如利用<strong>组合关系</strong>而不是<strong>继承关系</strong>，也可以达到代码复用的目的。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是同一个行为具有多个不同表现形式或形态的能力，同一个接口，使用不同的实例而执行不同操作。<strong>子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现</strong>。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="继承-方法重写"><a href="#继承-方法重写" class="headerlink" title="继承 + 方法重写"></a>继承 + 方法重写</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicArray</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> capacity = DEFAULT_CAPACITY;  <span class="hljs-keyword">protected</span> Integer[] elements = <span class="hljs-keyword">new</span> Integer[DEFAULT_CAPACITY];    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.size; &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123; <span class="hljs-keyword">return</span> elements[index];&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Integer e)</span> </span>&#123;    ensureCapacity();    elements[size++] = e;  &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacity</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 如果数组满了就扩容...</span>  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortedDynamicArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DynamicArray</span> </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Integer e)</span> </span>&#123;    ensureCapacity();    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">for</span> (i = size-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; --i) &#123; <span class="hljs-comment">//保证数组中的数据有序</span>      <span class="hljs-keyword">if</span> (elements[i] &gt; e) &#123;        elements[i+<span class="hljs-number">1</span>] = elements[i];      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">break</span>;      &#125;    &#125;    elements[i+<span class="hljs-number">1</span>] = e;    ++size;  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(DynamicArray dynamicArray)</span> </span>&#123;    dynamicArray.add(<span class="hljs-number">5</span>);    dynamicArray.add(<span class="hljs-number">1</span>);    dynamicArray.add(<span class="hljs-number">3</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dynamicArray.size(); ++i) &#123;      System.out.println(dynamicArray.get(i));    &#125;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;    DynamicArray dynamicArray = <span class="hljs-keyword">new</span> SortedDynamicArray();    test(dynamicArray); <span class="hljs-comment">// 打印结果：1、3、5</span>  &#125;&#125;</code></pre><p>多态需要<strong>编程语言提供特殊的语法机制</strong>来实现。在上面的例子中，用到了三个语法机制来实现多态。</p><ul><li><strong>父类对象可以引用子类对象</strong>。可以将 SortedDynamicArray 传递给 DynamicArray。</li><li><strong>继承</strong>。SortedDynamicArray 继承了 DynamicArray，才能将 SortedDyamicArray 传递给 DynamicArray；</li><li><strong>子类可以重写（override）父类中的方法</strong>。SortedDyamicArray 重写了 DynamicArray 中的 add() 方法。</li></ul><p>这三种语法机制配合在一起，实现了在 test() 方法中，子类 SortedDyamicArray 替换父类 DynamicArray，执行子类 SortedDyamicArray 的 add() 方法，实现了多态特性。</p><p>对于多态的实现方式，除了利用<strong>继承加方法重写</strong>这种方式外，还有其他两种比较常见的的实现方式，一个是利用<strong>接口类语法</strong>，另一个是利用 <strong>duck-typing 语法</strong>。不过，并不是每种编程语言都支持接口类或者 duck-typing 这两种语法机制，比如 C++ 不支持接口类语法，而 duck-typing 只有一些动态语言才支持，比如 Python、JavaScript 等。</p><h4 id="接口类语法"><a href="#接口类语法" class="headerlink" title="接口类语法"></a>接口类语法</h4><p>Iterator 是一个接口类，定义了一个可以遍历集合数据的迭代器。Array 和 LinkedList 都实现了接口类 Iterator。通过<strong>传递不同类型的实现类（Array、LinkedList）到 print(Iterator iterator) 函数中，支持动态的调用不同的 next()、hasNext() 实现</strong>。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span> </span>&#123;  <span class="hljs-function">String <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;  <span class="hljs-function">String <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;  <span class="hljs-function">String <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Array</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span> </span>&#123;  <span class="hljs-keyword">private</span> String[] data;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-comment">// 省略其它方法...</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span> </span>&#123;  <span class="hljs-keyword">private</span> LinkedListNode head;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-comment">// 省略其它方法... </span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Iterator iterator)</span> </span>&#123;    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;      System.out.println(iterator.next());    &#125;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Iterator arrayIterator = <span class="hljs-keyword">new</span> Array();    print(arrayIterator);        Iterator linkedListIterator = <span class="hljs-keyword">new</span> LinkedList();    print(linkedListIterator);  &#125;&#125;</code></pre><p>Java 通过<strong>继承实现多态特性</strong>，必须要求两个<strong>类之间有继承关系</strong>。通过<strong>接口实现多态特性</strong>，<strong>类必须实现对应的接口</strong>。</p><h3 id="多态的意义"><a href="#多态的意义" class="headerlink" title="多态的意义"></a>多态的意义</h3><p>多态特性能<strong>提高代码的可扩展性和复用性</strong>。利用多态，一个 print() 函数可以实现遍历打印不同类型集合的数据。当需要再增加一种要遍历打印的类型的时候，比如 HashMap，只需让 HashMap 实现 Iterator 接口，重新实现自己的 hasNext()、next() 等方法就可以了，不需要改动 print() 函数的代码，提高了代码的可扩展性。</p><p>多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等。</p><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="违反OOP风格的代码设计"><a href="#违反OOP风格的代码设计" class="headerlink" title="违反OOP风格的代码设计"></a>违反OOP风格的代码设计</h2><h3 id="滥用-getter、setter-方法"><a href="#滥用-getter、setter-方法" class="headerlink" title="滥用 getter、setter 方法"></a>滥用 getter、setter 方法</h3><ul><li>设计实现类的时候，除非真的需要，否则尽量不要给属性定义 setter 方法；</li><li>尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器，也要防范集合内部数据被修改的风险。</li></ul><h3 id="Constants-类、Utils-类的设计问题"><a href="#Constants-类、Utils-类的设计问题" class="headerlink" title="Constants 类、Utils 类的设计问题"></a>Constants 类、Utils 类的设计问题</h3><ul><li>对于这两种类的设计，尽量能做到职责单一，定义一些细化的小类，比如 RedisConstants、FileUtils，而不是定义一个大而全的 Constants 类、Utils 类；</li><li>如果能将这些类中的属性和方法，划分归并到其他业务类中，能极大地提高类的内聚性和代码的可复用性。</li></ul><h2 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h2><p>面向对象编程中，抽象类和接口是两个经常使用的语法概念，是面向对象四大特性以及很多设计模式、设计思想、设计原则编程实现的基础，例如：</p><ul><li>使用<strong>接口来实现面向对象的抽象特性、多态特性</strong>和<strong>基于接口而非实现</strong>的设计原则；</li><li>使用<strong>抽象类来实现面向对象的继承特性和模板设计模式</strong>等。</li></ul><p>继承关系是 is-a 的关系，接口表示 has-a 关系，表示<strong>具有某些功能</strong>。接口，有一个更形象的叫法：<strong>协议</strong>。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul><li>抽象类<strong>不允许被实例化</strong>，只能被<strong>继承</strong>；</li><li>抽象类可以包含属性和方法。抽象类中的成员变量可以是各种类型的，接口中的成员变量只能是 <strong>public static final</strong> 类型的；<ul><li>抽象类中的方法可以有方法体；</li><li>也可以不包含方法体。不包含代码实现的方法叫作<strong>抽象方法</strong>；</li></ul></li><li>子类继承抽象类，<strong>必须实现抽象类中的所有抽象方法</strong>。</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li><p>接口是隐式抽象的，声明接口时不必使用<strong>abstract</strong>关键字；</p></li><li><p>接口没有构造方法，接口不能实例化；</p></li><li><p>接口支持多继承；</p></li><li><p>接口中<strong>没有成员变量</strong>，<strong>只有方法声明，没有方法实现</strong>，实现接口的类<strong>必须实现接口中的所有方法</strong>；</p><ul><li>接口不包含任何<strong>非常量成员</strong>，任何 field 都是隐含着 public static final 的意义；</li></ul></li><li><p>接口没有<strong>非静态方法实现</strong>，要么是隐式的抽象方法（声明时不需要<strong>abstract</strong>关键字），要么是静态方法；</p><ul><li>JDK 1.8版本及以上，接口里可以有静态方法和方法体了，只有静态方法可以在接口中实现</li></ul></li></ul><h3 id="抽象类-OR-接口"><a href="#抽象类-OR-接口" class="headerlink" title="抽象类 OR 接口"></a>抽象类 OR 接口</h3><ul><li><strong>抽象类是一种自下而上的设计思路</strong>，先有子类的代码重复，然后抽象成上层的父类（抽象类）；</li><li>如果表示 <strong>is-a</strong> 的关系，为了解决<strong>代码复用</strong>的问题，使用<strong>抽象类</strong>；</li><li>接口是一种<strong>自上而下的设计思路</strong>，一般是先设计接口，再考虑具体的实现；</li><li>如果表示 <strong>has-a</strong> 关系，为了解决<strong>抽象</strong>而非代码复用的问题，使用<strong>接口</strong>；</li></ul><h2 id="基于接口而非实现编程"><a href="#基于接口而非实现编程" class="headerlink" title="基于接口而非实现编程"></a>基于接口而非实现编程</h2><p>“基于接口而非实现编程”，也可以表达为“<strong>基于抽象而非实现编程</strong>”。软件开发时一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。</p><p>本质上看，<strong>“接口”是一组“协议”或者“约定”，是功能提供者给使用者的一个“功能列表”</strong>。“接口”在不同的应用场景下会有不同的解读，比如服务端与客户端之间的“接口”，类库提供的“接口”，甚至是一组通信的协议都可以叫作“接口”。落实到具体的编码，“基于接口而非实现编程”原则中的“接口”，可以理解为编程语言中的<strong>接口或者抽象类</strong>。</p><p>这条原则能有效地提高代码质量。可以<strong>将接口和实现相分离，封装不稳定的实现，暴露稳定的接口</strong>。上游系统面向接口而非实现编程，<strong>不依赖不稳定的实现细节</strong>，当实现发生变化时，上游系统的代码基本上不需要改动，以此<strong>降低耦合性，提高扩展性</strong>。</p><h3 id="应用原则"><a href="#应用原则" class="headerlink" title="应用原则"></a>应用原则</h3><p>编写代码时遵从基于接口而非实现编程的原则：</p><ul><li><strong>函数的命名不能暴露任何实现细节</strong>；</li><li><strong>封装具体的实现细节</strong>；</li><li><strong>为实现类定义抽象的接口</strong>。具体的实现类依赖统一的接口定义，使用者依赖接口而非具体的实现类来编程。</li></ul><p>越不稳定的系统，越要在代码的扩展性、维护性上下功夫。不过，如果业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，没有必要为其设计接口，也没有必要基于接口编程，那么直接使用实现类就可以了。</p><h2 id="组合优于继承"><a href="#组合优于继承" class="headerlink" title="组合优于继承"></a>组合优于继承</h2><h3 id="继承的缺点"><a href="#继承的缺点" class="headerlink" title="继承的缺点"></a>继承的缺点</h3><p>继承层次越来越深，会使得继承关系会越来越复杂，引发以下问题：</p><ul><li>代码的可读性变差。因为要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码，一直追溯到最顶层父类的代码；</li><li>破坏了类的封装特性，降低可维护性。父类的实现细节暴露给子类，子类的实现依赖父类的实现，两者高度耦合。父类代码的修改会影响所有子类的逻辑。</li></ul><h3 id="组合的优势"><a href="#组合的优势" class="headerlink" title="组合的优势"></a>组合的优势</h3><p>可以利用组合（composition）、接口、委托（delegation）三个技术，解决继承存在的问题。</p><p>注：<strong>组合</strong>，java代码复用的一种方法。<strong>使用多个已有的对象组合为一个功能更加复杂强大的新对象</strong>。体现的是<strong>整体与部分、拥有的关系</strong>。因为在对象之间，各自的内部细节是不可见的，所以也说这种方式的代码复用是黑盒的。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyable</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span>；</span><span class="hljs-function">&#125;</span><span class="hljs-function"><span class="hljs-keyword">public</span> class FlyAbility implements Flyable </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//... &#125;</span>&#125;<span class="hljs-comment">//省略Tweetable/TweetAbility/EggLayable/EggLayAbility</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ostrich</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Tweetable</span>, <span class="hljs-title">EggLayable</span> </span>&#123;<span class="hljs-comment">//鸵鸟</span>  <span class="hljs-keyword">private</span> TweetAbility tweetAbility = <span class="hljs-keyword">new</span> TweetAbility(); <span class="hljs-comment">//组合</span>  <span class="hljs-keyword">private</span> EggLayAbility eggLayAbility = <span class="hljs-keyword">new</span> EggLayAbility(); <span class="hljs-comment">//组合</span>  <span class="hljs-comment">//... 省略其他属性和方法...</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tweet</span><span class="hljs-params">()</span> </span>&#123;    tweetAbility.tweet(); <span class="hljs-comment">// 委托</span>  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">layEgg</span><span class="hljs-params">()</span> </span>&#123;    eggLayAbility.layEgg(); <span class="hljs-comment">// 委托</span>  &#125;&#125;</code></pre><p>继承主要有三个作用：<strong>表示 is-a 关系，支持多态特性，代码复用</strong>。这三个作用都可以通过其他技术来达成。</p><ul><li>is-a 关系可以通过<strong>组合</strong>和<strong>接口的 has-a</strong> 关系来替代；</li><li>多态特性可以利用接口来实现；</li><li>代码复用可以通过组合和委托来实现。</li></ul><p>理论上讲，通过组合、接口、委托三种技术，可以替代继承。在项目中可以不用或者少用继承关系，特别是一些复杂的继承关系。</p><h3 id="组合-OR-继承"><a href="#组合-OR-继承" class="headerlink" title="组合 OR 继承"></a>组合 OR 继承</h3><p>继承改写成组合意味着要做更细粒度的类的拆分，定义更多的类和接口。类和接口的增多会增加代码的复杂程度和维护成本。实际的项目开发要根据具体的情况，具体地选择该用继承还是组合。</p><p>如果类之间的继承结构稳定，继承层次比较浅，继承关系不复杂，可以使用继承。反之，就尽量使用组合。</p><p>一些设计模式会固定使用继承或者组合。装饰者模式、策略模式、组合模式等都使用了组合关系，而模板模式使用了继承关系。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OOP</tag>
      
      <tag>Encapsulation</tag>
      
      <tag>Inheritance</tag>
      
      <tag>Polymorphism</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python Tips</title>
    <link href="/2020/07/21/Python-Tips/"/>
    <url>/2020/07/21/Python-Tips/</url>
    
    <content type="html"><![CDATA[<p>Python知识点整理。</p><a id="more"></a><h2 id="Python中的引用与拷贝"><a href="#Python中的引用与拷贝" class="headerlink" title="Python中的引用与拷贝"></a>Python中的引用与拷贝</h2><blockquote><p>区别</p><p>引用：旧瓶装旧酒<br>浅拷贝：新瓶装旧酒<br>深拷贝：新瓶装新酒</p></blockquote><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>python中赋值符号“=”两边的对象是同一个对象，左边的对象可以看成是右边对象的一个引用。</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>b=a<span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>b[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>a.append(<span class="hljs-string">'c'</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>b[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b<span class="hljs-literal">True</span></code></pre><p>a的值的变化会导致b的值也会变化，因为他们是同一个对象，共享同一块内存地址，b是a的引用。</p><p><strong>判断两个变量是否是同一个对象的方法是用is</strong>，返回True则代表两个变量是同一个对象。 </p><p>赋值是将一个对象的地址赋值给一个变量，让变量指向该地址。 </p><h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><p>对象的拷贝是根据源对象生成一个新的对象，占用不同的内容存空间。一个对象值的变化，不会影响另外一个对象的值。拷贝又分潜拷贝和深拷贝。 </p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>python中的copy模块可以实现对象的浅拷贝。 </p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> copy<span class="hljs-meta">&gt;&gt;&gt; </span>a=[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span>b=copy.copy(a)<span class="hljs-meta">&gt;&gt;&gt; </span>b <span class="hljs-keyword">is</span> a<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">False</span><span class="hljs-meta">&gt;&gt;&gt; </span>a.append(<span class="hljs-string">'c'</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>a[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>], <span class="hljs-string">'c'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>b[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">0</span>].append(<span class="hljs-number">3</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>a[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>], <span class="hljs-string">'c'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>b[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> b[<span class="hljs-number">0</span>]<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span><span class="hljs-comment"># b=a[:]会创建一个新的与a完全相同的对象，但是与a并不指向同一对象</span><span class="hljs-meta">&gt;&gt;&gt; </span>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span>b = a[:]<span class="hljs-meta">&gt;&gt;&gt; </span>b[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b<span class="hljs-literal">False</span><span class="hljs-meta">&gt;&gt;&gt; </span>a.append(<span class="hljs-number">7</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>], <span class="hljs-number">7</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>b[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">3</span>].append(<span class="hljs-number">9</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>], <span class="hljs-number">7</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>b[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">3</span>] <span class="hljs-keyword">is</span> b[<span class="hljs-number">3</span>]<span class="hljs-literal">True</span>&gt;&gt;&gt;</code></pre><p>通过例子可以看到通过copy模块的copy方法，根据对象a生成了一个新对象b，这一点可以通过is表达式的结果证明。 </p><p>a.append(‘c’)之后，发现a和b的值不一样了，这是因为a和b指向两个不同的地址。对a的值的修改不会影响b的值。 但是a[0].append(3)之后，a[0]和b[0]却是一样的。这就是浅拷贝的效果。因为a[0] 和b[0]还是指向同一个地址。 </p><p>浅拷贝是在另一块地址中创建一个新的变量或容器，但是容器内的元素的地址均是源对象的元素的地址的拷贝。也就是说新的容器中指向了旧的元素。</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>python的copy模块的deepcopy函数可以实现深拷贝。</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> copy<span class="hljs-meta">&gt;&gt;&gt; </span>a=[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span>b=copy.deepcopy(a)<span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b<span class="hljs-literal">False</span><span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> b[<span class="hljs-number">0</span>]<span class="hljs-literal">False</span><span class="hljs-meta">&gt;&gt;&gt; </span>a.append(<span class="hljs-string">'c'</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>a[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>], <span class="hljs-string">'c'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>b[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">0</span>].append(<span class="hljs-number">3</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>a[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span>b[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]]</code></pre><p>由于b是a的深拷贝，所以a对象和b对象的内存地址不同，a对象和b对象包含的底层对象（a[0]a[1]b[0]b[1]）内存地址也不同。 </p><p>对a对象的值的改变不会影响b对象的值，对a对象的底层对象的值的改变也不会影响b的底层对象的值。</p><p>深拷贝是在另一块地址中创建一个新的变量或容器，同时容器内的元素的地址也是新开辟的，仅仅是值相同而已，是完全的副本。</p><h3 id="二维数组初始化"><a href="#二维数组初始化" class="headerlink" title="二维数组初始化"></a>二维数组初始化</h3><p><a href="https://blog.csdn.net/yockie/article/details/46127829" target="_blank" rel="noopener">python创建二维数组</a></p><pre><code class="hljs python"><span class="hljs-comment"># list * n—&gt;n shallow copies of list concatenated, n个list的浅拷贝的连接</span><span class="hljs-meta">&gt;&gt;&gt; </span>dimen_list = [[<span class="hljs-number">0</span>] * <span class="hljs-number">3</span>] * <span class="hljs-number">4</span><span class="hljs-meta">&gt;&gt;&gt; </span>dimen_list[[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span>dimen_list[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><span class="hljs-meta">&gt;&gt;&gt; </span>dimen_list[[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span>lists = [[]] * <span class="hljs-number">3</span><span class="hljs-meta">&gt;&gt;&gt; </span>lists[[], [], []]<span class="hljs-meta">&gt;&gt;&gt; </span>lists[<span class="hljs-number">0</span>].append(<span class="hljs-number">3</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>lists[[<span class="hljs-number">3</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">3</span>]]<span class="hljs-comment"># 需要用另一种方式创建多维数组,以免浅拷贝</span><span class="hljs-meta">&gt;&gt;&gt; </span>size = <span class="hljs-number">3</span><span class="hljs-meta">&gt;&gt;&gt; </span>lists = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(size)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(size)]<span class="hljs-meta">&gt;&gt;&gt; </span>lists[[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]</code></pre><h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><p>Python内置类型：主要有数字、序列、映射、类、实例和异常。 </p><p><strong>数字类型</strong>：int, float, complex</p><p><strong>迭代器类型</strong>：Python 支持对容器进行迭代。序列支持迭代方法。</p><p><strong>生成器类型</strong>：Python 的 generator 提供了一种实现迭代器协议的便捷方式。</p><p><strong>不可变序列类型</strong>：数字、布尔、元组tuple、range 类型表示不可变的数字序列、文本序列类型（字符串）str、bytes、frozenset</p><p>注：由于许多主要二进制协议都基于 ASCII 文本编码，因此 bytes 对象提供了一些仅在处理 ASCII 兼容数据时可用，并且在许多特性上与字符串对象紧密相关的方法。 </p><p><strong>可变序列类型</strong>：列表list、字典dic、set，不可以作为字典的key</p><p>不可变序列类型普遍实现，而可变序列类型未实现的操作是对 <strong>hash()</strong> 内置函数的支持。也就是说，<strong>hash() 函数可以应用于数字、字符串和对象，但是不能直接应用于list、set、dictionary</strong>。 </p><pre><code class="hljs python">列表解析式：[x*<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>)]  字典解析式：my_dict = &#123;i: i * i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>)&#125;  集合解析式：my_set = &#123;i * <span class="hljs-number">15</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>)&#125;字符串/列表逆序：<span class="hljs-meta">&gt;&gt;&gt; </span>str = <span class="hljs-string">"abc"</span><span class="hljs-meta">&gt;&gt;&gt; </span>str[::<span class="hljs-number">-1</span>]    <span class="hljs-comment"># 原字符串不改变</span><span class="hljs-string">'cba'</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">''</span>.join(reversed(str))  <span class="hljs-comment"># 原字符串不改变</span><span class="hljs-string">'cba'</span>           <span class="hljs-meta">&gt;&gt;&gt; </span>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>a[::<span class="hljs-number">-1</span>]      <span class="hljs-comment"># 原列表不改变 </span>[<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>a.reverse()  <span class="hljs-comment"># 原列表改变 </span><span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]</code></pre><p><strong>空对象</strong>：当函数无显示返回值时，会返回该对象。它不支持任何特殊的操作。空对象只有一种值 None (内置名称)。</p><p><strong>优先队列的特点</strong>：队列的特点是先进先出，入队时，将新元素置于队尾巴，出队时，队头元素最先被移出。优先队列不再遵循先入先出的原则，而分为两种情况：1）最大优先队列，无论入队顺序如何，都是当前最大的元素出队；2）最小优先队列，无论入队顺序如何，都是当前最小的元素出队。</p><p><strong>优先队列的实现</strong>：二叉堆有以下性质：1）最大堆的堆顶是整个堆中的最大元素；2) 最小堆的堆顶是整个堆中的最小元素。因此，可以用最大堆来实现最大优先队列，每一次入队操作就是堆的插入操作，每一次出队操作就是删除堆顶节点。二叉堆节点上浮和下沉的时间复杂度都是O(logn)，所以优先队列的入队和出队的时间复杂度也是O(logn)。</p><p>python中heapq模块实现了最小堆。heapq有两种方式创建堆：1）使用一个空列表，然后使用heapq.heappush()方法将值加入堆中；2）使用heap.heapify(list)转换列表成为堆结构。 </p><table><thead><tr><th>heapify(heap)</th><th>让列表具备堆特征</th></tr></thead><tbody><tr><td>heappush(heap, x)</td><td>将x压入堆中</td></tr><tr><td>heappop(heap)</td><td>从堆中弹出最小的元素</td></tr><tr><td>heapreplace(heap, x)</td><td>弹出最小的元素，并将x压入堆中</td></tr><tr><td>nlargest(n, iter)</td><td>返回iter中n个最大的元素</td></tr><tr><td>nsmallest(n, iter)</td><td>返回iter中n个最小的元素</td></tr></tbody></table><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p><a href="https://www.runoob.com/python3/python3-func-enumerate.html" target="_blank" rel="noopener">enumerate() </a></p><p>enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据下标和数据，一般用在 for 循环当中。 </p><pre><code class="hljs python">&gt;&gt;&gt;seq = [<span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>, <span class="hljs-string">'three'</span>]&gt;&gt;&gt;<span class="hljs-keyword">for</span> i, element <span class="hljs-keyword">in</span> enumerate(seq):<span class="hljs-meta">... </span>   print(i, seq[i])<span class="hljs-meta">... </span><span class="hljs-number">0</span> one<span class="hljs-number">1</span> two<span class="hljs-number">2</span> three</code></pre><p><a href="https://www.runoob.com/python3/python3-func-zip.html" target="_blank" rel="noopener">zip()</a></p><p>zip() 函数将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。可以使用 list() 转换来输出列表。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 ***** 号操作符，可以将元组解压为列表。</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>b = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>c = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>zipped = zip(a,b)  <span class="hljs-comment"># 返回一个对象</span><span class="hljs-meta">&gt;&gt;&gt; </span>zipped&lt;zip object at <span class="hljs-number">0x103abc288</span>&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>list(zipped)       <span class="hljs-comment"># list() 转换为列表</span>[(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">6</span>)]<span class="hljs-meta">&gt;&gt;&gt; </span>list(zip(a,c))     <span class="hljs-comment"># 元素个数与最短的列表一致</span>[(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">6</span>)] <span class="hljs-meta">&gt;&gt;&gt; </span>a1, a2 = zip(*zip(a,b))  <span class="hljs-comment"># 与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式</span><span class="hljs-meta">&gt;&gt;&gt; </span>list(a1)[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>list(a2)[<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]</code></pre><p><a href="https://www.runoob.com/python3/python3-func-reversed.html" target="_blank" rel="noopener">reversed(seq)</a></p><p>返回一个反转的迭代器；参数：要转换的序列，可以是tuple, string, list 或 range。</p><pre><code class="hljs python"><span class="hljs-comment"># 字符串</span><span class="hljs-meta">&gt;&gt;&gt; </span>seqString = <span class="hljs-string">'Runoob'</span><span class="hljs-meta">&gt;&gt;&gt; </span>print(list(reversed(seqString)))[<span class="hljs-string">'b'</span>, <span class="hljs-string">'o'</span>, <span class="hljs-string">'o'</span>, <span class="hljs-string">'n'</span>, <span class="hljs-string">'u'</span>, <span class="hljs-string">'R'</span>]</code></pre><p><a href="https://www.runoob.com/python/python-func-eval.html" target="_blank" rel="noopener">eval()</a></p><p>eval() 函数用来执行一个字符串表达式，返回表达式的值。</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = <span class="hljs-number">7</span><span class="hljs-meta">&gt;&gt;&gt; </span>eval( <span class="hljs-string">'3 * x'</span> )<span class="hljs-number">21</span><span class="hljs-meta">&gt;&gt;&gt; </span>eval(<span class="hljs-string">'pow(2,2)'</span>)<span class="hljs-number">4</span><span class="hljs-meta">&gt;&gt;&gt; </span>eval(<span class="hljs-string">'2 + 2'</span>)<span class="hljs-number">4</span><span class="hljs-meta">&gt;&gt;&gt; </span>n=<span class="hljs-number">81</span><span class="hljs-meta">&gt;&gt;&gt; </span>eval(<span class="hljs-string">"n + 4"</span>)<span class="hljs-number">85</span></code></pre><p><a href="https://www.runoob.com/python/python-func-bin.html" target="_blank" rel="noopener">bin()</a></p><p>返回整数 int 或者长整数 long int 的二进制表示。 </p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bin(<span class="hljs-number">11</span>)<span class="hljs-string">'0b1011'</span><span class="hljs-meta">&gt;&gt;&gt; </span>bin(<span class="hljs-number">20</span>)<span class="hljs-string">'0b10100'</span>str = <span class="hljs-meta">&gt;&gt;&gt; </span>str = <span class="hljs-string">"1010"</span><span class="hljs-meta">&gt;&gt;&gt; </span>int(str, base=<span class="hljs-number">2</span>)<span class="hljs-number">10</span></code></pre><p><a href="https://www.runoob.com/python/python-func-getattr.html" target="_blank" rel="noopener">getattr()</a></p><p>getattr(object, name[, default]) 函数用于返回一个对象属性值。用例，leetcode习题解6：链表组件。</p><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">A</span>(<span class="hljs-symbol">object</span>):    <span class="hljs-symbol">bar</span> = <span class="hljs-symbol">1</span>&gt;&gt;&gt; <span class="hljs-symbol">a</span> = <span class="hljs-symbol">A</span>()&gt;&gt;&gt; <span class="hljs-symbol">getattr</span>(<span class="hljs-symbol">a, </span>'<span class="hljs-symbol">bar</span>')  # 获取属性 <span class="hljs-symbol">bar</span> 值<span class="hljs-symbol">1</span></code></pre><p><a href="https://www.runoob.com/python3/python3-string-maketrans.html" target="_blank" rel="noopener">maketrans()</a></p><p>str.maketrans(intab_str, outtab_str) 创建字符映射的转换表。第一个参数表示需要转换的字符，第二个表示转换的目标。两个字符串的长度必须相同，为一一对应关系</p><p><a href="https://www.runoob.com/python3/python3-string-translate.html" target="_blank" rel="noopener">translate()</a></p><p>translate() 方法根据参数table给出的表(包含 256 个字符)转换字符串的字符，要过滤掉的字符放到 deletechars 参数中。</p><pre><code class="hljs python">intab = <span class="hljs-string">"aeiou"</span>outtab = <span class="hljs-string">"12345"</span>trantab = str.maketrans(intab, outtab)   <span class="hljs-comment"># 制作翻译表</span> str = <span class="hljs-string">"this is string example....wow!!!"</span><span class="hljs-keyword">print</span> (str.translate(trantab))<span class="hljs-comment"># th3s 3s str3ng 2x1mpl2....w4w!!!</span></code></pre><p>ord() 和 chr()</p><p>ord() 和 chr() 方法将字母和ASCII相互转化。</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>ord(<span class="hljs-string">'A'</span>) <span class="hljs-number">65</span> <span class="hljs-meta">&gt;&gt;&gt; </span>chr(<span class="hljs-number">65</span>) <span class="hljs-string">'A'</span></code></pre><p><a href="https://www.runoob.com/python/att-string-join.html" target="_blank" rel="noopener">join()</a></p><p>str.join(sequence) 方法用于将序列中的元素以指定的字符连接生成一个新的字符串，sequence为要连接的元素序列。返回通过指定字符连接序列中元素后生成的新字符串。 </p><pre><code class="hljs python">str = <span class="hljs-string">"-"</span>seq = (<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>)<span class="hljs-keyword">print</span> str.join(seq)<span class="hljs-comment"># a-b-c</span>list = [<span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>]print(<span class="hljs-string">''</span>.join(list))<span class="hljs-comment"># 123</span>seq = &#123;<span class="hljs-string">'hello'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'world'</span>: <span class="hljs-number">2</span>&#125;print(<span class="hljs-string">'-'</span>.join(seq))  <span class="hljs-comment"># 字典只对键进行连接</span><span class="hljs-comment"># hello-world</span><span class="hljs-keyword">import</span> os<span class="hljs-keyword">print</span> os.path.join(<span class="hljs-string">"D:\\"</span>,<span class="hljs-string">"test.txt"</span>)  <span class="hljs-comment"># 连接2个字符串</span><span class="hljs-comment"># D:\test.txt</span><span class="hljs-comment"># file_path存放于E:\PySec</span>print(os.path.abspath(<span class="hljs-string">'.'</span>))print(os.path.dirname(os.path.abspath(<span class="hljs-string">'.'</span>)))  <span class="hljs-comment"># abspath('.')返回当前目录的绝对路径</span>file_dir = os.path.dirname(os.path.abspath(<span class="hljs-string">'.'</span>)) + <span class="hljs-string">'data'</span>lists = os.listdir(file_dir)print(lists)file = os.path.join(file_dir, lists[<span class="hljs-number">-1</span>])print(file)<span class="hljs-comment"># E:\PySec</span><span class="hljs-comment"># E:\</span><span class="hljs-comment"># ['DAG reference.pdf', 'formatted.csv', 'formatted_1.csv', 'formatted_2.csv', 'Pro_process.docx']</span><span class="hljs-comment"># E:\data\Pro_process.docx</span></code></pre><p><a href="https://www.runoob.com/python3/python3-os-path.html" target="_blank" rel="noopener">os.path()</a></p><p>os.path 模块主要用于获取文件的属性。</p><p><a href="https://www.runoob.com/python/att-string-find.html" target="_blank" rel="noopener">find()</a></p><p>str.find(str, beg=0, end=len(string))。Python find() 方法检测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，如果包含子字符串返回开始的索引值，否则返回-1。</p><p><a href="https://www.runoob.com/python/att-string-isalpha.html" target="_blank" rel="noopener">isalpha()</a></p><p>isalpha() 方法检测字符串是否只由字母组成。如果字符串至少有一个字符并且所有字符都是字母则返回 True，否则返回 False。</p><p><a href="https://www.runoob.com/python/python-func-all.html" target="_blank" rel="noopener">all()</a></p><p>all() 函数用于判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。元素除了是 0、空、None、False 外都算 True。</p><p><a href="https://blog.csdn.net/LaoYuanPython/article/details/95082169" target="_blank" rel="noopener">富比较</a></p><p>Python中基类object提供了一系列可以用于实现同类对象进行“比较”的方法，可以用于同类对象的不同实例进行比较，包括 <strong>lt</strong>、<strong>gt</strong>、<strong>le</strong>、<strong>ge</strong>、<strong>eq</strong>和<strong>ne</strong> 六个方法。</p><p><a href="https://docs.python.org/zh-cn/3.7/library/itertools.html" target="_blank" rel="noopener">排列组合</a></p><p>python的itertools包中提供了和排列组合相关的函数：</p><ul><li><a href="https://docs.python.org/zh-cn/3.7/library/itertools.html#itertools.combinations" target="_blank" rel="noopener">combinations</a>方法重点在组合</li><li><a href="https://docs.python.org/zh-cn/3.7/library/itertools.html#itertools.permutations" target="_blank" rel="noopener">permutations</a>方法重在排列</li><li><a href="https://docs.python.org/zh-cn/3.7/library/itertools.html#itertools.product" target="_blank" rel="noopener">product</a> 用于求多个可迭代对象的笛卡尔积(Cartesian Product)，它跟嵌套的 for循环等价。即：product(A, B) 和 ((x,y) for x in A for y in B)的效果是一样的。</li></ul><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> combinations, permutations, product<span class="hljs-meta">&gt;&gt;&gt; </span>list(combinations(<span class="hljs-string">'abc'</span>,<span class="hljs-number">2</span>))[(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>), (<span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>)]<span class="hljs-meta">&gt;&gt;&gt; </span>list(permutations(<span class="hljs-string">'abc'</span>,<span class="hljs-number">2</span>))[(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>), (<span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>), (<span class="hljs-string">'c'</span>, <span class="hljs-string">'a'</span>), (<span class="hljs-string">'c'</span>, <span class="hljs-string">'b'</span>)]<span class="hljs-meta">&gt;&gt;&gt; </span>list(product(<span class="hljs-string">'abc'</span>,repeat=<span class="hljs-number">2</span>))[(<span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>), (<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>), (<span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-string">'b'</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>), (<span class="hljs-string">'c'</span>, <span class="hljs-string">'a'</span>), (<span class="hljs-string">'c'</span>, <span class="hljs-string">'b'</span>), (<span class="hljs-string">'c'</span>, <span class="hljs-string">'c'</span>)]<span class="hljs-meta">&gt;&gt;&gt; </span>list(product(<span class="hljs-string">'abc'</span>,<span class="hljs-string">'de'</span>))[(<span class="hljs-string">'a'</span>, <span class="hljs-string">'d'</span>), (<span class="hljs-string">'a'</span>, <span class="hljs-string">'e'</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-string">'d'</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-string">'e'</span>), (<span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>), (<span class="hljs-string">'c'</span>, <span class="hljs-string">'e'</span>)]</code></pre><p><a href="https://blog.csdn.net/transformed/article/details/89879193" target="_blank" rel="noopener">cmp_to_key</a></p><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> cmp_to_key L=[<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">23</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] sorted(L,key=cmp_to_key(<span class="hljs-keyword">lambda</span> x,y:y-x))<span class="hljs-comment"># Output：</span><span class="hljs-comment"># [23, 9, 2, 2, 1]</span>  sorted(L,key=cmp_to_key(<span class="hljs-keyword">lambda</span> x,y:x-y))<span class="hljs-comment"># [1, 2, 2, 9, 23]</span></code></pre><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>总结Python常用数据结构的操作的时间复杂度。</p><p><a href="https://www.jianshu.com/p/a8fa3d31aa40" target="_blank" rel="noopener">参考一</a> </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.python.org/zh-cn/3.7/library/stdtypes.html" target="_blank" rel="noopener">python3.7.6文档：内置类型</a></p><p><a href="https://github.com/JiaxingZhao/Python--Antic/blob/master/Python%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB" target="_blank" rel="noopener">Python知识点汇总</a></p><p><a href="https://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">Python3教程</a></p><p><a href="https://blog.csdn.net/liuchunming033/article/details/51493367" target="_blank" rel="noopener">Python语言中的引用与拷贝</a></p><p><a href="https://www.jianshu.com/p/801318c77ab5" target="_blank" rel="noopener">Python标准库模块之heapq</a></p><p><a href="https://blog.csdn.net/LaoYuanPython/article/details/95082169" target="_blank" rel="noopener">为什么Python中称lt、gt等为“富比较”方法</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
