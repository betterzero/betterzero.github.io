<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据结构与算法</title>
    <link href="/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>文章对常用的数据结构做归纳总结。</p><a id="more"></a><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><ul><li>时间和空间的转换，两者之间平衡的意识；</li><li>掌握常用的基础数据结构，包括内部实现、常用操作的时间和空间复杂度；</li><li>针对不同的场景，能够选择较为合适的数据结构；</li></ul><h1 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a>常用数据结构</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li><p>用一组连续的内存空间，存储一组具有相同类型的数据；</p></li><li><p>支持随机访问，但插入、删除操作比较低效；</p></li></ul><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="随机访问"><a href="#随机访问" class="headerlink" title="随机访问"></a>随机访问</h4><p>一维寻址公式：a[k]_address = base_address + k * type_size；</p><p>二维寻址公式，对于 m*n 的数组：a[i][j]_address = base_address + (i*n+j) * type_size；</p><p>所以，根据下标随机访问的时间复杂度为 O(1)；</p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><ul><li>开头插入：最坏时间复杂度是O(n)；</li><li>平均情况时间复杂度： (1+2+…n)/n = O(n)；</li><li>在中间第 k 位插入：时间复杂度可以达到是O(1)；<ul><li>如果数组中的数据是有序的，在某个位置插入一个新的元素时，就必须搬移 k 之后的数据，但是，</li><li>如果数组中存储的数据没有任何规律，数组只是被当作一个存储数据的集合。这种情况下，如果要将某个数据插入到第 k 个位置，为了避免大规模的数据搬移，还有一个简单的办法，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置；</li></ul></li><li>在末尾插入：时间复杂度是O(1)；</li></ul><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><ul><li>开头删除：最坏时间复杂度O(n)；</li><li>平均情况时间复杂度O(n)；</li><li>在中间第 k 位删除：每次删除操作只记录数据已被删除。当没有更多空间时，才触发执行真正的删除操作；<ul><li>在某些特殊场景下，并不一定要求数组中数据的连续性。如果将多次删除操作集中在一起执行，删除的效率会有所提高；</li><li>JVM 的标记清除垃圾回收算法的核心思想应用了这个思想；</li></ul></li><li>在末尾删除：时间复杂度O(1)；</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li><p>平时的业务开发，使用编程语言提供的容器类比较方便，有助于提高开发效率；</p></li><li><p>底层的开发适合直接使用数组，更加高效；</p></li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul><li>通过指针将一组零散的内存块串联起来使用；</li><li>插入、删除数据快；</li></ul><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>根据指针一个节点一个节点依次遍历，直到找到目标节点。</p><h4 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h4><p>只要考虑相邻节点的指针改变，时间复杂度是O(1)。</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>一种特殊的单链表，尾节点指针指向链表的头节点。</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><ul><li><p>支持两个方向，后继指针 next 指向后面的节点，前驱指针 pre 指向前面的节点；</p></li><li><p>查找、插入、删除的效率都比单链表高；</p></li></ul><h4 id="删除“值等于给定值”的节点"><a href="#删除“值等于给定值”的节点" class="headerlink" title="删除“值等于给定值”的节点"></a>删除“值等于给定值”的节点</h4><ul><li><p>从头节点开始遍历，依次对比，直到找到值等于给定值的节点，通过指针操作将其删除；</p></li><li><p>时间复杂度为O(n)；</p></li></ul><h4 id="删除给定指针指向的节点"><a href="#删除给定指针指向的节点" class="headerlink" title="删除给定指针指向的节点"></a>删除给定指针指向的节点</h4><ul><li>对于单链表，已经知道了要删除的节点，但是要删除某个结点 q 需要知道其前驱结点，而单链表不可以直接获取前驱结点，所以为了找到前驱结点，要从头结点开始遍历链表，直到 p-&gt;next=q，说明 p 是 q 的前驱结点。时间复杂度为O(n)；</li><li>对于双向链表，因为节点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，O(1) 的时间复杂度就可以完成操作；</li></ul><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><ul><li><p>链表适合插入、删除操作比较频繁的场景；</p></li><li><p>双向链表比单链表的插入、删除等操作简单、高效，适用在很多场景；</p></li><li><p>循环链表适合要处理的数据具有环形结构的特点，比如约瑟夫环问题；</p></li></ul><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>一种操作受限的线性表，只允许在一端插入和删除数据，特点是FILO。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li><p>只需要一个栈顶指针；</p></li><li><p>用数组实现的栈叫顺序栈，用链表实现的栈叫链式栈；</p></li></ul><h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 基于数组实现的顺序栈</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayStack</span> </span>&#123;  <span class="hljs-keyword">private</span> String[] items;  <span class="hljs-comment">// 数组</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;       <span class="hljs-comment">// 栈中元素个数</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;           <span class="hljs-comment">// 栈的大小</span>  <span class="hljs-comment">// 初始化数组，申请一个大小为n的数组空间</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayStack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">this</span>.items = <span class="hljs-keyword">new</span> String[n];    <span class="hljs-keyword">this</span>.n = n;    <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;  &#125;  <span class="hljs-comment">// 入栈操作</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">push</span><span class="hljs-params">(String item)</span> </span>&#123;    <span class="hljs-comment">// 数组空间不够了，直接返回false，入栈失败。</span>    <span class="hljs-keyword">if</span> (count == n) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-comment">// 将item放到下标为count的位置，并且count加一</span>    items[count] = item;    ++count;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  &#125;    <span class="hljs-comment">// 出栈操作</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 栈为空，则直接返回null</span>    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 返回下标为count-1的数组元素，并且栈中元素个数count减一</span>    String tmp = items[count-<span class="hljs-number">1</span>];    --count;    <span class="hljs-keyword">return</span> tmp;  &#125;&#125;</code></pre><h4 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 基于链表实现的链式栈</span><span class="hljs-comment"> * 注意：通俗的理解，节点的next指针是指向“底下”的节点，是指向下面的节点</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackBasedOnLinkedList</span> </span>&#123;  <span class="hljs-keyword">private</span> Node top = <span class="hljs-keyword">null</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;    Node newNode = <span class="hljs-keyword">new</span> Node(value, <span class="hljs-keyword">null</span>);    <span class="hljs-comment">// 判断是否栈空</span>    <span class="hljs-keyword">if</span> (top == <span class="hljs-keyword">null</span>) &#123;      top = newNode;    &#125; <span class="hljs-keyword">else</span> &#123;      newNode.next = top;      top = newNode;    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 这里用-1表示栈中没有数据。</span><span class="hljs-comment">   */</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (top == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> value = top.data;    top = top.next;    <span class="hljs-keyword">return</span> value;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printAll</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 用一个临时变量</span>    Node p = top;    <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;      System.out.print(p.data + <span class="hljs-string">" "</span>);      p = p.next;    &#125;    System.out.println();  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data;    <span class="hljs-keyword">private</span> Node next;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data, Node next)</span> </span>&#123;      <span class="hljs-keyword">this</span>.data = data;      <span class="hljs-keyword">this</span>.next = next;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> data;    &#125;  &#125;&#125;</code></pre><h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><ul><li>不管是顺序栈还是链式栈，存储数据只需要一个大小为 n 的数组。在<strong>入栈</strong>和<strong>出栈</strong>过程中，只需要一两个临时变量存储空间，所以<strong>空间复杂度是 O(1)</strong>；<ul><li><strong>注：</strong>这里存储数据需要一个大小为 n 的数组，并不是说空间复杂度就是 O(n)。因为这 n 个空间是必须的，无法省掉。<strong>所以空间复杂度，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间</strong>；</li></ul></li><li>顺序栈还是链式栈，<strong>入栈、出栈</strong>只涉及<strong>栈顶</strong>个别数据的操作，所以时间复杂度都是 O(1)；</li></ul><h3 id="动态扩容的栈"><a href="#动态扩容的栈" class="headerlink" title="动态扩容的栈"></a>动态扩容的栈</h3><p>尽管链式栈的大小不受限，但要存储 next 指针，<strong>内存消耗相对较多</strong>。</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><ul><li><p>底层依赖一个支持动态扩容的数组；</p></li><li><p>栈满之后，要申请一个更大的数组，将原来的数据搬移到新的数组中；</p></li></ul><h4 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h4><ul><li><p>最好情况时间复杂度是O(1)；</p></li><li><p>最坏情况时间复杂度是O(n)；</p></li><li><p>均摊时间复杂度是O(1)；</p></li></ul><h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><p>时间复杂度是O(1)。</p><h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><h4 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h4><p>作为一个比较基础的数据结构，<strong>应用场景较多</strong>。一个比较经典的应用场景就是<strong>函数调用栈</strong>。栈可以用于在函数调用时保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？</p><ul><li>其实，不一定非要用栈来保存临时变量，只不过函数调用符合<strong>后进先出</strong>的特性，用栈这种数据结构来实现，是最<strong>顺理成章</strong>的选择；</li><li>从调用函数进入被调用函数，对于<strong>数据</strong>来说，变化的是什么呢？是<strong>作用域</strong>。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段<strong>栈空间</strong>给这个函数的变量，在函数结束的时候，将<strong>栈顶复位</strong>，正好回到调用函数的作用域内；</li></ul><p><strong>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构</strong>，用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;   ret = add(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>);   res = a + ret;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, res);   reuturn <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;   <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;   sum = x + y;   <span class="hljs-keyword">return</span> sum;&#125;</code></pre><p><img src="%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88.PNG" srcset="/img/loading.gif" alt=""></p><h4 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h4><p>算术表达式只包含加减乘除四则运算。一个保存操作数的栈，另一个是保存运算符的栈。</p><ul><li>从左向右遍历表达式，当遇到<strong>数字</strong>，就直接<strong>压入操作数栈</strong>；</li><li>当遇到<strong>运算符</strong>，就与<strong>运算符栈的栈顶元素</strong>进行比较，<ul><li>如果比运算符栈顶元素的<strong>优先级高</strong>，就将当前运算符<strong>压栈</strong>；</li><li>如果比运算符栈顶元素的优先级<strong>低或者相同</strong>，从运算符栈中<strong>取栈顶运算符</strong>，从操作数栈的栈顶<strong>取 2 个操作数</strong>，然后进行计算，再把计算完的结果<strong>压入操作数栈</strong>，继续比较；</li></ul></li></ul><h4 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h4><p>表达式中只包含三种括号，圆括号 ()、方括号[]和花括号{}，可以任意嵌套。给定一个包含三种括号的表达式字符串。用栈可以解决检查它的合法性。</p><ul><li>用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；</li><li>当扫描到右括号时，从栈顶取出一个左括号，<ul><li>如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串；</li><li>如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式；</li></ul></li><li>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式；</li></ul><h4 id="实现浏览器的前进、后退功能"><a href="#实现浏览器的前进、后退功能" class="headerlink" title="实现浏览器的前进、后退功能"></a>实现浏览器的前进、后退功能</h4><p>使用两个栈，X 和 Y，把首次浏览的页面依次压入栈 X，</p><ul><li>当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y；</li><li>当点击前进按钮时，依次从栈 Y 中取出数据，放入栈 X 中；</li><li>当栈 X 中没有数据时，就说明没有页面可以继续后退浏览了；当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了；</li></ul><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>一种操作受限的线性表数据结构，特性是FIFO。</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>需要两个指针，head指针指向队头，tail指针指向队尾。</p><h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><ul><li><p>用数组实现的队列；</p></li><li><p>出队时不用搬移数据。如果没有空闲空间，只需要在入队时再集中触发一次数据的搬移操作；</p></li></ul><p>队满的判断条件是 tail == n，队空的判断条件是 head == tail。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 基于数组实现的队列</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayQueue</span> </span>&#123;  <span class="hljs-comment">// 数组：items，数组大小：n</span>  <span class="hljs-keyword">private</span> String[] items;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;  <span class="hljs-comment">// head表示队头下标，tail表示队尾下标</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tail = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 申请一个大小为capacity的数组</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;    items = <span class="hljs-keyword">new</span> String[capacity];    n = capacity;  &#125;  <span class="hljs-comment">// 入队</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(String item)</span> </span>&#123;    <span class="hljs-comment">// 如果tail == n 表示队列已经满了</span>    <span class="hljs-keyword">if</span> (tail == n) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    items[tail] = item;    ++tail;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  &#125;  <span class="hljs-comment">// 出队</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 如果head == tail 表示队列为空</span>    <span class="hljs-keyword">if</span> (head == tail) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 为了让其他语言的同学看的更加明确，把--操作放到单独一行来写了</span>    String ret = items[head];    ++head;    <span class="hljs-keyword">return</span> ret;  &#125;&#125;</code></pre><p>以上的不停地入队、出队操作，head 和 tail 都会持续往后移动。当 tail 移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。</p><p>一个可能的解决方案：在出队时可以不用搬移数据。<strong>如果没有空闲空间，只需要在入队时，再集中触发一次数据的搬移操作</strong>。借助这个思想，出队函数 dequeue() 保持不变，<strong>改造一下入队函数 enqueue()</strong> 的实现，就可以解决刚才的问题。</p><pre><code class="hljs java"><span class="hljs-comment">// 入队操作，将item放入队尾</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(String item)</span> </span>&#123;  <span class="hljs-comment">// tail == n表示队列末尾没有空间了</span>  <span class="hljs-keyword">if</span> (tail == n) &#123;    <span class="hljs-comment">// tail ==n &amp;&amp; head==0，表示整个队列都占满了</span>    <span class="hljs-keyword">if</span> (head == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-comment">// 数据搬移</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head; i &lt; tail; ++i) &#123;      items[i-head] = items[i];    &#125;    <span class="hljs-comment">// 搬移完之后重新更新head和tail</span>    tail -= head;    head = <span class="hljs-number">0</span>;  &#125;    items[tail] = item;  ++tail;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><h3 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h3><p>用链表实现的队列。基于链表的实现，需要两个指针：</p><ul><li>head 指针指向链表的第一个结点；</li><li>tail 指针指向最后一个结点；</li><li>入队时：tail-&gt;next= new_node, tail = tail-&gt;next；</li><li>出队时：head = head-&gt;next；</li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 基于链表实现的队列</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueueBasedOnLinkedList</span> </span>&#123;  <span class="hljs-comment">// 队列的队首和队尾</span>  <span class="hljs-keyword">private</span> Node head = <span class="hljs-keyword">null</span>;  <span class="hljs-keyword">private</span> Node tail = <span class="hljs-keyword">null</span>;  <span class="hljs-comment">// 入队</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(String value)</span> </span>&#123;    <span class="hljs-keyword">if</span> (tail == <span class="hljs-keyword">null</span>) &#123;      Node newNode = <span class="hljs-keyword">new</span> Node(value, <span class="hljs-keyword">null</span>);      head = newNode;      tail = newNode;    &#125; <span class="hljs-keyword">else</span> &#123;      tail.next = <span class="hljs-keyword">new</span> Node(value, <span class="hljs-keyword">null</span>);      tail = tail.next;    &#125;  &#125;  <span class="hljs-comment">// 出队</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    String value = head.data;    head = head.next;    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;      tail = <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-keyword">return</span> value;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printAll</span><span class="hljs-params">()</span> </span>&#123;    Node p = head;    <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;      System.out.print(p.data + <span class="hljs-string">" "</span>);      p = p.next;    &#125;    System.out.println();  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">private</span> String data;    <span class="hljs-keyword">private</span> Node next;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(String data, Node next)</span> </span>&#123;      <span class="hljs-keyword">this</span>.data = data;      <span class="hljs-keyword">this</span>.next = next;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> data;    &#125;  &#125;&#125;</code></pre><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>用数组来实现队列的时候，在 tail==n 时，会有<strong>数据搬移</strong>操作，这样入队操作性能就会受到影响。可以使用逻辑上数组首尾相连成环的循环队列解决这个问题。</p><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>确定好队空和队满的判定条件：</p><ul><li>队空：head == tail；</li><li>队满：(tail + 1) % n == head；</li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 基于数组实现的循环队列</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircularQueue</span> </span>&#123;  <span class="hljs-comment">// 数组：items，数组大小：n</span>  <span class="hljs-keyword">private</span> String[] items;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;  <span class="hljs-comment">// head表示队头下标，tail表示队尾下标</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tail = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 申请一个大小为capacity的数组</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CircularQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;    items = <span class="hljs-keyword">new</span> String[capacity];    n = capacity;  &#125;  <span class="hljs-comment">// 入队</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(String item)</span> </span>&#123;    <span class="hljs-comment">// 队列满了</span>    <span class="hljs-keyword">if</span> ((tail + <span class="hljs-number">1</span>) % n == head) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    items[tail] = item;    tail = (tail + <span class="hljs-number">1</span>) % n;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  &#125;  <span class="hljs-comment">// 出队</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 如果head == tail 表示队列为空</span>    <span class="hljs-keyword">if</span> (head == tail) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    String ret = items[head];    head = (head + <span class="hljs-number">1</span>) % n;    <span class="hljs-keyword">return</span> ret;  &#125;&#125;</code></pre><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>队列满时，tail指向的位置没有存储数据，所以循环队列会浪费一个数组的存储空间。</p><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><ul><li><p>在队列的基础上增加了阻塞操作；</p></li><li><p>队列为空时，从队头取数据会被阻塞；</p></li></ul><h3 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h3><p>线程安全的队列。</p><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>方式一：直接在enqueue()、dequeue() 上加锁，锁粒度大并发度会比较低下，同一时刻仅允许一个存取数操作。</p><p>方式二：利用 CAS 原子操作，可以实现非常高效的并发队列。</p><h3 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h3><ul><li>平时的业务很少直接用到队列；</li><li>一些具有特殊特性的队列应用比较广泛，比如循环队列、阻塞队列和并发队列；</li><li>循环队列比链式队列应用更加广泛；</li><li>高性能队列 Disruptor、Linux环形缓存，都用到了循环并发队列；</li><li>Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等；</li></ul><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>每个节点最多有两个子节点，即左子节点和右子节点。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul><li><p>节点高度 = 节点到叶子节点的最长路径（边数）；</p></li><li><p>节点深度 =  根节点到这个节点所经历的边的个数；</p></li><li><p>节点层数 = 节点深度 + 1；</p></li><li><p>树的高度 = 根节点的高度；</p></li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li><p>满二叉树：叶子节点全都在最底层，除叶子节点之外，每个节点都有左右两个子节点；</p></li><li><p>完全二叉树：叶子节点都在最底下两层，而且最后一层的叶子节点都靠左排列；</p></li><li><p>二叉查找树：最大的特点是支持<strong>动态数据集合的快速插入、删除、查找操作</strong>。树中的任意一个节点，</p><ul><li>其左子树中的每个节点的值，都要小于这个节点的值；</li><li>其右子树中的每个节点的值，都要大于这个节点的值；</li></ul></li></ul><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><h3 id="BST查找操作"><a href="#BST查找操作" class="headerlink" title="BST查找操作"></a>BST查找操作</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySearchTree</span> </span>&#123;  <span class="hljs-keyword">private</span> Node tree;  <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;    Node p = tree;    <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">if</span> (data &lt; p.data) p = p.left;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data &gt; p.data) p = p.right;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> p;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;  &#125;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data;    <span class="hljs-keyword">private</span> Node left;    <span class="hljs-keyword">private</span> Node right;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;      <span class="hljs-keyword">this</span>.data = data;    &#125;  &#125;&#125;</code></pre><h3 id="BST的插入操作"><a href="#BST的插入操作" class="headerlink" title="BST的插入操作"></a>BST的插入操作</h3><p>二叉查找树的插入过程有点类似查找操作。新插入的数据<strong>一般都是在叶子节点</strong>上，所以只需要从根节点开始，依次<strong>比较要插入的数据和节点的大小关系</strong>。</p><ul><li>如果要插入的数据比节点的数据大：<ol><li>并且节点的右子树为空，就将新数据直接插到右子节点的位置；</li><li>如果不为空，就递归遍历右子树，查找插入位置；</li></ol></li><li>如果要插入的数据比节点数值小：<ol><li>并且节点的左子树为空，就将新数据直接插到左子节点的位置；</li><li>如果不为空，就递归遍历左子树，查找插入位置；</li></ol></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;  <span class="hljs-keyword">if</span> (tree == <span class="hljs-keyword">null</span>) &#123;    tree = <span class="hljs-keyword">new</span> Node(data);    <span class="hljs-keyword">return</span>;  &#125;  Node p = tree;  <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">if</span> (data &gt; p.data) &#123;      <span class="hljs-keyword">if</span> (p.right == <span class="hljs-keyword">null</span>) &#123;        p.right = <span class="hljs-keyword">new</span> Node(data);        <span class="hljs-keyword">return</span>;      &#125;      p = p.right;    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// data &lt; p.data</span>      <span class="hljs-keyword">if</span> (p.left == <span class="hljs-keyword">null</span>) &#123;        p.left = <span class="hljs-keyword">new</span> Node(data);        <span class="hljs-keyword">return</span>;      &#125;      p = p.left;    &#125;  &#125;&#125;</code></pre><h3 id="BST的删除操作"><a href="#BST的删除操作" class="headerlink" title="BST的删除操作"></a>BST的删除操作</h3><p>BST的删除操作相对复杂，针对要删除节点的子节点个数的不同，需要分三种情况来处理。</p><ul><li>如果<strong>要删除的节点没有子节点</strong>，只需要直接将父节点中，指向要删除节点的指针置为 null。</li><li>如果<strong>要删除的节点只有一个子节点</strong>（只有左子节点或者右子节点），只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。</li><li>如果<strong>要删除的节点有两个子节点</strong>。那么需要<strong>找到这个节点的右子树中的最小节点</strong>，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;  Node p = tree; <span class="hljs-comment">// p指向要删除的节点，初始化指向根节点</span>  Node pp = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// pp记录的是p的父节点</span>  <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; p.data != data) &#123;    pp = p;    <span class="hljs-keyword">if</span> (data &gt; p.data) p = p.right;    <span class="hljs-keyword">else</span> p = p.left;  &#125;  <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 没有找到</span>  <span class="hljs-comment">// 要删除的节点有两个子节点</span>  <span class="hljs-keyword">if</span> (p.left != <span class="hljs-keyword">null</span> &amp;&amp; p.right != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 查找右子树中最小节点</span>    Node minP = p.right;    Node minPP = p; <span class="hljs-comment">// minPP表示minP的父节点</span>    <span class="hljs-keyword">while</span> (minP.left != <span class="hljs-keyword">null</span>) &#123;      minPP = minP;      minP = minP.left;    &#125;    p.data = minP.data; <span class="hljs-comment">// 将minP的数据替换到p中</span>    p = minP; <span class="hljs-comment">// 下面就变成了删除minP了</span>    pp = minPP;  &#125;  <span class="hljs-comment">// 删除节点是叶子节点或者仅有一个子节点</span>  Node child; <span class="hljs-comment">// p的子节点</span>  <span class="hljs-keyword">if</span> (p.left != <span class="hljs-keyword">null</span>) child = p.left;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.right != <span class="hljs-keyword">null</span>) child = p.right;  <span class="hljs-keyword">else</span> child = <span class="hljs-keyword">null</span>;  <span class="hljs-keyword">if</span> (pp == <span class="hljs-keyword">null</span>) tree = child; <span class="hljs-comment">// 删除的是根节点</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pp.left == p) pp.left = child;  <span class="hljs-keyword">else</span> pp.right = child;&#125;</code></pre><h3 id="BST的其他操作"><a href="#BST的其他操作" class="headerlink" title="BST的其他操作"></a>BST的其他操作</h3><ul><li>除了<strong>插入、删除、查找</strong>操作之外，二叉查找树中还可以支持快速地<strong>查找最大节点</strong>和<strong>最小节点</strong>、<strong>前驱节点</strong>和<strong>后继节点</strong>；</li><li>二叉查找树除了支持上面几个操作之外，还有一个重要的特性，就是<strong>中序遍历二叉查找树，可以输出有序的数据序列</strong>，时间复杂度是 O(n)，非常高效。因此，二叉查找树也叫作<strong>二叉排序树</strong>；</li><li>支持重复数据的二叉查找树： <ul><li>很多时候，在二叉查找树中存储的是一个包含很多字段的对象。利用对象的某个字段作为<strong>键值</strong>来构建二叉查找树。对象中的其他字段叫作<strong>卫星数据</strong>；</li></ul></li></ul><h3 id="散列表与BST"><a href="#散列表与BST" class="headerlink" title="散列表与BST"></a>散列表与BST</h3><p>散列表也支持这些操作，且相比于二叉查找树更高效，时间复杂度是 O(1)。思考这两种数据结构的适用场景。</p><ul><li>散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。BST中序遍历可以在 O(n) 时间复杂度内输出有序的数据序列；</li><li>散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定；尽管二叉查找树的性能不稳定，但是在工程中，最常用的平衡二叉查找树的性能稳定，时间复杂度稳定在 O(logn)；</li><li>尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定比平衡二叉查找树的效率高；</li><li>散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定；</li><li>为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间；</li></ul><p>综合这几点，平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲突。实际的开发过程中，需要结合具体的需求来选择使用哪一个。</p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><ul><li><p>链式存储法</p></li><li><p>顺序存储法</p></li></ul><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>将所有节点都遍历打印出来。经典的方法有<strong>前序遍历、中序遍历和后序遍历</strong>。其中，前、中、后序，表示的是<strong>节点与它的左右子树节点</strong>遍历打印的<strong>先后顺序</strong>。二叉树的前、中、后序遍历是一个<strong>递归</strong>的过程。时间复杂度均为O(n)；</p><ul><li>前序遍历：根-&gt;左子树-&gt;右子树；</li><li>中序遍历：左子树-&gt;根-&gt;右子树；</li><li>后序遍历：左子树-&gt;右子树-&gt;根；</li></ul><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><ul><li>一个完全二叉树；</li><li>每一个节点的值都必须大于等于（或小于等于）其子树中的每个节点的值；</li></ul><h2 id="存储-1"><a href="#存储-1" class="headerlink" title="存储"></a>存储</h2><p>完全二叉树比较适合用数组来存储。用数组来存储完全二叉树节省存储空间。通过数组的下标，可以找到一个节点的左右子节点和父节点，而不需要存储左右子节点的指针。假设节点在数组中的下标为 i，那么：</p><ul><li>其父节点的下标为 i/2；</li><li>其左子节点的下标为 i∗2；</li><li>其右子节点的下标为 i∗2+1；</li></ul><h2 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h2><p>插入一个元素和删除堆顶元素。</p><h2 id="基于堆实现排序"><a href="#基于堆实现排序" class="headerlink" title="基于堆实现排序"></a>基于堆实现排序</h2><ol><li>建堆<ul><li>思路1：从前往后处理数组，并且每个数据插入堆中时，都是从下往上堆化；</li><li>思路2：从后往前处理数组，并且每个数据都是从上往下堆化</li></ul></li><li>第二步：排序<ol><li>堆顶跟最后一个元素交换，把下标为n的元素放到堆顶，通过堆化的方法，将剩下的 n - 1 个元素重新构建成堆；</li><li>堆化完成之后，取堆顶的元素，放到下标是 n - 1 的位置；</li><li>一直重复这个过程，直到最后堆中只剩下标为 1 的一个元素，排序工作完成</li></ol></li></ol><h3 id="快速排序与堆排序"><a href="#快速排序与堆排序" class="headerlink" title="快速排序与堆排序"></a>快速排序与堆排序</h3><ul><li><p>堆排序数据访问的方式没有快速排序友好</p><ul><li><p>对于快速排序来说，数据是顺序访问的；</p></li><li><p>对于堆排序来说，数据是跳着访问的；</p><ul><li>堆排序中，最重要的一个操作就是数据的堆化。对堆顶节点进行堆化，访问数组的元素对应的下标是跳跃的，快速排序则是局部顺序访问。所以，堆排序<strong>对 CPU 缓存是不友好的</strong>。</li></ul></li></ul></li><li><p>同样的数据，在排序过程中，堆排序算法的数据交换次数多于快速排序</p><ul><li>排序的时候有序度和逆序度两个概念；</li><li>对于<strong>基于比较的排序算法</strong>来说，整个排序过程就是由<strong>比较和交换（或移动）</strong>这两个基本的操作组成的；</li><li><strong>快速排序数据交换的次数不会比逆序度多</strong>，但是堆排序的第一步是建堆，<strong>建堆</strong>的过程会打乱数据原有的相对先后顺序，<strong>导致原数据的有序度降低</strong>。比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了；</li></ul></li><li><p>所以，快速排序比堆排序性能好</p></li></ul><h2 id="堆内容小结"><a href="#堆内容小结" class="headerlink" title="堆内容小结"></a>堆内容小结</h2><ul><li>堆是一种<strong>完全二叉树</strong>。它最大的特性是：<strong>每个节点的值都大于等于（或小于等于）其子树节点的值</strong>。因此，堆被分成了两类，<strong>大顶堆和小顶堆</strong>；</li><li>堆中比较重要的两个操作是<strong>插入一个数据</strong>和<strong>删除堆顶元素</strong>。这两个操作都要用到堆化；<ul><li><strong>插入</strong>一个数据的时候，把新插入的数据<strong>放到数组的最后</strong>，然后<strong>从下往上堆化</strong>；</li><li><strong>删除堆顶数据</strong>的时候，把数组中的<strong>最后一个元素放到堆顶</strong>，然后从<strong>上往下堆化</strong>；</li><li>这两个操作时间复杂度都是 O(logn)；</li></ul></li><li>堆排序，堆排序包含两个过程：</li><li>建堆和排序；<ul><li>建堆：将<strong>下标从 n/2 到 1 的节点</strong>，依次进行<strong>从上到下的堆化操作</strong>，就可以将数组中的数据组织成堆这种数据结构；</li><li>排序：<strong>迭代地将堆顶的元素放到堆的末尾，并将堆的大小减一，然后再堆化</strong>。重复这个过程，直到堆中只剩下一个元素，整个数组中的数据就都<strong>有序排列</strong>了；</li></ul></li><li><strong>优先级队列</strong>是一种特殊的队列，优先级高的数据先出队，不像普通的队列那样，先进先出。实际上，<strong>堆就可以看作优先级队列</strong>，只是称谓不一样罢了；</li><li><strong>Top K 问题</strong>可以分为<strong>针对静态数据</strong>和<strong>针对动态数据</strong>，只需要利用一个堆，就可以做到非常高效率的查询 Top K 的数据；</li><li><strong>求中位数</strong>实际上还有很多变形，比如<strong>求 99 百分位数据、90 百分位数据</strong>等，处理的思路都是一样的，即<strong>利用两个堆，一个大顶堆，一个小顶堆</strong>，随着数据的动态添加，<strong>动态调整两个堆中的数据</strong>，最后<strong>大顶堆的堆顶元素就是要求的数据</strong>；</li></ul><h2 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h2><h3 id="实现优先级队列"><a href="#实现优先级队列" class="headerlink" title="实现优先级队列"></a>实现优先级队列</h3><p>队列最大的特性就是先进先出。在优先级队列中，数据的出队顺序不是先进先出，而是按照<strong>优先级</strong>来，优先级最高的，最先出队。</p><p>实现一个优先级队列的方法有很多，但是用堆来实现是<strong>最直接、最高效</strong>的。这是因为，堆和优先级队列非常相似。一个堆就可以看作一个优先级队列。很多时候，它们只是概念上的区分而已。<strong>往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素</strong>。</p><p>优先级队列的应用场景非常多。很多数据结构和算法都要依赖它。比如，赫夫曼编码、图的最短路径、最小生成树算法等等。很多语言都提供了优先级队列的实现，Java 的 PriorityQueue，C++ 的 priority_queue 等。</p><h3 id="合并有序小文件"><a href="#合并有序小文件" class="headerlink" title="合并有序小文件"></a>合并有序小文件</h3><p>假设有 100 个小文件，每个文件的大小是 100MB，每个文件中存储的都是有序的字符串。希望将这些 100 个小文件合并成一个有序的大文件。</p><p><strong>方法一：</strong>整体思路有点像归并排序中的合并函数：</p><ul><li>从这 100 个文件中，<strong>各取第一个字符串</strong>，放入数组中，然后比较大小，把<strong>最小的字符串</strong>放入合并后的大文件中，并从数组中删除；</li><li>假设，这个最小的字符串来自于 a.txt 这个小文件，就再从这个小文件<strong>取下一个字符串</strong>，放到数组中，<strong>重新比较大小</strong>，并且选择最小的放入合并后的大文件，将它从数组中删除；</li><li>依次类推，直到所有的文件中的数据都放入到大文件为止；</li><li>这里用数组这种数据结构，来存储从小文件中取出来的字符串。每次从数组中取最小字符串，都需要循环遍历整个数组，显然，这不是很高效。</li></ul><p><strong>方法二：</strong>优先级队列，也可以说是堆：</p><ul><li>把小文件中取出来的字符串放入到小顶堆中，<strong>堆顶的元素就是优先级队列队首的元素</strong>，就是最小的字符串；</li><li>将这个字符串放入到大文件中，并将其从堆中删除；</li><li>再从小文件中取出下一个字符串，放入到堆中；</li><li>循环这个过程，就可以将 100 个小文件中的数据依次放入到大文件中；</li><li>删除堆顶数据和往堆中插入数据的时间复杂度都是 O(logn)，n 表示堆中的数据个数，这里就是 100。该方法比原来数组存储的方式高效；</li></ul><h3 id="高性能定时器"><a href="#高性能定时器" class="headerlink" title="高性能定时器"></a>高性能定时器</h3><p>假设有一个定时器，定时器中维护了很多定时任务，每个任务都设定了一个要触发执行的时间点。<strong>定时器每过一个很小的单位时间（比如 1 秒），就扫描一遍任务，看是否有任务到达设定的执行时间。如果到达了，就拿出来执行。</strong></p><p>但是，这样每过 1 秒就扫描一遍任务列表的做法比较低效，主要原因有两点：</p><ul><li>任务的约定执行时间离当前时间可能还有很久，这样前面很多次扫描其实都是徒劳的；</li><li>每次都要扫描整个任务列表，如果任务列表很大的话，势必会比较耗时。</li></ul><p>针对这些问题，可以用优先级队列来解决：</p><ul><li>按照任务设定的执行时间，将这些任务存储在优先级队列中，<strong>队列首部（也就是小顶堆的堆顶）存储的是最先执行的任务</strong>；<ul><li>这样，定时器就不需要每隔 1 秒就扫描遍历任务列表了；</li></ul></li><li>取队首任务的执行时间点，与当前时间点相减，得到一个<strong>时间间隔 T</strong>。这个时间间隔 T 就是，从当前时间开始，需要等待多久，才会有第一个任务需要被执行。这样，<strong>定时器就可以设定在 T 秒之后，定时器取优先级队列中队首的任务执行</strong>。<ul><li>这样，当前时间点到（T-1）秒这段时间里，定时器都不需要做任何事情；</li></ul></li><li>再计算新的队首任务的执行时间点与当前时间点的差值，把这个值作为定时器执行下一个任务需要等待的时间；</li><li><strong>循环以上操作</strong>，定时器既不用间隔 1 秒就轮询一次，也不用遍历整个任务列表，性能就提高了。</li></ul><h3 id="针对静态-动态数据集合求Top-K"><a href="#针对静态-动态数据集合求Top-K" class="headerlink" title="针对静态/动态数据集合求Top K"></a>针对静态/动态数据集合求Top K</h3><ul><li>针对静态数据集合，也就是说数据集合事先确定，不会再变；<ul><li>在一个包含 n 个数据的数组中，查找前 K 大数据：<ul><li><strong>维护一个大小为 K 的小顶堆</strong>，顺序遍历数组，从数组中取出数据与堆顶元素比较：<ul><li>若比堆顶元素大，就把堆顶元素删除，并且将这个元素插入到堆中；</li><li>若比堆顶元素小，则不做处理，继续遍历数组；</li><li>遍历数组中的数据，遍历结束后，堆中的数据就是前 K 大数据了。</li></ul></li><li>遍历数组需要 O(n) 的时间复杂度，<strong>一次堆化操作需要 O(logK)</strong> 的时间复杂度，所以最坏情况下，n 个元素都入堆一次，时间复杂度就是 O(nlogK)。</li></ul></li></ul></li><li>针对动态数据集合，也就是说数据集合事先并不确定，有数据动态地加入到集合中：<ul><li>针对动态数据求得 Top K 就是实时 Top K。一个数据集合中有两个操作，一个是<strong>添加数据</strong>，另一个询问<strong>当前的前 K 大数据</strong>：<ul><li>如果每次询问前 K 大数据，都基于当前的数据重新计算的话，那时间复杂度就是 O(nlogK)，n 表示当前的数据的大小。</li><li>实际上，可以一直都<strong>维护一个 K 大小的小顶堆</strong>，当有数据被添加到集合中时，将其与堆顶的元素对比：<ul><li>若比堆顶元素大，就把堆顶元素删除，并且将这个元素插入到堆中；</li><li>若比堆顶元素小，则不做处理；</li><li>这样，无论任何时候需要查询当前的前 K 大数据，都可以立刻将结果返回。</li></ul></li></ul></li></ul></li></ul><h3 id="热榜-Top10-关键词"><a href="#热榜-Top10-关键词" class="headerlink" title="热榜 Top10 关键词"></a>热榜 Top10 关键词</h3><p>处理这个问题，有很多高级的解决方法，比如使用 MapReduce 等。</p><p>将处理的场景限定为单机，可以使用的内存为 1GB，该问题的可选解决方案为：</p><ul><li>用户搜索的关键词，有很多可能都是重复的，所以首先要统计每个搜索关键词出现的频率。可以通过<strong>散列表、平衡二叉查找树或者其他一些支持快速查找、插入的数据结构</strong>，来记录关键词及其出现的次数；<ul><li>假设选用<strong>散列表</strong>，可以顺序扫描这 10 亿个搜索关键词。当扫描到某个关键词时，就去散列表中查询：<ul><li>如果存在，将对应的次数加一；</li><li>如果不存在，将它插入到散列表，并记录次数为 1；</li><li>遍历完这 10 亿个搜索关键词之后，散列表中就存储了不重复的搜索关键词以及出现的次数；</li></ul></li></ul></li><li>然后，再根据前面讲的<strong>用堆求 Top K 的方法</strong>，建立一个大小为 10 的小顶堆，遍历散列表，依次取出每个搜索关键词及对应出现的次数，然后与堆顶的搜索关键词对比。如果出现次数比堆顶搜索关键词的次数多，那就删除堆顶的关键词，将这个出现次数更多的关键词加入到堆中；</li><li>以此类推，当遍历完整个散列表中的搜索关键词之后，堆中的搜索关键词就是出现次数最多的 Top 10 搜索关键词了；</li><li><strong>上面的解决思路其实存在漏洞</strong>。10 亿的关键词还是很多的。假设 10 亿条搜索关键词中不重复的有 1 亿条，如果每个搜索关键词的平均长度是 50 个字节，那存储 1 亿个关键词起码需要 <strong>5GB</strong> 的内存空间，而散列表因为要避免频繁冲突，不会选择太大的装载因子，所以<strong>消耗的内存空间就更多</strong>了。而<strong>机器只有 1GB 的可用内存空间</strong>，所以无法一次性将所有的搜索关键词加入到内存中。</li><li>在哈希算法那一节讲过，<strong>相同数据经过哈希算法得到的哈希值是一样的</strong>。可以根据哈希算法的这个特点，<strong>将 10 亿条搜索关键词先通过哈希算法分片到 10 个文件中</strong>。具体可以这样做：<ul><li>创建 10 个空文件 00，01，02，……，09；</li><li><strong>遍历这 10 亿个关键词，并且通过某个哈希算法对其求哈希值，然后哈希值同 10 取模，</strong>得到的结果就是这个搜索关键词应该被分到的文件编号；</li></ul></li><li>对这<strong>10亿个关键词分片</strong>之后，每个文件都只有 1 亿的关键词，去除掉重复的，可能就只有 1000 万个，每个关键词平均 50 个字节，所以总的大小就是 500MB。1GB 的内存完全可以放得下；</li><li><strong>针对每个包含 1 亿条搜索关键词的文件，利用散列表和堆，分别求出 Top 10</strong>，然后把这个 10 个 Top 10 放在一块，然后取这 100 个关键词中，出现次数最多的 10 个关键词，这就是这 10 亿数据中的 Top 10 最频繁的搜索关键词了；</li></ul><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>一种非线性表数据结构，比树要复杂</p><h2 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h2><ul><li><p>有向图</p></li><li><p>无向图</p></li><li><p>带权图</p></li></ul><h2 id="存储-2"><a href="#存储-2" class="headerlink" title="存储"></a>存储</h2><h3 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h3><p>缺点：浪费存储空间</p><p>优点：存储方式简单、直接、方便计算</p><p>应用：Floyd-Warshall算法</p><h3 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h3><ul><li>查询效率没有邻接矩阵存储方式高；</li><li>如果链过长，可以将链表转换成其他更高效的数据结构，比如平衡二叉查找树；</li><li>实际开发中，用红黑树或者其他动态数据结构，比如跳表、散列表等，更加快速地查找两个顶点之间是否存在边；</li><li>将链表改成有序动态数组，通过二分查找的方法快速定位两个顶点之间是否存在边；</li></ul><h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><ul><li><p>通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置；</p></li><li><p>当按照键值查询元素时，可以用同样的散列函数，将键值转化为数组下标，从对应的数组下标的位置取元素；</p></li><li><p>数组的一种扩展，由数组演化而来。没有数组，就没有散列表。</p></li></ul><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>hash(key)（key表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值）。</p><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><p>散列函数计算得到的散列值是一个非负整数。</p><ul><li><p>如果 key1 == key2, 那么 hash(key1) == hash(key2)</p></li><li><p>如果 key1 != key2, 那么 hash(key1) != hash(key2)</p></li></ul><h3 id="设计要点"><a href="#设计要点" class="headerlink" title="设计要点"></a>设计要点</h3><ul><li><p>散列函数的设计不能太过复杂；</p></li><li><p>散列函数生成的值要尽可能随机并且均匀分布；</p></li></ul><h2 id="装载因子"><a href="#装载因子" class="headerlink" title="装载因子"></a>装载因子</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>散列表的装载因子 = 填入表中的元素个数 / 散列表的长度；</p><ul><li>装填因子越大，说明空闲的位置越少，冲突越多，散列表的性能会下降；</li></ul><h3 id="装载因子过大怎么办"><a href="#装载因子过大怎么办" class="headerlink" title="装载因子过大怎么办"></a>装载因子过大怎么办</h3><ul><li>当装载因子过大时，可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到新散列表中；</li><li>针对散列表的扩容，数据搬移操作比数组要复杂的多，需要通过散列函数重新计算每个数据的存储位置；</li></ul><h2 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h2><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>如果出现散列冲突，就重新探测一个空闲位置，将其插入。</p><h4 id="应用-5"><a href="#应用-5" class="headerlink" title="应用"></a>应用</h4><p>数据量比较小，装载因子小的时候，适合采用开放寻址法。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><p>散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度；</p></li><li><p>这样实现的散列表，序列化起来比较简单；</p></li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li><p>删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据；</p></li><li><p>装载因子的上限不能太大；</p></li></ul><h4 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h4><p>往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p><h4 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a>二次探测</h4><p>和线性探测有共同点：</p><ul><li><p>线性探测每次探测的步长是1，探测的下标序列就是hash(key) + 0，hash(key) + 1，hash(key) + 2，……</p></li><li><p>二次探测探测的步长就变成了原来的“二次方”，探测的下标序列就是hash(key) + 0，hash(key) + 1^2，hash(key) + 2^2，……</p></li></ul><h4 id="双重散列"><a href="#双重散列" class="headerlink" title="双重散列"></a>双重散列</h4><p>先用一组散列表中的第一个散列函数，计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p><h3 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h3><p>一种更加常用的散列冲突的解决办法，比开放寻址法简单很多。</p><p>每个“桶”（bucket）或者”槽“（slot）会对应一条链表。所有散列值相同的元素都放到相同槽位对应的链表中。</p><h4 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a>操作</h4><ul><li><p>插入时，只需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表中即可；</p></li><li><p>查找、删除一个元素时，同样通过散列函数计算出对应的槽，遍历链表查找或者删除；</p></li></ul><h4 id="应用-6"><a href="#应用-6" class="headerlink" title="应用"></a>应用</h4><ul><li><p>适合存储大对象，大数据量的散列表；</p></li><li><p>更加灵活、支持更多的优化策略，比如用红黑树代替链表；</p></li></ul><h2 id="散列表的应用"><a href="#散列表的应用" class="headerlink" title="散列表的应用"></a>散列表的应用</h2><h3 id="LRU淘汰缓存算法"><a href="#LRU淘汰缓存算法" class="headerlink" title="LRU淘汰缓存算法"></a>LRU淘汰缓存算法</h3><p>一个缓存（cache）系统主要包含下面这几个操作：</p><ul><li>往缓存中<strong>添加</strong>一个数据；</li><li>从缓存中<strong>删除</strong>一个数据；</li><li>在缓存中<strong>查找</strong>一个数据。</li></ul><p>维护一个按照访问时间从大到小有序排列的链表结构。因为缓存大小有限，当缓存空间不够，需要淘汰一个数据的时候，直接将链表<strong>头部</strong>的结点删除。</p><p>当要缓存某个数据的时候，先在链表中查找这个数据：</p><ul><li>如果没有找到，直接将数据放到链表的尾部；</li><li>如果找到了，把它移动到链表的尾部；</li><li>因为查找数据需要遍历链表，所以单纯用链表实现的 LRU 缓存淘汰算法的时间复杂很高，是 O(n)。</li></ul><p>如果将<strong>散列表</strong>和<strong>链表</strong>两种数据结构组合使用，可以将这三个操作的时间复杂度都降低到 O(1)。</p><p>pre和next组成<strong>双向链表</strong>，这个链表是按照缓存的时间由大到小，组成的一个<strong>缓存队列</strong>；</p><p>hnext（使用<strong>链表法</strong>解决冲突的<strong>散列表中的链表的next指针</strong>）的作用是，（当发生哈希冲突时）在链表中<strong>插入缓存数据</strong>时，用于<strong>哈希值相等的缓存数据的连接</strong>。</p><p><img src="LRU.PNG" srcset="/img/loading.gif" alt=""></p><p><strong>散列表和链表经常一块使用</strong>。散列表虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数<strong>打乱之后无规律存储</strong>的。</p><p>它<strong>无法支持按照某种顺序快速地遍历数据</strong>。如果希望按照<strong>顺序</strong>遍历散列表中的数据，需要将散列表中的数据拷贝到数组中，然后排序，再遍历。因为<strong>散列表是动态数据结构</strong>，不停地有数据的插入、删除，所以<strong>按序遍历散列表</strong>中的数据的时候，需要<strong>先排序，效率很低</strong>。为了解决这个问题，将散列表和链表（或者跳表）结合在一起使用。</p><h3 id="Word-拼写检查实现"><a href="#Word-拼写检查实现" class="headerlink" title="Word 拼写检查实现"></a>Word 拼写检查实现</h3><p>常用的英文单词有 20 万个左右，假设单词的平均长度是 10 个字母，平均一个单词占用 10 个字节的内存空间，那 20 万英文单词大约占 2MB 的存储空间，就算放大 10 倍也就是 20MB。</p><p>这个大小完全可以放在内存里面。所以<strong>可以用散列表来存储整个英文单词词典</strong>。当用户输入某个英文单词时，拿用户输入的单词<strong>去散列表中查找</strong>。如果查到，则说明拼写正确；如果没有查到，则说明拼写可能有误，给予提示。借助散列表这种数据结构，就可以轻松实现快速判断是否存在拼写错误。</p><h2 id="工业级散列表特性"><a href="#工业级散列表特性" class="headerlink" title="工业级散列表特性"></a>工业级散列表特性</h2><ul><li><p>支持快速的查询、插入、删除操作；</p></li><li><p>内存占用合理，不能浪费过多的内存空间；</p></li><li><p>性能稳定，极度情况下，散列表的性能也不会退化到无法接受的情况；</p></li></ul><h3 id="实现工业级散列表要点"><a href="#实现工业级散列表要点" class="headerlink" title="实现工业级散列表要点"></a>实现工业级散列表要点</h3><ul><li><p>设计一个合适的散列表；</p></li><li><p>定义装载因子的阈值，并且设计动态扩容策略；</p></li><li><p>选择合适的散列冲突解决方法；</p></li></ul><h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><ul><li><p>将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法；</p></li><li><p>通过原始数据映射之后得到的二进制值串就是哈希值；</p></li></ul><h2 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a>设计步骤</h2><ul><li><p>从哈希值不能反向导出原始数据；</p></li><li><p>堆输入数据非常敏感，哪怕原始数据只修改了一个bit，最后得到的哈希值也大不相同；</p></li><li><p>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；</p></li><li><p>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速计算出哈希值；</p></li></ul><h2 id="应用-7"><a href="#应用-7" class="headerlink" title="应用"></a>应用</h2><ul><li><p>安全加密</p></li><li><p>唯一标识</p></li><li><p>数据校验</p></li><li><p>散列函数</p></li><li><p>负载均衡</p></li><li><p>数据分片</p></li><li><p>分布式存储</p></li></ul><h1 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h1><ul><li><p>一种特殊的散列表；</p></li><li><p>通过数组下标来定位数据，访问效率非常高；</p></li><li><p>每个数字用一个二进制位来表示，数字范围不大的情况下，需要的内存空间非常节省；</p></li></ul><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p><img src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%89%E4%B8%AA%E6%8C%87%E6%A0%87.png" srcset="/img/loading.gif" alt=""></p><p><img src="%E4%B8%89%E7%A7%8D%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 常用集合</title>
    <link href="/2020/07/22/Java%20%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/"/>
    <url>/2020/07/22/Java%20%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p>文章主要归纳介绍 Java 的集合框架与设计结构。包括 Java 提供的主要集合类型（Collections 和 Map）及其对应的数据结构、算法，并考虑不同场景下的具体技术选择。</p><a id="more"></a><h2 id="Java-集合框架设计结构"><a href="#Java-集合框架设计结构" class="headerlink" title="Java 集合框架设计结构"></a>Java 集合框架设计结构</h2><p>Java中提供了丰富的集合接口和类，它们来自于java.util包。Java集合类型分为：Collection和Map，Collection子接口有：Set、Queue和List等接口。每一种集合接口定义和描述了一种数据结构。</p><p><strong>Collection 接口</strong>是所有集合的根，然后扩展开提供了三大类集合，分别是：</p><ul><li><strong>List</strong>，有序集合，提供方便的访问、插入、删除等操作；</li><li><strong>Set</strong>，不允许重复元素，不存在两个对象 equals 返回 true。在需要保证元素唯一性的场景下使用较多；</li><li><strong>Queue/Deque</strong>，除了集合的基本功能，它还支持先入先出FIFO或后入先出LIFO等约束行为。并发包中有BlockingQueue。</li></ul><p><strong>Map</strong>允许按照某个键来访问元素。Map集合由两个集合构成：键集合，值集合。键集合是Set类型，不能有重复的元素。值集合是Collection类型，可以有重复的元素。</p><p>每种集合的通用逻辑，都被抽象到相应的抽象类之中，比如 AbstractList 就集中了各种 List 操作的通用部分。这些集合不是完全孤立的，例如LinkedList 实现了 List 和 Deque。</p><p><img src="java_collection.png" srcset="/img/loading.gif" alt=""></p><p><img src="java_map.png" srcset="/img/loading.gif" alt=""></p><p><strong>注：</strong></p><ul><li>Iterator通用迭代器、ListIterator针对 List 特化的迭代器</li><li>Comparator比较器、Comparable 排序接口</li><li>Collections常用算法类、Arrays静态数组的排序、查找算法</li></ul><h2 id="Java-主要集合类型"><a href="#Java-主要集合类型" class="headerlink" title="Java 主要集合类型"></a>Java 主要集合类型</h2><p>重点关注常用的实现类，掌握对应的数据结构、算法，能够根据不同的场景，进行具体的技术选择。</p><p><img src="java_common_collection.png" srcset="/img/loading.gif" alt=""></p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Vector、ArrayList 和 LinkedList 实现了 List，是<strong>有序集合</strong>。都提供按照位置进行定位、添加或者删除的操作，提供迭代器以遍历其内容等。但因为具体的设计区别，在行为、性能、线程安全等方面，表现又有很大不同。</p><ul><li>Vector 是 Java 早期提供的<strong>线程安全的动态数组</strong>，内部使用<strong>对象数组</strong>来保存数据。如果不需要线程安全，并不建议选择，毕竟同步有额外开销。可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据；</li><li>ArrayList 的应用更加广泛，使用<strong>动态数组</strong>实现，<strong>不是线程安全</strong>的，所以性能要好很多。ArrayList 也可以根据需要调整容量，两者的调整逻辑有所区别，<strong>Vector 在扩容时会提高 1 倍，而 ArrayList 增加 50%；</strong></li><li>LinkedList 是 Java 提供的<strong>双向链表</strong>，不需要像上面两种那样调整容量，但是因为存在额外的前驱和后继节点指针，所以占用的内存比 ArrayList 多一些。任意位置的插入删除很方便，不支持随机取值，只能从一端开始遍历，直到找到查询的对象。它<strong>不是线程安全的。</strong></li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>HashSet、LinkedHashSet 和 TreeSet 实现了Set。特点是<strong>元素不重复</strong>，<strong>存取无序</strong>。</p><ul><li>HashSet 以 HashMap 为基础实现。利用<strong>哈希算法</strong>，理想情况下添加、删除、包含等操作的<strong>时间复杂度为常数</strong>，它不保证有序。</li><li>LinkedHashSet 内部构建了一个记录插入顺序的双向链表，因此提供了<strong>按照插入顺序进行遍历</strong>的能力，也保证常数时间的包含、添加、删除等操作，这些<strong>操作性能略低于 HashSet</strong>，因为需要维护链表的开销；</li><li>TreeSet 默认利用 TreeMap 实现。支持自然顺序访问，包含、添加、删除、等操作相对低效（log(n) ）；</li></ul><p>在遍历元素时，HashSet 性能受自身容量影响，所以初始化时，除非有必要，不然不要将其背后的 HashMap 容量设置过大。而对于 LinkedHashSet，由于其内部链表提供的方便，所以遍历性能只和元素多少有关系。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Hashtable、HashMap、TreeMap 是最常见的 Map 的实现，<strong>以键值对的形式存储和操作数据的集合类型。</strong></p><ul><li>Hashtable 是早期 Java 类库提供的一个哈希表实现，本身<strong>是同步的</strong>，<strong>不支持 null 键和值</strong>，由于同步导致的性能开销，所以已经<strong>很少被推荐使用</strong>；</li><li>HashMap 应用更加广泛，利用哈希表实现。<strong>HashMap 不是同步的，支持 null 键和值等</strong>。通常情况下HashMap 的 put 或 get 操作的时间复杂度为常数。所以它是<strong>绝大部分利用键值对存取场景的首选</strong>，比如，实现一个用户 ID 和用户信息对应的运行时存储结构；<ul><li>大部分使用 Map 的场景，通常就是<strong>放入、访问或者删除</strong>，对顺序没有特别要求，HashMap 在这种情况下基本是最好的选择。</li></ul></li><li>LinkedHashMap 继承于HashMap，是基于HashMap和双向链表来实现的。LinkedHashMap 是有序的，可分为插入顺序和访问顺序。如果是访问顺序，那put和get操作已存在的Entry时，都会<strong>把Entry移动到双向链表的表尾(</strong>其实是先删除再插入)，存取数据时和 HashMap 一样，使用 Entry[] 的方式，双向链表只是为了保证顺序。LinkedHashMap <strong>不是线程安全</strong>的；<ul><li>这种特点适用于一些特定应用场景，例如：构建一个空间占用敏感的资源池，可以自动将最不常被访问的对象释放。那么，表满时需要删除时候就是头部元素。</li></ul></li><li>TreeMap 是基于<strong>红黑树</strong>实现的一种按序访问的 Map，TreeMap能够把它保存的记录根据键进行排序，默认是按键值的升序排序，也可以指定排序的比较器，具体顺序可以由指定的 <strong>Comparator</strong> 决定。用 Iterator 遍历时，得到的记录是排过序的。它的 get、put、remove 操作的时间复杂度是 O(log(n))，所以TreeMap实际使用的比较少。<ul><li>TreeMap 和 LinkedHashMap 都可以保证某种顺序，但二者还是不同的。TreeMap 的整体顺序由键的顺序关系决定，即通过 Comparator 或 Comparable（自然顺序）决定。</li></ul></li></ul><h4 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h4><p>HashMap 的性能表现非常依赖于哈希值的有效性，需要掌握相关内容。</p><h5 id="Java中equals和-的区别"><a href="#Java中equals和-的区别" class="headerlink" title="Java中equals和==的区别"></a>Java中equals和==的区别</h5><ul><li>== 的作用：<ul><li>基本类型：比较的就是值是否相同；</li><li>引用类型：比较的就是地址值是否相同</li></ul></li><li>equals() 的作用：<ul><li>引用类型：默认情况下，比较的是地址值。但是一般来说，意义不大。所以，一些类库重写了这个方法，如String、Integer、Date。这些类当中 equals 有其自身的实现，一般是用来比较对象的成员变量值是否相同，而不再是比较类在堆内存中的存放地址了。</li></ul></li></ul><h5 id="hashCode（）与-equals（）的相关规定"><a href="#hashCode（）与-equals（）的相关规定" class="headerlink" title="hashCode（）与 equals（）的相关规定"></a>hashCode（）与 equals（）的相关规定</h5><ul><li>如果两个对象相等（equals 相等），那么 hashCode 一定相等；</li><li>两个对象相等，对两个对象分别调用 equals 方法都返回 true；</li><li>两个对象有相同的哈希值(hash code)，它们不一定相等；</li><li>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖，所以<strong>重写了 equals 也要重写 hashCode；</strong></li><li>equals 有对称、反射、传递等特性。</li></ul><h4 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h4><p>掌握HashMap 设计与实现的基本原理与方法，对深入理解集合和数据结构有一些帮助。</p><ul><li>HashMap 内部实现基本点分析;</li><li>容量（capacity）和负载系数（load factor）;</li><li>树化 。</li></ul><p>HashMap 内部的结构如下图，它可以看作是<strong>数组和链表结合组成</strong>的复合结构，数组被分为一个个<strong>桶</strong>，通过<strong>哈希值决定键值对在这个数组的寻址</strong>；<strong>哈希值相同的键值对，则以链表形式存储</strong>。需要注意的是，如果链表大小超过阈值（TREEIFY_THRESHOLD, 8），链表就会被改造为树形结构。</p><p><img src="hash_buckets.png" srcset="/img/loading.gif" alt=""></p><h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h5><p>putVal 方法逻辑比较集中，从初始化、扩容到树化都和它有关，阅读源码时需要多加关注。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><span class="hljs-function"><span class="hljs-params">               <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;    HashMap.Node&lt;K,V&gt;[] tab; HashMap.Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)        n = (tab = resize()).length;    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span>            treeifyBin(tab, hash);    &#125;    <span class="hljs-keyword">if</span> (++size &gt; threshold)        resize();&#125;</code></pre><ul><li><p>如果表格是 null，resize 方法会初始化它；</p></li><li><p>resize 方法兼顾两个职责，创建初始存储表格，或者在容量不满足需求的时候，进行扩容resize；</p></li><li><p>在放置新的键值对的过程中，如果++size &gt; threshold，就会发生扩容</p></li><li><p>具体键值对在哈希表中的位置（数组 index）取决于下面的位运算：</p><pre><code class="hljs java">i = (n - <span class="hljs-number">1</span>) &amp; hash</code></pre></li></ul><p>将高位数据移位到低位进行异或运算的原因是：有些数据计算出的哈希值差异主要在高位，而 HashMap 里的哈希寻址是忽略容量以上的高位的，这种处理可以有效避免类似情况下的哈希碰撞。</p><pre><code class="hljs processing"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> hash(<span class="hljs-keyword">Object</span> kye) &#123;    <span class="hljs-built_in">int</span> h;    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">key</span> == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = <span class="hljs-built_in">key</span>.hashCode()) ^ (h &gt;&gt;&gt;<span class="hljs-number">16</span>;&#125;</code></pre><h5 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h5><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;    Node&lt;K,V&gt;[] oldTab = table;    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;    <span class="hljs-keyword">int</span> oldThr = threshold;    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;            threshold = Integer.MAX_VALUE;            <span class="hljs-keyword">return</span> oldTab;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span>        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span>            newCap = oldThr;        <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span>            newCap = DEFAULT_INITIAL_CAPACITY;            newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);        &#125;        <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?                      (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);        &#125;        threshold = newThr;        <span class="hljs-meta">@SuppressWarnings</span>(&#123;<span class="hljs-string">"rawtypes"</span>,<span class="hljs-string">"unchecked"</span>&#125;)            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];        table = newTab;        <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// ....</span>    &#125;        <span class="hljs-keyword">return</span> newTab;</code></pre><ul><li>不考虑极端情况，容量理论最大极限由 MAXIMUM_CAPACITY 指定，数值为 1&lt;&lt;30，也就是 2 的 30 次方；</li><li>门限值 = 负载因子 x 容量，如果构建 HashMap 的时候没有指定，那么依据相应的默认常量值；</li><li>门限通常以倍数进行调整 （newThr = oldThr &lt;&lt; 1），当元素个数超过门限大小时，则调整 Map 大小；</li><li>扩容后，需要将老的数组中的元素重新放置到新的数组，这是扩容的一个主要开销来源。</li></ul><h5 id="容量、负载因子和树化"><a href="#容量、负载因子和树化" class="headerlink" title="容量、负载因子和树化"></a>容量、负载因子和树化</h5><p>容量和负载系数决定了可用的桶的数量：</p><ul><li>空桶太多会浪费空间；</li><li>可用空间较少则会严重影响操作的性能。<ul><li>极端情况下，假设只有一个桶，就退化成了链表，操作的时间复杂度不能保证。</li></ul></li></ul><p>对于<strong>容量</strong>，如果能够知道 HashMap 要存取的键值对数量，可以考虑预先设置合适的容量大小。需要满足：</p><ul><li>负载因子 * 容量 &gt; 元素数量，所以预先设置的容量需要大于 “预估元素数量 / 负载因子”；</li><li>是 2 的幂数；</li></ul><p>对于<strong>负载因子</strong>：</p><ul><li>如果没有特别需求，不要轻易进行更改，因为 JDK 自身的默认负载因子是非常符合通用场景的需求的；</li><li>如果确实需要调整，建议不要设置超过 0.75 的数值，因为会显著增加冲突，降低 HashMap 的性能；</li><li>如果使用太小的负载因子，按照上面的公式，可能会导致频繁的扩容，增加无谓的开销，本身访问性能也会受影响。</li></ul><p><strong>树化</strong>的原因是主要是，在元素放置过程中，如果哈希冲突频繁发生，元素都被放置到同一个桶里，会形成一个比较长的链表，而链表查找的时间复杂度是线性的，严重影响存取性能。树化对应的逻辑主要在 putVal 和 treeifyBin方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> hash)</span> </span>&#123;    <span class="hljs-keyword">int</span> n, index; Node&lt;K,V&gt; e;    <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)        resize();    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">//树化改造逻辑</span>    &#125;&#125;</code></pre><p>结合putVal 和 treeifyBin 这两个方法，可以看到，当 binCount 大于 TREEIFY_THRESHOLD 时：</p><ul><li>如果容量小于 MIN_TREEIFY_CAPACITY，只会进行简单的扩容；</li><li>如果容量大于 MIN_TREEIFY_CAPACITY ，则会进行树化改造。</li></ul><pre><code class="hljs html">static final int TREEIFY_THRESHOLD = 8;static final int UNTREEIFY_THRESHOLD = 6;</code></pre><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>java.util.Collections工具类为集合框架提供了很多有用的方法，这些方法都是静态的，在编程中可以直接调用。</p><h3 id="默认排序算法"><a href="#默认排序算法" class="headerlink" title="默认排序算法"></a>默认排序算法</h3><p>理解 Java 提供的默认排序算法的排序方式以及设计思路：需要区分是 Arrays.sort() 还是 Collections.sort()。对于小数据集，会直接进行二分插入排序。</p><ul><li>Arrays.sort() 对<strong>原始数据类型的数组</strong>，默认升序排序。如果要实现降序排列，需要借助比较器Comparator。</li><li>对于<strong>原始数据类型</strong>，目前使用的是所谓<strong>双轴快速排序</strong>（Dual-Pivot QuickSort），是一种改进的快速排序算法，早期版本是相对传统的快速排序；</li><li>Collections.sort() 对<strong>对象数据类型的List</strong> 进行排序。</li><li>对于<strong>对象数据类型</strong>，目前则是使用<strong>TimSort</strong>，思想上也是一种<strong>归并和二分插入排序</strong>结合的优化排序算法。TimSort 的思路是<strong>查找数据集中已经排好序的分区</strong>，然后<strong>合并这些分区</strong>，达到排序的目的。</li></ul><p>另外，Java 8 引入了<strong>并行排序算法</strong>（直接使用 parallelSort 方法），这是为了充分利用现代多核处理器的计算能力，底层实现基于 fork-join 框架，当处理的数据集比较小的时候，差距不明显，甚至还表现差一点；但是，当数据集增长到数万或百万以上时，提高就非常大了，具体还是取决于处理器和系统环境。</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p><strong>问：</strong>思考一个应用场景，实现一个云计算任务调度系统，可以保证 VIP 客户的任务被优先处理，可以利用哪些数据结构或者标准的集合类型呢？更进一步讲，类似场景大多是基于什么数据结构呢？</p><p><strong>答：</strong>由于任务有前后顺序关系，所以考虑使用<strong>优先级队列</strong>，如PriorityQueue、PriorityBlockingQueue。将VIP用户的优先级设置为最高，优先处理。借鉴操作系统中的调度算法，还可以设计各种公平的优先级选择算法（基于<strong>排队先后顺序、调度任务所需的时间长短</strong>进行排序），与 PriorityQueue 结合使用。</p><p><strong>消息队列</strong>可以对用户请求进行削锋，前台快速响应，后台后续进行处理操作。其他的优化有：利用分布式系统的优点，将VIP用户的请求分发到算力更高的服务器上处理。达到高可用的目的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Java 编程思想</p><p>Java 核心卷</p><p><a href="<https://time.geekbang.org/column/intro/100006701>/">极客时间 - Java精讲</a></p><p><a href="http://c.biancheng.net/java/" target="_blank" rel="noopener">C语言中文网 - Java教程</a></p><p><a href="http://www.justdojava.com/2019/09/16/java-collection-1/" target="_blank" rel="noopener">集合系列 - 初探 java 集合框架图</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Collection</tag>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库基础</title>
    <link href="/2020/07/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统基础</title>
    <link href="/2020/07/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络基础</title>
    <link href="/2020/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM基础</title>
    <link href="/2020/07/22/JVM%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/22/JVM%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 多线程基础</title>
    <link href="/2020/07/22/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/22/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>并发成为现代软件开发的基础能力，Java 精心设计的高效并发机制，是构建大规模应用的基础之一。本文介绍 Java 并发编程基础知识。主要内容为 线程生命周期、如何实现线程、synchronized与锁、volatile、线程池、并发包、CAS与原子操作。</p><a id="more"></a><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是<strong>应用程序在内存中分配的空间，也就是正在运行的程序</strong>，各个进程之间互不干扰。同时进程保存着程序每一个时刻运行的状态。进程的出现，使操作系统的性能大大提升，但是如果一个进程在一段时间只执行一个任务，那么当进程有多个子任务时，只能逐个执行这些子任务，效率较低。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>为了提高 CPU 和 IO 设备的综合利用率，线程个概念被提出并应用。线程是一个比进程更小的执行单位，一个进程包含了多个线程，同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，而<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>是私有的，每个线程负责一个单独的子任务。</p><h2 id="进程和线程的异同"><a href="#进程和线程的异同" class="headerlink" title="进程和线程的异同"></a>进程和线程的异同</h2><ul><li><p><strong>进程是操作系统进行资源分配的基本单位</strong>，<strong>线程是系统调度的最小单元</strong>；</p></li><li><p>线程是程序执行的最小单位，更加轻量级，线程间的切换和调度的成本远远小于进程。多线程可以在多核 CPU 上同时运行，减少了线程上下文切换的开销；</p></li><li><p>多线程并发编程是高并发系统的基础，好多线程机制可以提高系统整体的并发能力及性能；</p></li><li><p>一个进程可以包含多个线程，线程作为任务的真正执行者，有<strong>自己的栈、寄存器、本地存储（Thread Local）</strong>等，但是会<strong>和进程内其他线程共享文件描述符、虚拟地址空间等</strong>；</p></li><li><p>Java 中进程的内存占用如下图所示</p><p><img src="JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86.png" srcset="/img/loading.gif" alt=""></p></li></ul><h1 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h1><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>Java 5 以后，线程生命周期的不同状态被明确定义在其公共内部枚举类型 java.lang.Thread.State 中，分别是：</p><ul><li><p>新建（<strong>NEW</strong>），表示线程被创建出来还<strong>没真正启动</strong>的状态，可以认为它是个 Java 内部状态；</p></li><li><p>就绪（<strong>RUNNABLE</strong>），表示该线程已经在 JVM 中执行，当然由于执行需要计算资源，它<strong>可能是正在运行</strong>，也可能还在<strong>等待系统分配给它 CPU 片段，在就绪队列里面排队</strong>。在其他一些分析中，会额外区分一种状态 <strong>RUNNING</strong>，但是从 Java API 的角度，并不能表示出来；</p></li><li><p>阻塞（<strong>BLOCKED</strong>），这个状态和同步非常相关，<strong>阻塞表示线程在等待 Monitor lock</strong>。比如，线程试图<strong>通过 synchronized 去获取某个锁</strong>，但是其他线程已经独占了，那么当前线程就会处于阻塞状态；</p></li><li><p>等待（<strong>WAITING</strong>），表示正在<strong>等待其他线程采取某些操作</strong>。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（<strong>wait</strong>），另外的生产者线程去准备任务数据，然后通过类似 <strong>notify</strong> 等动作，通知消费线程可以继续工作了。<strong>Thread.join() 也会令线程进入等待状态</strong>。计时等待（<strong>TIMED_WAIT</strong>），其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如 <strong>wait 或 join 等方法的指定超时</strong>版本，如下面示例：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;</code></pre></li><li><p>终止（<strong>TERMINATED</strong>），不管是<strong>意外退出还是正常执行结束，线程已经完成使命，终止运行</strong>。第二次调用 start() 方法的时候，线程可能处于终止或者其他（非 NEW）状态，但是不论如何，都<strong>不可以再次启动</strong>。</p></li></ul><h2 id="线程操作"><a href="#线程操作" class="headerlink" title="线程操作"></a>线程操作</h2><ul><li>start()：启动线程并执行相应的 run() 方法；</li><li>run()：子线程要执行的逻辑代码在 run() 中完成；</li><li>sleep()：让当前线程停止执行，把 CPU 让给其他线程执行，但<strong>不会释放对象锁和监控的状态</strong>，到了指定时间后线程又会自动恢复运行状态；<ul><li>注：线程睡眠到期自动苏醒，并返回到<strong>可运行状态</strong>，不是运行状态。sleep() 中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始执行；</li></ul></li><li>wait()：使一个线程处于等待（阻塞）状态，并且<strong>释放所持有的对象的锁</strong>；</li><li>join()：t.join() 方法只会使主线程（调用 t.join() 的线程）进入等待池并等待 t线程 执行完毕后才会被唤醒。不影响同一时刻处在运行状态的其他线程；<ul><li>使用场景示例：主线程创建并启动了线程，如果子线程中药进行大量耗时运算，主线程往往会早于子线程结束之前结束。如果主线程想等待子线程执行完成之后再结束，比如主线程要获取子线程处理的数据，就要用到 join() 方法；</li></ul></li><li>yield()：告诉调度器主动让出 CPU；<ul><li>注：让出 CPU 不代表当前线程不执行了。当前线程让出 CPU 后，还会进行 CPU 资源的争夺，但是不保证一定能够再次分配到；</li></ul></li><li>getPriority()：获取当前线程的优先级；<ul><li>注：两个等待的线程，优先级高的线程容易被 CPU 执行。优先级分为1~10等级，默认优先级是5；</li></ul></li><li>setPriority()：设置线程的优先级；</li><li>getId()：取得线程唯一标识；</li><li>isAlive()：判断当前线程是否处于活动状态，活动状态就是已经启动尚未终止；</li><li>currentThread()：返回代码段正在被哪个线程调用；</li><li>resume()、stop()、suspend() 方法被标记为过时，在 JDK 最新版本中，destory/stop 方法将被移除；</li><li>基类 Object 提供了一些基础的 wait() / notify() / notifyAll() 方法；<ul><li>如果持有某个对象的 Monitor 锁，调用 wait 会让当前线程处于等待状态，直到其他线程 notify 或者 notifyAll。所以，这些方法本质上是提供了 Monitor 的获取和释放的能力，是基本的线程间通信方式；</li></ul></li><li>并发类库中的工具，比如 CountDownLatch.await() 会让当前线程进入等待状态，直到 latch 被计数为 0，这可以看作是线程间通信的 Signal；</li></ul><h1 id="Java-中如何实现线程"><a href="#Java-中如何实现线程" class="headerlink" title="Java 中如何实现线程"></a>Java 中如何实现线程</h1><h2 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h2><ul><li><strong>创建一个任务类继承 Thread 类</strong>，Thread类实现了Runnable接口，所以自定义的任务类也实现了Runnable接口；<ul><li>扩展 java.lang.Thread 类来创建线程，java.lang.Thread 类主要有两个方法：<ul><li>start()：调用自定义对象的start()方法，可以启动线程；</li><li>run()：run()方法定义了具体的任务代码或处理逻辑，Thread 的子类应该重写run()方法；</li></ul></li><li>创建一个任务类对象，可以用 Thread 或者 Runnable 作为自定义的变量类型；</li><li>调用自定义对象的 start() 方法，启动一个线程；</li></ul></li><li><strong>定义一个任务类实现 Runnable 接口</strong>；<ul><li>实现 Runnable 接口中的 run() 方法；</li><li>定义了任务类后，为任务类创建一个任务对象；</li><li>任务必须在线程中执行，创建一个 Thread 类的对象，将前面创建的实现了 Runnable 接口的<strong>任务类对象作为参数传递给Thread类的构造方法</strong>；</li><li>调用Thread类对象的 start() 方法，启动一个线程。</li></ul></li></ul><h1 id="synchronized-与锁"><a href="#synchronized-与锁" class="headerlink" title="synchronized 与锁"></a>synchronized 与锁</h1><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>线程安全是一个多线程环境下<strong>正确性的概念</strong>，也就是保证多线程环境下<strong>共享的</strong>、<strong>可修改</strong>的<strong>状态</strong>的正确性，这里的状态反映在程序中其实可以看作是<strong>数据</strong>。换个角度来看，如果状态不是共享的，或者不是可修改的，也就不存在线程安全问题。线程安全需要保证几个基本特性：</p><ul><li>原子性：相关操作不会中途被其他线程干扰，一般通过<strong>同步机制</strong>实现；</li><li>可见性：一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为<strong>将线程本地状态反映到主内存上</strong>，<strong>volatile</strong> 可以负责保证可见性的；</li><li>有序性：保证线程内串行语义，<strong>避免指令重排</strong>等； </li></ul><h2 id="synchronized-与-ReentrantLock"><a href="#synchronized-与-ReentrantLock" class="headerlink" title="synchronized 与 ReentrantLock"></a>synchronized 与 ReentrantLock</h2><p>synchronized 是 Java 内建的同步机制，所以也称为 Intrinsic Locking，它提供了互斥的语义和可见性，<strong>当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在那里</strong>。</p><ul><li>Java 5 以前，synchronized 是仅有的同步手段，在代码中，synchronized 可以用来<strong>修饰方法</strong>，也可以使用在特定的<strong>代码块</strong>儿上，<strong>本质上 synchronized 方法等同于把方法全部语句用 synchronized 块包起</strong>；</li><li>synchronized 依赖于 <strong>JVM</strong>，ReentrantLock 依赖于 <strong>API</strong>，synchronized 是依赖于 JVM 实现的，没有直接暴露给用户；ReentrantLock 是 JDK 层面实现的（需要 lock() 和 unlock() 方法配合 try/finally 来完成），所以可以查看它的源代码；</li><li>ReentrantLock，是 Java 5 提供的锁实现，语义和 synchronized 基本相同。再入锁通过代码直接调用 lock() 方法获取，代码书写也更加灵活。ReentrantLock 提供了很多实用的方法，能够实现很多 synchronized 无法做到的<strong>细节控制</strong>，比如可以控制 fairness，也就是<strong>公平性</strong>，或者利用<strong>定义条件</strong>等。但是，编码中也需要注意，必须要<strong>明确调用 unlock() 方法释放</strong>，不然就会一直持有该锁；<ul><li>与 synchronized 相比，ReentrantLock 增加了一些高级功能，主要有三点：等待可中断；可实现公平锁；可实现选择性通知（锁可以绑定多个条件）；</li></ul></li><li>synchronized 和 ReentrantLock 的性能不能一概而论，早期版本 synchronized 在很多场景下性能相差较大，在后续版本进行了较多改进，在低竞争场景中表现可能优于 ReentrantLock；</li></ul><h2 id="syschronized-实现原理"><a href="#syschronized-实现原理" class="headerlink" title="syschronized 实现原理"></a>syschronized 实现原理</h2><p>synchronized 代码块由一对 monitorenter / monitorexit 指令实现，Monitor 对象是同步的基本实现单元。</p><ul><li>Java 6 之前，Monitor 的实现完全依靠<strong>操作系统内部的互斥锁</strong>，因为需要进行<strong>用户态到内核态的切换</strong>，所以同步操作是一个<strong>重量级操作</strong>；</li></ul><h2 id="锁的升级、降级"><a href="#锁的升级、降级" class="headerlink" title="锁的升级、降级"></a>锁的升级、降级</h2><ul><li>现代的（Oracle）JDK 中，JVM 对此进行了改进，提供了<strong>三种不同的 Monitor 实现</strong>，也就是常说的三种不同的锁：<strong>偏斜锁</strong>（Biased Locking）、<strong>轻量级锁</strong>和<strong>重量级锁</strong>，大大改进了其性能；</li><li>锁的升级、降级，指的是 <strong>JVM 优化 synchronized 运行的机制</strong>，当 JVM 检测到不同的竞争状况时，会<strong>自动切换到适合的锁实现</strong>，这种切换就是锁的升级、降级；</li><li>当<strong>没有竞争</strong>出现时，默认会使用偏斜锁。JVM 会利用 <strong>CAS 操作</strong>（compare and swap），在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，<strong>大部分对象生命周期中最多会被一个线程锁定</strong>，使用<strong>偏斜锁可以降低无竞争开销</strong>；</li><li>如果有<strong>另外的线程试图锁定某个已经被偏斜过的对象</strong>，JVM 就需要撤销（revoke）偏斜锁，并切换到<strong>轻量级锁实现</strong>。轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，<strong>如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁；</strong></li><li>有的观点认为 Java 不会进行锁降级。有的观点认为，锁降级是会发生的，当 <strong>JVM 进入安全点</strong>（SafePoint）的时候，会检查是否有闲置的 Monitor，然后试图进行降级。</li></ul><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个共享变量的值，而另外一个线程还继续使用它的本地内存中共享变量的副本，造成<strong>数据的不一致</strong>。</p><p>注：在多个线程之间能够被共享的变量被称为共享变量。共享变量包括所有的实例变量，静态变量和数组元素。他们都被存放在堆内存中，volatile 只作用于共享变量。</p><h2 id="volatile-定义"><a href="#volatile-定义" class="headerlink" title="volatile 定义"></a>volatile 定义</h2><p>java 编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java 语言提供了 volatile，在某些情况下比锁更加方便。如果一个字段被声明成 volatile，java 线程内存模型确保所有线程看到这个变量的值是一致的。</p><p>Volatile 是<strong>轻量级的 synchronized</strong>，它在多处理器开发中保证了共享变量的“<strong>可见性</strong>”。可见性指的是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h2><p>池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。线程池提供了一种限制和管理资源的技术。 每个线程池维护一些基本统计信息，例如已完成任务的数量。</p><ul><li><strong>降低资源消耗</strong>：通过重复利用已创建的线程降低线程创建和销毁造成的消耗；</li><li>*<em>提高响应速度 *</em>：当任务到达时，任务可以不需要的等待线程的创建就能立即执行；</li><li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控；</li></ul><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>通常开发者可以利用 Executors 提供的通用线程池创建方法，创建不同配置的线程池，主要区别在于不同的 ExecutorService 类型或者不同的初始参数。Executors 目前提供了 5 种不同的线程池创建配置：</p><ul><li>newCachedThreadPool()：<strong>用来处理大量短时间工作任务的线程池</strong>，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</li><li>newFixedThreadPool(int nThreads)：<strong>重用指定数目（nThreads）的线程，底层使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的</strong>。如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；</li><li>newSingleThreadExecutor()：<strong>工作线程数目被限制为 1</strong>，操作一个无界的工作队列，<strong>保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态</strong>，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；</li><li>newSingleThreadScheduledExecutor() 和 newScheduledThreadPool(int corePoolSize)：创建的是个 ScheduledExecutorService，可以进行<strong>定时或周期性的工作调度</strong>，区别在于单一工作线程还是多个工作线程；</li><li>newWorkStealingPool(int parallelism)：Java 8 加入这个创建方法，内部会构建ForkJoinPool，利用Work-Stealing算法，<strong>并行地处理任务，不保证处理顺序</strong>；</li></ul><p>注：</p><ul><li>newFixedThreadPool 和 newSingleThreadExecutor：允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致OOM。</li><li>newCachedThreadPool 和 newScheduledThreadPool：允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</li></ul><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><h3 id="线程池创建"><a href="#线程池创建" class="headerlink" title="线程池创建"></a>线程池创建</h3><p>可以通过 ThreadPoolExecutor 创建一个线程池。</p><pre><code class="hljs java"><span class="hljs-keyword">new</span>  ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, handler);</code></pre><ul><li>corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，<strong>即使其他空闲的基本线程能够执行新任务也会创建线程</strong>，等到<strong>需要执行的任务数大于线程池基本大小</strong>时就不再创建。如果调用了线程池的 prestartAllCoreThreads 方法，线程池会提前创建并启动所有基本线程；</li><li>runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列：<ul><li>ArrayBlockingQueue：基于数组结构的有界阻塞队列，按 FIFO 原则对元素排序；</li><li>LinkedBlockingQueue：基于链表结构的阻塞队列，按 FIFO 原则对元素排序，吞吐量通常高于 ArrayBlockingQueue。静态工厂方法 Executors.newFixedThreadPool() 使用了这个队列；</li><li>SynchronousQueue：不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 LinkedBlockingQueue，静态工厂方法 Executors.newCachedThreadPool 使用了这个队列；</li><li>PriorityBlockingQueue：具有优先级的无界阻塞队列；</li></ul></li><li>maximumPoolSize（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果；</li><li>ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字；</li><li>RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是 AbortPolicy，表示无法处理新任务时抛出异常。以下是 JDK1.5 提供的四种策略：<ul><li>AbortPolicy：直接抛出异常；</li><li>CallerRunsPolicy：只用调用者所在线程来运行任务；</li><li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务；</li><li>DiscardPolicy：不处理，丢弃掉；</li><li>也可以根据应用场景需要来实现 RejectedExecutionHandler 接口自定义策略。如记录日志或持久化不能处理的任务；</li></ul></li><li>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率；</li><li>TimeUnit（线程活动保持时间的单位）：可选的单位有天，小时，分钟，毫秒，微秒 (千分之一毫秒) 和毫微秒 (千分之一微秒)；</li></ul><h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><p>可以通过 execute() 和 submit() 方法向线程池提交任务。</p><ul><li><p>execute() 用于提交不需要返回值的任务，无法判断任务是否被线程池执行成功；</p><pre><code class="hljs java">threadsPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-comment">// TODO Auto-generated method stub</span>            &#125;        &#125;);</code></pre></li></ul><ul><li><p>submit() 方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get() 方法获取返回值，get() 方法会阻塞当前线程直到任务完成，而 get(long timeout，TimeUnit unit) 方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完；</p><pre><code class="hljs java">Future&lt;Object&gt; future = executor.submit(harReturnValuetask);<span class="hljs-keyword">try</span> &#123;     Object s = future.get();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;    <span class="hljs-comment">// 处理中断异常 </span>&#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;    <span class="hljs-comment">// 处理无法执行任务异常 </span>&#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-comment">// 关闭线程池 </span>    executor.shutdown();&#125;</code></pre></li></ul><h3 id="线程池关闭"><a href="#线程池关闭" class="headerlink" title="线程池关闭"></a>线程池关闭</h3><p>可以通过调用线程池的 shutdown 或 shutdownNow 方法来关闭线程池，它们的原理是遍历线程池中的工作线程，然后逐个调用线程的 interrupt 方法来中断线程，所以无法响应中断的任务可能永远无法终止。</p><ul><li>shutdownNow 首先将线程池的状态设置成 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表；</li><li>shutdown 只是将线程池的状态设置成 SHUTDOWN 状态，然后中断所有没有正在执行任务的线程；</li></ul><p>只要调用了这两个关闭方法的其中一个，isShutdown 方法就会返回 true。当所有的任务都已关闭后, 才表示线程池关闭成功，这时调用 isTerminaed 方法会返回 true。至于调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定。通常调用 shutdown 来关闭线程池，如果任务不一定要执行完，则可以调用 shutdownNow。</p><h3 id="线程池工作流程"><a href="#线程池工作流程" class="headerlink" title="线程池工作流程"></a>线程池工作流程</h3><p>线程池的主要工作流程如下图所示：</p><p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg" srcset="/img/loading.gif" alt=""></p><p>当提交一个新任务到线程池时，线程池的处理流程如下：</p><ol><li>首先线程池判断<strong>基本线程池</strong>是否已满？没满，创建一个工作线程来执行任务，否则：</li><li>其次线程池判断<strong>工作队列</strong>是否已满？没满，则将新提交的任务存储在工作队列里，否则：</li><li>最后线程池判断<strong>整个线程池</strong>是否已满？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务；</li></ol><p>源码分析部分以及下面的线程池配置部分可以参见方腾飞老师<a href="https://www.infoq.cn/article/java-threadPool" target="_blank" rel="noopener">JAVA 线程池的分析和使用</a>的博客，以及 <a href="https://snailclimb.gitee.io/javaguide/#/docs/java/Multithread/JavaConcurrencyAdvancedCommonInterviewQuestions?id=_41-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8%e7%ba%bf%e7%a8%8b%e6%b1%a0%ef%bc%9f" target="_blank" rel="noopener">JavaGuide的线程池总结</a>。</p><h3 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h3><p>合理的配置线程池，需要从以下几个角度分析任务特性：</p><ol><li>任务的性质：CPU 密集型任务，IO 密集型任务和混合型任务。</li><li>任务的优先级：高，中和低。</li><li>任务的执行时间：长，中和短。</li><li>任务的依赖性：是否依赖其他系统资源，如数据库连接。</li></ol><h1 id="Java-并发包"><a href="#Java-并发包" class="headerlink" title="Java 并发包"></a>Java 并发包</h1><p>Java 提供了不同层面的线程安全支持。在传统集合框架内部，除了 <strong>Vector、Stack、Hashtable</strong> 等同步容器，还提供了<strong>同步包装器</strong>（Synchronized Wrapper），可以调用 Collections 工具类提供的包装方法，获取一个同步的包装容器（如 Collections.synchronizedMap），但是它们都是利用<strong>粗粒度的同步方式</strong>，<strong>高并发下性能较低</strong>。</p><p>鉴于Java 集合框架的典型容器类绝大多数都不是线程安全的且性能较低，Java 提供了并发包，为高度并发需求提供了更加全面的工具支持。</p><ul><li>各种并发容器，如 ConcurrentHashMap、CopyOnWriteArrayList；</li><li>各种线程安全队列（Queue/Deque），如 ArrayBlockingQueue、SynchronousQueue；</li><li>各种有序容器的线程安全版本等；</li></ul><p>线程安全的实现方式有简单的 <strong>synchronize</strong> 方式，也有更加精细化的，比如<strong>基于分离锁实现的 ConcurrentHashMap</strong> 等并发实现等。具体选择要看开发的场景需求。</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p><strong>Java 1.6</strong> 版本的ConcurrentHashMap：</p><p>ConcurrentHashMap 由 Segment 数组结构和 HashEntry 数组结构组成。Segment 是一种可重入锁 ReentrantLock，在 ConcurrentHashMap 里扮演锁的角色，<strong>HashEntry 则用于存储键值对数据</strong>。<strong>一个 ConcurrentHashMap 里包含一个 Segment 数组</strong>，Segment 的结构和 HashMap 类似，是一种数组和链表结构， <strong>一个 Segment 里包含一个 HashEntry 数组</strong>，每个 HashEntry 是一个链表结构的元素， 每个 Segment 守护者一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁。结构如下图所示：</p><p><img src="ConcurrentHashMap.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>Java 8</strong> 和之后的版本中，ConcurrentHashMap：</p><ul><li>总体结构上，它的内部存储和 HashMap 结构非常相似，同样是大的桶（bucket）数组，内部也是的链表结构，同步的粒度要更细致一些（锁的颗粒度，是加在链表头上的）；</li><li>内部仍然有 Segment 定义，但仅仅是为了保证序列化时的兼容性，不再有任何结构上的用处；</li><li>因为不再使用 Segment，初始化操作大大简化，修改为 lazy-load 形式，这样可以有效避免初始开销；</li><li>数据存储利用 volatile 来保证可见性；</li><li>使用 CAS 等操作，在特定场景进行无锁并发操作；</li><li>使用 Unsafe、LongAdder 之类底层手段，进行极端情况的优化。</li></ul><h2 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h2><p>队列是非常重要的数据结构，日常开发中很多线程间数据传递都要依赖于它，Executor 框架提供的各种线程池，同样无法离开队列。</p><p>实现一个线程安全的队列有两种实现方式：一种是使用阻塞算法，另一种是使用非阻塞算法。使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现，而非阻塞的实现方式则可以使用循环 CAS 的方式来实现。线程安全队列 ConcurrentLinkedQueue 是使用非阻塞的方式来实现的。</p><h3 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h3><h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><p>对于 ConcurrentLinkedQueue 的方法实现可以参见<a href="https://juejin.im/post/5aeeae756fb9a07ab11112af#heading-0" target="_blank" rel="noopener">并发容器之 ConcurrentLinkedQueue</a> 这篇文章。</p><ul><li><p>Concurrent 类型基于 <strong>lock-free</strong>，在常见的多线程访问场景，一般可以<strong>提供较高吞吐量</strong>；</p></li><li><p><strong>Concurrent</strong> 类型没有类似 <strong>CopyOnWrite</strong> 之类容器相对较重的<strong>修改开销</strong>；</p></li><li><p>Concurrent 往往提供了<strong>较低的遍历一致性</strong>。可以这样理解所谓的弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历；</p></li><li><p>同步容器 ”<strong>fail-fast</strong>”：检测到容器在遍历过程中发生了修改，则抛出 ConcurrentModificationException，不再继续遍历；</p></li><li><p>弱一致性的另外一个体现是，<strong>size 等操作准确性是有限的</strong>，未必是 100% 准确；</p></li><li><p>与此同时，<strong>读取的性能</strong>具有一定的不确定性；</p></li></ul><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p>对于阻塞队列，更加详细的介绍和分析参见 <a href="https://www.infoq.cn/article/java-blocking-queue" target="_blank" rel="noopener">Java 中的阻塞队列</a> 。</p><h2 id="CopyOnWrite"><a href="#CopyOnWrite" class="headerlink" title="CopyOnWrite"></a>CopyOnWrite</h2><p>CopyOnWrite 的原理是：任何修改操作，如 add、set、remove，都会拷贝原数组，修改后替换原来的数组，通过这种防御性的方式，实现另类的线程安全。适合<strong>读多写少的操作</strong>，不然修改的开销是比较高的。</p><p>这样做的好处在于，可以在并发的场景下对容器进行”读操作”而不需要”加锁”，从而达到读写分离的目的。从JDK 1.5 开始 Java 并发包里提供了两个使用 CopyOnWrite 机制实现的并发容器 ，分别是CopyOnWriteArrayList和CopyOnWriteArraySet 。CopyOnWriteArraySet 是通过包装了 CopyOnWriteArrayList 来实现的。</p><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>CopyOnWriteArrayList 经常被用于“读多写少”的并发场景，因为 CopyOnWriteArrayList 无需任何同步措施，增强了读的性能。Java 中遍历非线程安全的 List（如：ArrayList和 LinkedList）的时候，若中途有别的线程对List容器进行修改，会抛出ConcurrentModificationException异常。CopyOnWriteArrayList由于其”读写分离”，遍历和修改操作分别作用在不同的List容器，所以在使用迭代器遍历的时候，不会抛出异常。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>CopyOnWriteArrayList每次执行写操作都会将原容器进行拷贝了一份，数据量大的时候，内存会存在较大的压力，可能会引起频繁Full GC（ZGC没有使用Full GC）；<ul><li>比如对象占用的内存200M左右，再写入100M数据进去，内存就会多占用300M；</li></ul></li><li>CopyOnWriteArrayList 由于实现的原因，写和读分别作用在不同新老容器上，写操作执行过程中，读不会阻塞，但读取到的却是老容器的数据；</li></ul><h4 id="操作分析"><a href="#操作分析" class="headerlink" title="操作分析"></a>操作分析</h4><p>CopyOnWriteArrayList 的源码分析可以参见<a href="https://redspider.gitbook.io/concurrent/di-san-pian-jdk-gong-ju-pian/16#16-2-copyonwritearraylist" target="_blank" rel="noopener">代码分析</a>。</p><ul><li>CopyOnWriteArrayList 的 add 操作是先把原容器进行copy，然后在新的副本上进行“写操作”，最后再切换引用，在此过程中是加了锁的；</li><li>remove 操作的逻辑是将要删除元素之外的其他元素拷贝到新的副本中，然后切换引用，再将原容器的引用指向新的副本中，因为 remove 操作也是写操作，所以也是要加锁的；</li><li>get 操作是“读操作”，没有加锁，直接读取；</li></ul><h2 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h2><p> Java 并发包提供了<strong>比 synchronized 更加高级的各种同步结构</strong>，包括 CountDownLatch、CyclicBarrier、Semaphore 等，可以实现更加丰富的多线程操作，比如利用 Semaphore 作为资源控制器，限制同时进行工作的线程数量；</p><ul><li><p>Semaphore，Java 版本的<strong>信号量的实现</strong>。</p></li><li><p>CountDownLatch，也叫做闭锁，<strong>允许一个或多个线程等待某些操作完成后再执行</strong>；</p></li><li><p>CyclicBarrier，一种辅助性的同步结构，<strong>允许多个线程等待到达某个屏障</strong>；</p></li></ul><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Java 提供了经典信号量（Semaphore）的实现，它通过控制一定数量的允许（permit）的方式，来达到限制通用资源访问的目的。类比如下场景：在车站、机场等出租车时，当很多空出租车就位时，为防止过度拥挤，调度员指挥排队等待坐车的队伍一次进来 5 个人上车，等这 5 个人坐车出发，再放进去下一批，这和 Semaphore 的工作原理有些类似。Semaphore 可以理解为<strong>计数器</strong>，其<strong>基本逻辑基于 acquire/release</strong>，没有太复杂的同步逻辑。</p><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p><a href="https://www.jianshu.com/p/03f5d1b02bb8" target="_blank" rel="noopener">参考：白话Java并发工具类</a></p><p>在多线程协作完成业务功能时，有时候需要等待其他多个线程完成任务之后，主线程才能继续往下执行业务功能，在这种的业务场景下，通常可以使用Thread类的join方法，让主线程等待被join的线程执行完之后，主线程才能继续往下执行。当然，使用线程间消息通信机制也可以完成。java并发工具类中提供了类似“倒计时”这样的工具类，可以十分方便的完成这种业务场景。</p><p>CountDownLatch内部会维护一个初始值为线程数量的计数器，主线程执行await方法，如果计数器大于0，则阻塞等待。当一个线程完成任务后，计数器值减1。当计数器为0时，表示所有的线程已经完成任务，等待的主线程被唤醒继续执行。</p><h4 id="CountDownLatch主要方法"><a href="#CountDownLatch主要方法" class="headerlink" title="CountDownLatch主要方法"></a>CountDownLatch主要方法</h4><ul><li>await() throws InterruptedException：调用该方法的线程等到构造方法传入的N减到0的时候，才能继续往下执行；</li><li>await(long timeout, TimeUnit unit)：与上面的await方法功能一致，加上时间限制，调用该方法的线程等到指定的timeout时间后，不管N是否减至为0，都会继续往下执行；</li><li>countDown()：使CountDownLatch初始值N减1；</li><li>long getCount()：获取当前CountDownLatch维护的值；</li></ul><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>CyclicBarrier也是一种多线程并发控制的实用工具，和CountDownLatch一样具有等待计数的功能。CyclicBarrier在使用一次后，下面依然有效，可以继续当做计数器使用，这是与CountDownLatch的区别之一。</p><h3 id="CountDownLatch-与-CyclicBarrier-异同"><a href="#CountDownLatch-与-CyclicBarrier-异同" class="headerlink" title="CountDownLatch 与 CyclicBarrier 异同"></a>CountDownLatch 与 CyclicBarrier 异同</h3><ul><li>CountDownLatch 是不可以重置的，所以<strong>无法重用</strong>；而 CyclicBarrier 则没有这种限制，<strong>可以重用</strong>；</li><li>CountDownLatch 的基本操作组合是 <strong>countDown/await</strong>。调用 await 的线程阻塞等待 countDown 足够的次数，不管是在一个线程还是多个线程里 countDown，只要次数足够即可。<strong>CountDownLatch 操作的是事件</strong>；</li><li>CyclicBarrier 的基本操作组合，则就是 <strong>await</strong>，当所有的伙伴（parties）<strong>都调用了 await</strong>，才会继续进行任务，并<strong>自动进行重置</strong>。注意，正常情况下，CyclicBarrier 的重置都是自动发生的，如果调用 reset 方法，但还有线程在等待，就会导致等待线程被打扰，抛出 BrokenBarrierException 异常。<strong>CyclicBarrier 侧重点是线程，而不是调用事件</strong>，它的典型应用场景是<strong>用来等待并发线程结束</strong>。</li></ul><h3 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h3><p>Java 并发类库还提供了Phaser，功能与 CountDownLatch 很接近，但是它<strong>允许线程动态地注册到 Phaser 上面</strong>，而 CountDownLatch 显然是不能动态设置的。Phaser 的设计初衷是，实现多个线程类似步骤、阶段场景的协调，线程注册等待屏障条件触发，进而协调彼此间行动。</p><h1 id="CAS-与原子操作"><a href="#CAS-与原子操作" class="headerlink" title="CAS 与原子操作"></a>CAS 与原子操作</h1><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁是一种特定的程序状态，实体之间由于循环依赖导致彼此一直处于等待之中，没有任何个体可以继续前进。死锁不仅仅是在线程之间会发生，存在资源独占的进程之间同样也可能出现死锁。通常来说，大多关注多线程场景中的死锁。两个或多个线程之间，由于互相持有对方需要的锁，而永久处于阻塞的状态。</p><p>定位死锁最常见的方式就是利用 jstack 等工具获取线程栈，然后定位互相之间的依赖关系，进而找到死锁。如果是比较明显的死锁，往往 jstack 等就能直接定位，类似 JConsole 甚至可以在图形界面进行有限的死锁检测。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLockSample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;  <span class="hljs-keyword">private</span> String first;  <span class="hljs-keyword">private</span> String second;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DeadLockSample</span><span class="hljs-params">(String name, String first, String second)</span> </span>&#123;      <span class="hljs-keyword">super</span>(name);      <span class="hljs-keyword">this</span>.first = first;      <span class="hljs-keyword">this</span>.second = second;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">synchronized</span> (first) &#123;          System.out.println(<span class="hljs-keyword">this</span>.getName() + <span class="hljs-string">" obtained: "</span> + first);          <span class="hljs-keyword">try</span> &#123;              Thread.sleep(<span class="hljs-number">1000L</span>);              <span class="hljs-keyword">synchronized</span> (second) &#123;                  System.out.println(<span class="hljs-keyword">this</span>.getName() + <span class="hljs-string">" obtained: "</span> + second);              &#125;          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;              <span class="hljs-comment">// Do nothing</span>          &#125;      &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;      String lockA = <span class="hljs-string">"lockA"</span>;      String lockB = <span class="hljs-string">"lockB"</span>;      DeadLockSample t1 = <span class="hljs-keyword">new</span> DeadLockSample(<span class="hljs-string">"Thread1"</span>, lockA, lockB);      DeadLockSample t2 = <span class="hljs-keyword">new</span> DeadLockSample(<span class="hljs-string">"Thread2"</span>, lockB, lockA);      t1.start();      t2.start();      t1.join();      t2.join();  &#125;&#125;</code></pre><h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h2><p>锁可以从不同的角度分类。其中，乐观锁和悲观锁是一种分类方式。</p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁就是常说的锁。悲观锁总是认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁又称为“无锁”。乐观锁总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。而一旦多个线程发生冲突，乐观锁通常使用 CAS 来保证线程执行的安全性。由于无锁操作中没有锁的存在，因此不可能出现死锁的情况。</p><p>悲观锁多用于”<strong>写多读少</strong>“的环境，避免频繁失败和重试影响性能。乐观锁多用于“<strong>读多写少</strong>“的环境，避免频繁加锁影响性能。</p><h2 id="CAS-定义"><a href="#CAS-定义" class="headerlink" title="CAS 定义"></a>CAS 定义</h2><p><strong>比较并交换(compare and swap, CAS)</strong>，是原子操作的一种，可用于在多线程编程中<strong>实现不被打断的数据交换操作</strong>，从而<strong>避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题</strong>。 该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。</p><ul><li><strong>记录下</strong>某块内存中的旧值；</li><li>对旧值<strong>进行一系列的操作</strong>后得到新值；</li><li>通过CAS操作将新值与旧值进行交换：<ul><li>如果这块内存的值在这期间内没被修改过，则旧值会与内存中的数据相同，这时CAS操作将会成功执行，使内存中的数据变为新值；</li><li>如果内存中的值在这期间内被修改过，则一般来说旧值会与内存中的数据不同，这时CAS操作将会失败，新值将不会被写入内存。</li></ul></li></ul><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cas</span><span class="hljs-params">(<span class="hljs-keyword">long</span> *addr, <span class="hljs-keyword">long</span> old, <span class="hljs-keyword">long</span> <span class="hljs-keyword">new</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">/* Executes atomically. */</span>    <span class="hljs-keyword">if</span>(*addr != old)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    *addr = <span class="hljs-keyword">new</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre><h3 id="Java-实现CAS的原理"><a href="#Java-实现CAS的原理" class="headerlink" title="Java 实现CAS的原理"></a>Java 实现CAS的原理</h3><p>CAS 是一种原子操作。在 Java 中，如果一个方法是native的，那 Java 就不负责具体实现它，而是交给底层的JVM使用 C 或者 C++ 实现。在 Java 中，Unsafe 类里面是一些native方法，其中有几个关于 CAS。这些方法都是都是public native的。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapObject</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset,Object expected, Object x)</span></span>;<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapInt</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset,<span class="hljs-keyword">int</span> expected,<span class="hljs-keyword">int</span> x)</span></span>;<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapLong</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset,<span class="hljs-keyword">long</span> expected,<span class="hljs-keyword">long</span> x)</span></span>;</code></pre><p>Unsafe 中对 CAS 的实现使用 C++，它的具体实现和操作系统、CPU都有关系。</p><p>Linux的 x86 下主要通过cmpxchgl这个指令在 CPU 级完成CAS操作，但在多处理器情况下必须使用lock指令加锁来完成。</p><p>Unsafe类里面还有其它方法用于不同的用途。比如支持线程挂起和恢复的park和unpark， LockSupport类底层就是调用了这两个方法。还有支持反射操作的 allocateInstance() 方法。</p><h3 id="CAS-实现原子操作的三个问题"><a href="#CAS-实现原子操作的三个问题" class="headerlink" title="CAS 实现原子操作的三个问题"></a>CAS 实现原子操作的三个问题</h3><h4 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h4><p>ABA问题，就是一个值原来是A，变成了B，又变回了A。这个时候使用CAS是检查不出变化的，但实际上却被更新了两次。</p><p>ABA问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。JDK 1.5 开始，JDK 的 atomic 包里提供了一个类AtomicStampedReference 类来解决ABA问题。这个类的 compareAndSet 方法的作用是：</p><ul><li>首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志；</li><li>如果二者都相等，才使用 CAS 设置为新的值和标志。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(V   expectedReference,</span></span><span class="hljs-function"><span class="hljs-params">                             V   newReference,</span></span><span class="hljs-function"><span class="hljs-params">                             <span class="hljs-keyword">int</span> expectedStamp,</span></span><span class="hljs-function"><span class="hljs-params">                             <span class="hljs-keyword">int</span> newStamp)</span> </span>&#123;    Pair&lt;V&gt; current = pair;    <span class="hljs-keyword">return</span>        expectedReference == current.reference &amp;&amp;        expectedStamp == current.stamp &amp;&amp;        ((newReference == current.reference &amp;&amp;          newStamp == current.stamp) ||         casPair(current, Pair.of(newReference, newStamp)));&#125;</code></pre><h4 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h4><p>CAS多与自旋结合。如果 CAS 自旋长时间不成功，CPU 资源的开销很大。</p><p>解决思路是让 JVM 支持处理器提供的 <strong>pause 指令</strong>。pause 指令能让自旋失败时 CPU 睡眠一小段时间再继续自旋，从而使得读操作的频率低很多，为解决内存顺序冲突而导致的CPU流水线重排的代价也会小很多。</p><h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>竞争锁的失败的线程，并不会真实的在操作系统层面挂起等待，JVM 会让线程做几个空循环（基于预测在不久的将来就能获得），经过若干次循环后，如果可以获得锁，那么进入临界区，如果还不能获得锁，才会真实的将线程在操作系统层面进行挂起。</p><p>自旋锁适用场景：自旋锁可以减少线程的阻塞，对于锁竞争不激烈，且占用锁时间非常短的代码块来说，性能有较大的提升，因为自旋的消耗会小于线程阻塞挂起操作的消耗。反之，如果锁的竞争激烈，或者持锁的线程需要长时间占用锁执行同步块，就不适合使用自旋锁，因为自旋锁在获取锁前一直都是占用 CPU 做无用功，线程自旋的消耗大于线程阻塞挂起操作的消耗，造成 CPU 的浪费。</p><h4 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h4><p>CAS可以保证单个共享变量的原子操作，对于多个共享变量，CAS无法保证原子性。</p><ul><li><p>JDK 1.5 开始提供了 AtomicReference 类，保证对象之间的原子性。所以可以把多个（共享）变量封装进一个对象，然后通过 AtomicReference 类保证引用对象之间的原子性。</p></li><li><p>使用锁：锁内的临界区代码可以保证只有当前线程能操作；</p></li></ul><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h4 id="synchronized-和-volatile-的区别"><a href="#synchronized-和-volatile-的区别" class="headerlink" title="synchronized 和 volatile 的区别"></a>synchronized 和 volatile 的区别</h4><ul><li>synchronized 关键字解决的是<strong>多个线程之间访问资源的同步性</strong>；</li><li><strong>volatile 关键字</strong>是<strong>线程同步</strong>的<strong>轻量级</strong>实现，因为它不会引起线程上下文的切换和调度，所以比 synchronized 的<strong>使用和执行成本会更低</strong>，<strong>性能</strong>比 synchronized 好；</li><li>volatile 只能用于<strong>变量</strong>，synchronized 关键字可以修饰<strong>方法以及代码块</strong>；</li><li>多线程访问 volatile 关键字<strong>不会发生阻塞</strong>，synchronized 关键字<strong>可能会发生阻塞</strong>；</li><li>volatile 关键字能保证<strong>数据的可见性</strong>，但<strong>不能保证数据的原子性</strong>，synchronized 关键字两者都能保证。</li></ul><h4 id="sleep-和-wait-方法异同"><a href="#sleep-和-wait-方法异同" class="headerlink" title="sleep() 和 wait() 方法异同"></a>sleep() 和 wait() 方法异同</h4><ul><li>都可以暂停线程的执行；</li><li>最主要的区别在于：<strong>sleep() 方法没有释放锁，而 wait() 方法释放了锁</strong>； </li><li>wait() 通常被用于<strong>线程间交互/通信</strong>，sleep() 通常被用于<strong>暂停执行</strong>；</li><li>wait() 方法被调用后，线程<strong>不会自动苏醒</strong>，需要别的线程调用同一个对象上的 <strong>notify() 或者 notifyAll() 方法</strong>；sleep() 方法执行完成后，线程会<strong>自动苏醒</strong>。或者可以使用 <strong>wait(long timeout) 超时后线程会自动苏醒</strong>；</li></ul><h4 id="start-方法会执行-run-，为什么不直接调用-run-方法"><a href="#start-方法会执行-run-，为什么不直接调用-run-方法" class="headerlink" title="start() 方法会执行 run()，为什么不直接调用 run() 方法"></a>start() 方法会执行 run()，为什么不直接调用 run() 方法</h4><ul><li>new 一个 Thread，线程进入了新建状态；</li><li>调用 start() 方法，会启动一个线程并使线程进入了<strong>就绪状态</strong>，当分配到时间片后就可以开始运行；<ul><li>start() 会执行线程的相应<strong>准备工作</strong>，然后自动执行 run() 方法的内容，这是真正的多线程工作；</li></ul></li><li>直接执行 run() 方法，会将 run() 其当成 main 线程下的一个<strong>普通方法</strong>去执行，并不会在某个线程中执行它，所以这并<strong>不是多线程工作</strong>；</li></ul><p><strong>总结： 调用 start() 方法方可启动线程并使线程进入就绪状态，而 run() 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</strong></p><h4 id="AtomicInteger-底层实现原理"><a href="#AtomicInteger-底层实现原理" class="headerlink" title="AtomicInteger 底层实现原理"></a>AtomicInteger 底层实现原理</h4><p>AtomicIntger 是对 int 类型的一个封装，提供原子性的访问和更新操作，其原子性操作的实现是基于 CAS（compare-and-swap）技术。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>JDK1.8 源码</p><p>Java 并发编程实战</p><p><a href="https://betterzero.net/2020/07/22/Java%20%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/%3Chttps://time.geekbang.org/column/intro/100006701%3E/">极客时间 - Java精讲</a></p><p><a href="https://www.infoq.cn/profile/1277812/publish" target="_blank" rel="noopener">方腾飞InfoQ并发系列文章</a></p><p><a href="https://redspider.gitbook.io/concurrent/readme" target="_blank" rel="noopener">深入浅出Java多线程</a></p><p><a href="http://www.51gjie.com/java/717.html" target="_blank" rel="noopener">javaschool</a></p><p><a href="https://cloud.tencent.com/developer/article/1497826" target="_blank" rel="noopener">一次Java线程池误用引发的线上血案和总结</a> </p><p><a href="https://blog.csdn.net/u014209205/article/details/80598209" target="_blank" rel="noopener">JAVA Future类详解</a></p><p><a href="https://www.infoq.cn/article/ftf-java-volatile/" target="_blank" rel="noopener">聊聊并发（一）—深入分析 Volatile 的实现原理</a></p><p><a href="https://blog.csdn.net/a525390802/article/details/80509457" target="_blank" rel="noopener">JVM之内存模型JMM中本地内存的理解</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java OOP一些理解</title>
    <link href="/2020/07/22/Java%20OOP%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <url>/2020/07/22/Java%20OOP%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>文章介绍面向对象编程的基础概念，主要关于其特性、优势，以及 OOP 的使用方法与误区。</p><a id="more"></a><h1 id="面向过程编程及面向过程编程语言"><a href="#面向过程编程及面向过程编程语言" class="headerlink" title="面向过程编程及面向过程编程语言"></a>面向过程编程及面向过程编程语言</h1><p>面向过程编程<strong>以过程（或方法）作为组织代码的基本单元</strong>。它最主要的特点就是<strong>数据和方法相分离</strong>。面向过程编程语言最大的特点就是不支持丰富的<strong>面向对象编程特性</strong>，比如继承、多态、封装。</p><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>面向对象编程<strong>以类为组织代码的基本单元</strong>，一般来说，它具有以下优势。</p><ul><li>对于<strong>大规模复杂的程序的开发</strong>，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程更能应对这种复杂类型的程序开发；</li><li>面向对象编程具有更加<strong>丰富的特性</strong>，如封装、抽象、继承、多态。代码易扩展、易复用、易维护；</li></ul><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="访问权限控制"><a href="#访问权限控制" class="headerlink" title="访问权限控制"></a>访问权限控制</h3><p>封装主要关于<strong>信息隐藏、数据保护</strong>。编程语言需要提供<strong>访问权限控制</strong>这样的语法机制来支持。Java 使用访问控制符来保护对<strong>类、变量、方法和构造方法</strong>的访问。Java 支持 4 种不同的访问权限：</p><ul><li><strong>private</strong> : 访问权限限制的最窄的修饰符。同一类内可见。使用对象：变量、方法。 <strong>不能修饰类（外部类）</strong></li><li><strong>default</strong> (默认）: 通常称为“默认访问权限“或者“包访问权限”，不使用任何修饰符。同一包内可见。使用对象：类、接口、变量、方法。</li><li><strong>protected</strong> : 介于public 和 private 之间的一种访问修饰符。同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>不能修饰类（外部类）</strong>。</li><li><strong>public</strong> : 访问限制最宽的修饰符。允许跨包访问，所有类可见。使用对象：类、接口、变量、方法</li></ul><h3 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h3><p>如果对类中属性的访问不做限制，任何代码都可以访问、修改类中的属性，虽然看起来更加灵活，但是<strong>过度灵活也意味着不可控</strong>。属性可以随意被修改，修改逻辑可能散落在代码中的各个角落，影响代码的<strong>可读性、可维护性</strong>。</p><p>通过有限的方法，暴露必要的操作，能<strong>提高类的易用性</strong>。如果把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就要对业务细节有足够的了解。这对于调用者来说也是一种负担。如果将属性<strong>封装</strong>起来，只暴露必要的<strong>方法</strong>给调用者使用，调用者就不需要了解太多的业务细节，可以降低使用成本，减少用错的概率。</p><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p><strong>抽象关注的是如何隐藏方法的具体实现</strong>，让调用者只需要关心方法提供了哪些功能，不需要知道实现细节。</p><p>面向对象编程常常借助编程语言提供的<strong>接口</strong>或者<strong>抽象类</strong>这两种语法机制实现抽象这一特性。</p><p><strong>抽象有时候会被排除在面向对象特性之外</strong>。因为抽象是一个非常通用的设计思想，不单单用在面向对象编程中，也可以用来指导架构设计等。这个特性也并不需要编程语言提供特殊的语法机制来支持，只需要提供“函数”这一语法机制，就可以实现抽象特性。</p><h3 id="抽象的意义"><a href="#抽象的意义" class="headerlink" title="抽象的意义"></a>抽象的意义</h3><p>面对复杂的系统，人脑能承受的信息是有限的，所以要忽略一些非关键的实现细节。抽象作为一种<strong>只关注功能点不关注实现</strong>的设计思路，可以过滤掉非必要的信息。</p><p>抽象作为一个非常宽泛的<strong>设计思想</strong>，在代码设计中起到重要的指导作用。很多设计原则都体现了抽象这种设计思想，比如<strong>基于接口而非实现编程</strong>、<strong>开闭原则</strong>（对扩展开放、对修改关闭）、<strong>代码解耦</strong>（降低代码的耦合性）等。</p><p>换一个角度考虑，定义类的方法的时候，不要暴露太多的实现细节，以保证在修改方法的实现的时候，不用再修改其定义。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承用来表示<strong>类之间的 is-a 关系</strong>，比如猫是一种哺乳动物。继承可以分为两种模式，<strong>单继承和多继承</strong>。</p><p>Java 使用 <strong>extends</strong> 关键字来实现继承，C++ 使用冒号（class B : public A），Python 使用 paraentheses()。有些编程语言只支持单继承，不支持多重继承，比如 Java。有些编程语言两种方式都支持，比如 C++、Python。</p><h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><p>多重继承存在钻石问题，即菱形继承。假设类 B 和类 C 继承自类 A，都重写了类 A 中的同一个方法，而类 D 同时继承了类 B 和类 C，那么此时类 D 会继承 B、C 的方法，那对于 B、C 重写的 A 中的方法，类 D 继承哪一个就无法确定。</p><p>Java支持多接口实现，因为接口中的方法是抽象的，即便一个类实现了多个接口，且这些接口中存在同名方法，但在实现接口的时候，这个同名方法需要由这个实现类自己来实现，所以避免了二义性的问题。</p><h3 id="继承的意义"><a href="#继承的意义" class="headerlink" title="继承的意义"></a>继承的意义</h3><p>继承最大的优点是<strong>代码复用</strong>。假如两个类有一些相同的属性和方法，就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。两个子类可以重用父类中的代码。不过，通过其他方式，比如利用<strong>组合关系</strong>而不是<strong>继承关系</strong>，也可以达到代码复用的目的。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是同一个行为具有多个不同表现形式或形态的能力，同一个接口，使用不同的实例而执行不同操作。<strong>子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现</strong>。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="继承-方法重写"><a href="#继承-方法重写" class="headerlink" title="继承 + 方法重写"></a>继承 + 方法重写</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicArray</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> capacity = DEFAULT_CAPACITY;  <span class="hljs-keyword">protected</span> Integer[] elements = <span class="hljs-keyword">new</span> Integer[DEFAULT_CAPACITY];    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.size; &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123; <span class="hljs-keyword">return</span> elements[index];&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Integer e)</span> </span>&#123;    ensureCapacity();    elements[size++] = e;  &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacity</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 如果数组满了就扩容...</span>  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortedDynamicArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DynamicArray</span> </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Integer e)</span> </span>&#123;    ensureCapacity();    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">for</span> (i = size-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; --i) &#123; <span class="hljs-comment">//保证数组中的数据有序</span>      <span class="hljs-keyword">if</span> (elements[i] &gt; e) &#123;        elements[i+<span class="hljs-number">1</span>] = elements[i];      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">break</span>;      &#125;    &#125;    elements[i+<span class="hljs-number">1</span>] = e;    ++size;  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(DynamicArray dynamicArray)</span> </span>&#123;    dynamicArray.add(<span class="hljs-number">5</span>);    dynamicArray.add(<span class="hljs-number">1</span>);    dynamicArray.add(<span class="hljs-number">3</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dynamicArray.size(); ++i) &#123;      System.out.println(dynamicArray.get(i));    &#125;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;    DynamicArray dynamicArray = <span class="hljs-keyword">new</span> SortedDynamicArray();    test(dynamicArray); <span class="hljs-comment">// 打印结果：1、3、5</span>  &#125;&#125;</code></pre><p>多态需要<strong>编程语言提供特殊的语法机制</strong>来实现。在上面的例子中，用到了三个语法机制来实现多态。</p><ul><li><strong>父类对象可以引用子类对象</strong>。可以将 SortedDynamicArray 传递给 DynamicArray。</li><li><strong>继承</strong>。SortedDynamicArray 继承了 DynamicArray，才能将 SortedDyamicArray 传递给 DynamicArray；</li><li><strong>子类可以重写（override）父类中的方法</strong>。SortedDyamicArray 重写了 DynamicArray 中的 add() 方法。</li></ul><p>这三种语法机制配合在一起，实现了在 test() 方法中，子类 SortedDyamicArray 替换父类 DynamicArray，执行子类 SortedDyamicArray 的 add() 方法，实现了多态特性。</p><p>对于多态的实现方式，除了利用<strong>继承加方法重写</strong>这种方式外，还有其他两种比较常见的的实现方式，一个是利用<strong>接口类语法</strong>，另一个是利用 <strong>duck-typing 语法</strong>。不过，并不是每种编程语言都支持接口类或者 duck-typing 这两种语法机制，比如 C++ 不支持接口类语法，而 duck-typing 只有一些动态语言才支持，比如 Python、JavaScript 等。</p><h4 id="接口类语法"><a href="#接口类语法" class="headerlink" title="接口类语法"></a>接口类语法</h4><p>Iterator 是一个接口类，定义了一个可以遍历集合数据的迭代器。Array 和 LinkedList 都实现了接口类 Iterator。通过<strong>传递不同类型的实现类（Array、LinkedList）到 print(Iterator iterator) 函数中，支持动态的调用不同的 next()、hasNext() 实现</strong>。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span> </span>&#123;  <span class="hljs-function">String <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;  <span class="hljs-function">String <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;  <span class="hljs-function">String <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Array</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span> </span>&#123;  <span class="hljs-keyword">private</span> String[] data;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-comment">// 省略其它方法...</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span> </span>&#123;  <span class="hljs-keyword">private</span> LinkedListNode head;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-comment">// 省略其它方法... </span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Iterator iterator)</span> </span>&#123;    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;      System.out.println(iterator.next());    &#125;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Iterator arrayIterator = <span class="hljs-keyword">new</span> Array();    print(arrayIterator);        Iterator linkedListIterator = <span class="hljs-keyword">new</span> LinkedList();    print(linkedListIterator);  &#125;&#125;</code></pre><p>Java 通过<strong>继承实现多态特性</strong>，必须要求两个<strong>类之间有继承关系</strong>。通过<strong>接口实现多态特性</strong>，<strong>类必须实现对应的接口</strong>。</p><h3 id="多态的意义"><a href="#多态的意义" class="headerlink" title="多态的意义"></a>多态的意义</h3><p>多态特性能<strong>提高代码的可扩展性和复用性</strong>。利用多态，一个 print() 函数可以实现遍历打印不同类型集合的数据。当需要再增加一种要遍历打印的类型的时候，比如 HashMap，只需让 HashMap 实现 Iterator 接口，重新实现自己的 hasNext()、next() 等方法就可以了，不需要改动 print() 函数的代码，提高了代码的可扩展性。</p><p>多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等。</p><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="违反OOP风格的代码设计"><a href="#违反OOP风格的代码设计" class="headerlink" title="违反OOP风格的代码设计"></a>违反OOP风格的代码设计</h2><h3 id="滥用-getter、setter-方法"><a href="#滥用-getter、setter-方法" class="headerlink" title="滥用 getter、setter 方法"></a>滥用 getter、setter 方法</h3><ul><li>设计实现类的时候，除非真的需要，否则尽量不要给属性定义 setter 方法；</li><li>尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器，也要防范集合内部数据被修改的风险。</li></ul><h3 id="Constants-类、Utils-类的设计问题"><a href="#Constants-类、Utils-类的设计问题" class="headerlink" title="Constants 类、Utils 类的设计问题"></a>Constants 类、Utils 类的设计问题</h3><ul><li>对于这两种类的设计，尽量能做到职责单一，定义一些细化的小类，比如 RedisConstants、FileUtils，而不是定义一个大而全的 Constants 类、Utils 类；</li><li>如果能将这些类中的属性和方法，划分归并到其他业务类中，能极大地提高类的内聚性和代码的可复用性。</li></ul><h2 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h2><p>面向对象编程中，抽象类和接口是两个经常使用的语法概念，是面向对象四大特性以及很多设计模式、设计思想、设计原则编程实现的基础，例如：</p><ul><li>使用<strong>接口来实现面向对象的抽象特性、多态特性</strong>和<strong>基于接口而非实现</strong>的设计原则；</li><li>使用<strong>抽象类来实现面向对象的继承特性和模板设计模式</strong>等。</li></ul><p>继承关系是 is-a 的关系，接口表示 has-a 关系，表示<strong>具有某些功能</strong>。接口，有一个更形象的叫法：<strong>协议</strong>。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul><li>抽象类<strong>不允许被实例化</strong>，只能被<strong>继承</strong>；</li><li>抽象类可以包含属性和方法。抽象类中的成员变量可以是各种类型的，接口中的成员变量只能是 <strong>public static final</strong> 类型的；<ul><li>抽象类中的方法可以有方法体；</li><li>也可以不包含方法体。不包含代码实现的方法叫作<strong>抽象方法</strong>；</li></ul></li><li>子类继承抽象类，<strong>必须实现抽象类中的所有抽象方法</strong>。</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li><p>接口是隐式抽象的，声明接口时不必使用<strong>abstract</strong>关键字；</p></li><li><p>接口没有构造方法，接口不能实例化；</p></li><li><p>接口支持多继承；</p></li><li><p>接口中<strong>没有成员变量</strong>，<strong>只有方法声明，没有方法实现</strong>，实现接口的类<strong>必须实现接口中的所有方法</strong>；</p><ul><li>接口不包含任何<strong>非常量成员</strong>，任何 field 都是隐含着 public static final 的意义；</li></ul></li><li><p>接口没有<strong>非静态方法实现</strong>，要么是隐式的抽象方法（声明时不需要<strong>abstract</strong>关键字），要么是静态方法；</p><ul><li>JDK 1.8版本及以上，接口里可以有静态方法和方法体了，只有静态方法可以在接口中实现</li></ul></li></ul><h3 id="抽象类-OR-接口"><a href="#抽象类-OR-接口" class="headerlink" title="抽象类 OR 接口"></a>抽象类 OR 接口</h3><ul><li><strong>抽象类是一种自下而上的设计思路</strong>，先有子类的代码重复，然后抽象成上层的父类（抽象类）；</li><li>如果表示 <strong>is-a</strong> 的关系，为了解决<strong>代码复用</strong>的问题，使用<strong>抽象类</strong>；</li><li>接口是一种<strong>自上而下的设计思路</strong>，一般是先设计接口，再考虑具体的实现；</li><li>如果表示 <strong>has-a</strong> 关系，为了解决<strong>抽象</strong>而非代码复用的问题，使用<strong>接口</strong>；</li></ul><h2 id="基于接口而非实现编程"><a href="#基于接口而非实现编程" class="headerlink" title="基于接口而非实现编程"></a>基于接口而非实现编程</h2><p>“基于接口而非实现编程”，也可以表达为“<strong>基于抽象而非实现编程</strong>”。软件开发时一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。</p><p>本质上看，<strong>“接口”是一组“协议”或者“约定”，是功能提供者给使用者的一个“功能列表”</strong>。“接口”在不同的应用场景下会有不同的解读，比如服务端与客户端之间的“接口”，类库提供的“接口”，甚至是一组通信的协议都可以叫作“接口”。落实到具体的编码，“基于接口而非实现编程”原则中的“接口”，可以理解为编程语言中的<strong>接口或者抽象类</strong>。</p><p>这条原则能有效地提高代码质量。可以<strong>将接口和实现相分离，封装不稳定的实现，暴露稳定的接口</strong>。上游系统面向接口而非实现编程，<strong>不依赖不稳定的实现细节</strong>，当实现发生变化时，上游系统的代码基本上不需要改动，以此<strong>降低耦合性，提高扩展性</strong>。</p><h3 id="应用原则"><a href="#应用原则" class="headerlink" title="应用原则"></a>应用原则</h3><p>编写代码时遵从基于接口而非实现编程的原则：</p><ul><li><strong>函数的命名不能暴露任何实现细节</strong>；</li><li><strong>封装具体的实现细节</strong>；</li><li><strong>为实现类定义抽象的接口</strong>。具体的实现类依赖统一的接口定义，使用者依赖接口而非具体的实现类来编程。</li></ul><p>越不稳定的系统，越要在代码的扩展性、维护性上下功夫。不过，如果业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，没有必要为其设计接口，也没有必要基于接口编程，那么直接使用实现类就可以了。</p><h2 id="组合优于继承"><a href="#组合优于继承" class="headerlink" title="组合优于继承"></a>组合优于继承</h2><h3 id="继承的缺点"><a href="#继承的缺点" class="headerlink" title="继承的缺点"></a>继承的缺点</h3><p>继承层次越来越深，会使得继承关系会越来越复杂，引发以下问题：</p><ul><li>代码的可读性变差。因为要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码，一直追溯到最顶层父类的代码；</li><li>破坏了类的封装特性，降低可维护性。父类的实现细节暴露给子类，子类的实现依赖父类的实现，两者高度耦合。父类代码的修改会影响所有子类的逻辑。</li></ul><h3 id="组合的优势"><a href="#组合的优势" class="headerlink" title="组合的优势"></a>组合的优势</h3><p>可以利用组合（composition）、接口、委托（delegation）三个技术，解决继承存在的问题。</p><p>注：<strong>组合</strong>，java代码复用的一种方法。<strong>使用多个已有的对象组合为一个功能更加复杂强大的新对象</strong>。体现的是<strong>整体与部分、拥有的关系</strong>。因为在对象之间，各自的内部细节是不可见的，所以也说这种方式的代码复用是黑盒的。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyable</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span>；</span><span class="hljs-function">&#125;</span><span class="hljs-function"><span class="hljs-keyword">public</span> class FlyAbility implements Flyable </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//... &#125;</span>&#125;<span class="hljs-comment">//省略Tweetable/TweetAbility/EggLayable/EggLayAbility</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ostrich</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Tweetable</span>, <span class="hljs-title">EggLayable</span> </span>&#123;<span class="hljs-comment">//鸵鸟</span>  <span class="hljs-keyword">private</span> TweetAbility tweetAbility = <span class="hljs-keyword">new</span> TweetAbility(); <span class="hljs-comment">//组合</span>  <span class="hljs-keyword">private</span> EggLayAbility eggLayAbility = <span class="hljs-keyword">new</span> EggLayAbility(); <span class="hljs-comment">//组合</span>  <span class="hljs-comment">//... 省略其他属性和方法...</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tweet</span><span class="hljs-params">()</span> </span>&#123;    tweetAbility.tweet(); <span class="hljs-comment">// 委托</span>  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">layEgg</span><span class="hljs-params">()</span> </span>&#123;    eggLayAbility.layEgg(); <span class="hljs-comment">// 委托</span>  &#125;&#125;</code></pre><p>继承主要有三个作用：<strong>表示 is-a 关系，支持多态特性，代码复用</strong>。这三个作用都可以通过其他技术来达成。</p><ul><li>is-a 关系可以通过<strong>组合</strong>和<strong>接口的 has-a</strong> 关系来替代；</li><li>多态特性可以利用接口来实现；</li><li>代码复用可以通过组合和委托来实现。</li></ul><p>理论上讲，通过组合、接口、委托三种技术，可以替代继承。在项目中可以不用或者少用继承关系，特别是一些复杂的继承关系。</p><h3 id="组合-OR-继承"><a href="#组合-OR-继承" class="headerlink" title="组合 OR 继承"></a>组合 OR 继承</h3><p>继承改写成组合意味着要做更细粒度的类的拆分，定义更多的类和接口。类和接口的增多会增加代码的复杂程度和维护成本。实际的项目开发要根据具体的情况，具体地选择该用继承还是组合。</p><p>如果类之间的继承结构稳定，继承层次比较浅，继承关系不复杂，可以使用继承。反之，就尽量使用组合。</p><p>一些设计模式会固定使用继承或者组合。装饰者模式、策略模式、组合模式等都使用了组合关系，而模板模式使用了继承关系。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OOP</tag>
      
      <tag>Encapsulation</tag>
      
      <tag>Inheritance</tag>
      
      <tag>Polymorphism</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python Tips</title>
    <link href="/2020/07/21/Python-Tips/"/>
    <url>/2020/07/21/Python-Tips/</url>
    
    <content type="html"><![CDATA[<p>Python知识点整理。</p><a id="more"></a><h2 id="Python中的引用与拷贝"><a href="#Python中的引用与拷贝" class="headerlink" title="Python中的引用与拷贝"></a>Python中的引用与拷贝</h2><blockquote><p>区别</p><p>引用：旧瓶装旧酒<br>浅拷贝：新瓶装旧酒<br>深拷贝：新瓶装新酒</p></blockquote><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>python中赋值符号“=”两边的对象是同一个对象，左边的对象可以看成是右边对象的一个引用。</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>b=a<span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>b[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>a.append(<span class="hljs-string">'c'</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>b[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b<span class="hljs-literal">True</span></code></pre><p>a的值的变化会导致b的值也会变化，因为他们是同一个对象，共享同一块内存地址，b是a的引用。</p><p><strong>判断两个变量是否是同一个对象的方法是用is</strong>，返回True则代表两个变量是同一个对象。 </p><p>赋值是将一个对象的地址赋值给一个变量，让变量指向该地址。 </p><h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><p>对象的拷贝是根据源对象生成一个新的对象，占用不同的内容存空间。一个对象值的变化，不会影响另外一个对象的值。拷贝又分潜拷贝和深拷贝。 </p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>python中的copy模块可以实现对象的浅拷贝。 </p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> copy<span class="hljs-meta">&gt;&gt;&gt; </span>a=[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span>b=copy.copy(a)<span class="hljs-meta">&gt;&gt;&gt; </span>b <span class="hljs-keyword">is</span> a<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">False</span><span class="hljs-meta">&gt;&gt;&gt; </span>a.append(<span class="hljs-string">'c'</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>a[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>], <span class="hljs-string">'c'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>b[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">0</span>].append(<span class="hljs-number">3</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>a[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>], <span class="hljs-string">'c'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>b[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> b[<span class="hljs-number">0</span>]<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span><span class="hljs-comment"># b=a[:]会创建一个新的与a完全相同的对象，但是与a并不指向同一对象</span><span class="hljs-meta">&gt;&gt;&gt; </span>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span>b = a[:]<span class="hljs-meta">&gt;&gt;&gt; </span>b[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b<span class="hljs-literal">False</span><span class="hljs-meta">&gt;&gt;&gt; </span>a.append(<span class="hljs-number">7</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>], <span class="hljs-number">7</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>b[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">3</span>].append(<span class="hljs-number">9</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>], <span class="hljs-number">7</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>b[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">3</span>] <span class="hljs-keyword">is</span> b[<span class="hljs-number">3</span>]<span class="hljs-literal">True</span>&gt;&gt;&gt;</code></pre><p>通过例子可以看到通过copy模块的copy方法，根据对象a生成了一个新对象b，这一点可以通过is表达式的结果证明。 </p><p>a.append(‘c’)之后，发现a和b的值不一样了，这是因为a和b指向两个不同的地址。对a的值的修改不会影响b的值。 但是a[0].append(3)之后，a[0]和b[0]却是一样的。这就是浅拷贝的效果。因为a[0] 和b[0]还是指向同一个地址。 </p><p>浅拷贝是在另一块地址中创建一个新的变量或容器，但是容器内的元素的地址均是源对象的元素的地址的拷贝。也就是说新的容器中指向了旧的元素。</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>python的copy模块的deepcopy函数可以实现深拷贝。</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> copy<span class="hljs-meta">&gt;&gt;&gt; </span>a=[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span>b=copy.deepcopy(a)<span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b<span class="hljs-literal">False</span><span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> b[<span class="hljs-number">0</span>]<span class="hljs-literal">False</span><span class="hljs-meta">&gt;&gt;&gt; </span>a.append(<span class="hljs-string">'c'</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>a[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>], <span class="hljs-string">'c'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>b[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">0</span>].append(<span class="hljs-number">3</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>a[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span>b[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]]</code></pre><p>由于b是a的深拷贝，所以a对象和b对象的内存地址不同，a对象和b对象包含的底层对象（a[0]a[1]b[0]b[1]）内存地址也不同。 </p><p>对a对象的值的改变不会影响b对象的值，对a对象的底层对象的值的改变也不会影响b的底层对象的值。</p><p>深拷贝是在另一块地址中创建一个新的变量或容器，同时容器内的元素的地址也是新开辟的，仅仅是值相同而已，是完全的副本。</p><h3 id="二维数组初始化"><a href="#二维数组初始化" class="headerlink" title="二维数组初始化"></a>二维数组初始化</h3><p><a href="https://blog.csdn.net/yockie/article/details/46127829" target="_blank" rel="noopener">python创建二维数组</a></p><pre><code class="hljs python"><span class="hljs-comment"># list * n—&gt;n shallow copies of list concatenated, n个list的浅拷贝的连接</span><span class="hljs-meta">&gt;&gt;&gt; </span>dimen_list = [[<span class="hljs-number">0</span>] * <span class="hljs-number">3</span>] * <span class="hljs-number">4</span><span class="hljs-meta">&gt;&gt;&gt; </span>dimen_list[[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span>dimen_list[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><span class="hljs-meta">&gt;&gt;&gt; </span>dimen_list[[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]]<span class="hljs-meta">&gt;&gt;&gt; </span>lists = [[]] * <span class="hljs-number">3</span><span class="hljs-meta">&gt;&gt;&gt; </span>lists[[], [], []]<span class="hljs-meta">&gt;&gt;&gt; </span>lists[<span class="hljs-number">0</span>].append(<span class="hljs-number">3</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>lists[[<span class="hljs-number">3</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">3</span>]]<span class="hljs-comment"># 需要用另一种方式创建多维数组,以免浅拷贝</span><span class="hljs-meta">&gt;&gt;&gt; </span>size = <span class="hljs-number">3</span><span class="hljs-meta">&gt;&gt;&gt; </span>lists = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(size)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(size)]<span class="hljs-meta">&gt;&gt;&gt; </span>lists[[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]</code></pre><h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><p>Python内置类型：主要有数字、序列、映射、类、实例和异常。 </p><p><strong>数字类型</strong>：int, float, complex</p><p><strong>迭代器类型</strong>：Python 支持对容器进行迭代。序列支持迭代方法。</p><p><strong>生成器类型</strong>：Python 的 generator 提供了一种实现迭代器协议的便捷方式。</p><p><strong>不可变序列类型</strong>：数字、布尔、元组tuple、range 类型表示不可变的数字序列、文本序列类型（字符串）str、bytes、frozenset</p><p>注：由于许多主要二进制协议都基于 ASCII 文本编码，因此 bytes 对象提供了一些仅在处理 ASCII 兼容数据时可用，并且在许多特性上与字符串对象紧密相关的方法。 </p><p><strong>可变序列类型</strong>：列表list、字典dic、set，不可以作为字典的key</p><p>不可变序列类型普遍实现，而可变序列类型未实现的操作是对 <strong>hash()</strong> 内置函数的支持。也就是说，<strong>hash() 函数可以应用于数字、字符串和对象，但是不能直接应用于list、set、dictionary</strong>。 </p><pre><code class="hljs python">列表解析式：[x*<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>)]  字典解析式：my_dict = &#123;i: i * i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>)&#125;  集合解析式：my_set = &#123;i * <span class="hljs-number">15</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>)&#125;字符串/列表逆序：<span class="hljs-meta">&gt;&gt;&gt; </span>str = <span class="hljs-string">"abc"</span><span class="hljs-meta">&gt;&gt;&gt; </span>str[::<span class="hljs-number">-1</span>]    <span class="hljs-comment"># 原字符串不改变</span><span class="hljs-string">'cba'</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">''</span>.join(reversed(str))  <span class="hljs-comment"># 原字符串不改变</span><span class="hljs-string">'cba'</span>           <span class="hljs-meta">&gt;&gt;&gt; </span>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>a[::<span class="hljs-number">-1</span>]      <span class="hljs-comment"># 原列表不改变 </span>[<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>a.reverse()  <span class="hljs-comment"># 原列表改变 </span><span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]</code></pre><p><strong>空对象</strong>：当函数无显示返回值时，会返回该对象。它不支持任何特殊的操作。空对象只有一种值 None (内置名称)。</p><p><strong>优先队列的特点</strong>：队列的特点是先进先出，入队时，将新元素置于队尾巴，出队时，队头元素最先被移出。优先队列不再遵循先入先出的原则，而分为两种情况：1）最大优先队列，无论入队顺序如何，都是当前最大的元素出队；2）最小优先队列，无论入队顺序如何，都是当前最小的元素出队。</p><p><strong>优先队列的实现</strong>：二叉堆有以下性质：1）最大堆的堆顶是整个堆中的最大元素；2) 最小堆的堆顶是整个堆中的最小元素。因此，可以用最大堆来实现最大优先队列，每一次入队操作就是堆的插入操作，每一次出队操作就是删除堆顶节点。二叉堆节点上浮和下沉的时间复杂度都是O(logn)，所以优先队列的入队和出队的时间复杂度也是O(logn)。</p><p>python中heapq模块实现了最小堆。heapq有两种方式创建堆：1）使用一个空列表，然后使用heapq.heappush()方法将值加入堆中；2）使用heap.heapify(list)转换列表成为堆结构。 </p><table><thead><tr><th>heapify(heap)</th><th>让列表具备堆特征</th></tr></thead><tbody><tr><td>heappush(heap, x)</td><td>将x压入堆中</td></tr><tr><td>heappop(heap)</td><td>从堆中弹出最小的元素</td></tr><tr><td>heapreplace(heap, x)</td><td>弹出最小的元素，并将x压入堆中</td></tr><tr><td>nlargest(n, iter)</td><td>返回iter中n个最大的元素</td></tr><tr><td>nsmallest(n, iter)</td><td>返回iter中n个最小的元素</td></tr></tbody></table><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p><a href="https://www.runoob.com/python3/python3-func-enumerate.html" target="_blank" rel="noopener">enumerate() </a></p><p>enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据下标和数据，一般用在 for 循环当中。 </p><pre><code class="hljs python">&gt;&gt;&gt;seq = [<span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>, <span class="hljs-string">'three'</span>]&gt;&gt;&gt;<span class="hljs-keyword">for</span> i, element <span class="hljs-keyword">in</span> enumerate(seq):<span class="hljs-meta">... </span>   print(i, seq[i])<span class="hljs-meta">... </span><span class="hljs-number">0</span> one<span class="hljs-number">1</span> two<span class="hljs-number">2</span> three</code></pre><p><a href="https://www.runoob.com/python3/python3-func-zip.html" target="_blank" rel="noopener">zip()</a></p><p>zip() 函数将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。可以使用 list() 转换来输出列表。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 ***** 号操作符，可以将元组解压为列表。</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>b = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>c = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>zipped = zip(a,b)  <span class="hljs-comment"># 返回一个对象</span><span class="hljs-meta">&gt;&gt;&gt; </span>zipped&lt;zip object at <span class="hljs-number">0x103abc288</span>&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>list(zipped)       <span class="hljs-comment"># list() 转换为列表</span>[(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">6</span>)]<span class="hljs-meta">&gt;&gt;&gt; </span>list(zip(a,c))     <span class="hljs-comment"># 元素个数与最短的列表一致</span>[(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">6</span>)] <span class="hljs-meta">&gt;&gt;&gt; </span>a1, a2 = zip(*zip(a,b))  <span class="hljs-comment"># 与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式</span><span class="hljs-meta">&gt;&gt;&gt; </span>list(a1)[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>list(a2)[<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]</code></pre><p><a href="https://www.runoob.com/python3/python3-func-reversed.html" target="_blank" rel="noopener">reversed(seq)</a></p><p>返回一个反转的迭代器；参数：要转换的序列，可以是tuple, string, list 或 range。</p><pre><code class="hljs python"><span class="hljs-comment"># 字符串</span><span class="hljs-meta">&gt;&gt;&gt; </span>seqString = <span class="hljs-string">'Runoob'</span><span class="hljs-meta">&gt;&gt;&gt; </span>print(list(reversed(seqString)))[<span class="hljs-string">'b'</span>, <span class="hljs-string">'o'</span>, <span class="hljs-string">'o'</span>, <span class="hljs-string">'n'</span>, <span class="hljs-string">'u'</span>, <span class="hljs-string">'R'</span>]</code></pre><p><a href="https://www.runoob.com/python/python-func-eval.html" target="_blank" rel="noopener">eval()</a></p><p>eval() 函数用来执行一个字符串表达式，返回表达式的值。</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = <span class="hljs-number">7</span><span class="hljs-meta">&gt;&gt;&gt; </span>eval( <span class="hljs-string">'3 * x'</span> )<span class="hljs-number">21</span><span class="hljs-meta">&gt;&gt;&gt; </span>eval(<span class="hljs-string">'pow(2,2)'</span>)<span class="hljs-number">4</span><span class="hljs-meta">&gt;&gt;&gt; </span>eval(<span class="hljs-string">'2 + 2'</span>)<span class="hljs-number">4</span><span class="hljs-meta">&gt;&gt;&gt; </span>n=<span class="hljs-number">81</span><span class="hljs-meta">&gt;&gt;&gt; </span>eval(<span class="hljs-string">"n + 4"</span>)<span class="hljs-number">85</span></code></pre><p><a href="https://www.runoob.com/python/python-func-bin.html" target="_blank" rel="noopener">bin()</a></p><p>返回整数 int 或者长整数 long int 的二进制表示。 </p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bin(<span class="hljs-number">11</span>)<span class="hljs-string">'0b1011'</span><span class="hljs-meta">&gt;&gt;&gt; </span>bin(<span class="hljs-number">20</span>)<span class="hljs-string">'0b10100'</span>str = <span class="hljs-meta">&gt;&gt;&gt; </span>str = <span class="hljs-string">"1010"</span><span class="hljs-meta">&gt;&gt;&gt; </span>int(str, base=<span class="hljs-number">2</span>)<span class="hljs-number">10</span></code></pre><p><a href="https://www.runoob.com/python/python-func-getattr.html" target="_blank" rel="noopener">getattr()</a></p><p>getattr(object, name[, default]) 函数用于返回一个对象属性值。用例，leetcode习题解6：链表组件。</p><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">A</span>(<span class="hljs-symbol">object</span>):    <span class="hljs-symbol">bar</span> = <span class="hljs-symbol">1</span>&gt;&gt;&gt; <span class="hljs-symbol">a</span> = <span class="hljs-symbol">A</span>()&gt;&gt;&gt; <span class="hljs-symbol">getattr</span>(<span class="hljs-symbol">a, </span>'<span class="hljs-symbol">bar</span>')  # 获取属性 <span class="hljs-symbol">bar</span> 值<span class="hljs-symbol">1</span></code></pre><p><a href="https://www.runoob.com/python3/python3-string-maketrans.html" target="_blank" rel="noopener">maketrans()</a></p><p>str.maketrans(intab_str, outtab_str) 创建字符映射的转换表。第一个参数表示需要转换的字符，第二个表示转换的目标。两个字符串的长度必须相同，为一一对应关系</p><p><a href="https://www.runoob.com/python3/python3-string-translate.html" target="_blank" rel="noopener">translate()</a></p><p>translate() 方法根据参数table给出的表(包含 256 个字符)转换字符串的字符，要过滤掉的字符放到 deletechars 参数中。</p><pre><code class="hljs python">intab = <span class="hljs-string">"aeiou"</span>outtab = <span class="hljs-string">"12345"</span>trantab = str.maketrans(intab, outtab)   <span class="hljs-comment"># 制作翻译表</span> str = <span class="hljs-string">"this is string example....wow!!!"</span><span class="hljs-keyword">print</span> (str.translate(trantab))<span class="hljs-comment"># th3s 3s str3ng 2x1mpl2....w4w!!!</span></code></pre><p>ord() 和 chr()</p><p>ord() 和 chr() 方法将字母和ASCII相互转化。</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>ord(<span class="hljs-string">'A'</span>) <span class="hljs-number">65</span> <span class="hljs-meta">&gt;&gt;&gt; </span>chr(<span class="hljs-number">65</span>) <span class="hljs-string">'A'</span></code></pre><p><a href="https://www.runoob.com/python/att-string-join.html" target="_blank" rel="noopener">join()</a></p><p>str.join(sequence) 方法用于将序列中的元素以指定的字符连接生成一个新的字符串，sequence为要连接的元素序列。返回通过指定字符连接序列中元素后生成的新字符串。 </p><pre><code class="hljs python">str = <span class="hljs-string">"-"</span>seq = (<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>)<span class="hljs-keyword">print</span> str.join(seq)<span class="hljs-comment"># a-b-c</span>list = [<span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>]print(<span class="hljs-string">''</span>.join(list))<span class="hljs-comment"># 123</span>seq = &#123;<span class="hljs-string">'hello'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'world'</span>: <span class="hljs-number">2</span>&#125;print(<span class="hljs-string">'-'</span>.join(seq))  <span class="hljs-comment"># 字典只对键进行连接</span><span class="hljs-comment"># hello-world</span><span class="hljs-keyword">import</span> os<span class="hljs-keyword">print</span> os.path.join(<span class="hljs-string">"D:\\"</span>,<span class="hljs-string">"test.txt"</span>)  <span class="hljs-comment"># 连接2个字符串</span><span class="hljs-comment"># D:\test.txt</span><span class="hljs-comment"># file_path存放于E:\PySec</span>print(os.path.abspath(<span class="hljs-string">'.'</span>))print(os.path.dirname(os.path.abspath(<span class="hljs-string">'.'</span>)))  <span class="hljs-comment"># abspath('.')返回当前目录的绝对路径</span>file_dir = os.path.dirname(os.path.abspath(<span class="hljs-string">'.'</span>)) + <span class="hljs-string">'data'</span>lists = os.listdir(file_dir)print(lists)file = os.path.join(file_dir, lists[<span class="hljs-number">-1</span>])print(file)<span class="hljs-comment"># E:\PySec</span><span class="hljs-comment"># E:\</span><span class="hljs-comment"># ['DAG reference.pdf', 'formatted.csv', 'formatted_1.csv', 'formatted_2.csv', 'Pro_process.docx']</span><span class="hljs-comment"># E:\data\Pro_process.docx</span></code></pre><p><a href="https://www.runoob.com/python3/python3-os-path.html" target="_blank" rel="noopener">os.path()</a></p><p>os.path 模块主要用于获取文件的属性。</p><p><a href="https://www.runoob.com/python/att-string-find.html" target="_blank" rel="noopener">find()</a></p><p>str.find(str, beg=0, end=len(string))。Python find() 方法检测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，如果包含子字符串返回开始的索引值，否则返回-1。</p><p><a href="https://www.runoob.com/python/att-string-isalpha.html" target="_blank" rel="noopener">isalpha()</a></p><p>isalpha() 方法检测字符串是否只由字母组成。如果字符串至少有一个字符并且所有字符都是字母则返回 True，否则返回 False。</p><p><a href="https://www.runoob.com/python/python-func-all.html" target="_blank" rel="noopener">all()</a></p><p>all() 函数用于判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。元素除了是 0、空、None、False 外都算 True。</p><p><a href="https://blog.csdn.net/LaoYuanPython/article/details/95082169" target="_blank" rel="noopener">富比较</a></p><p>Python中基类object提供了一系列可以用于实现同类对象进行“比较”的方法，可以用于同类对象的不同实例进行比较，包括 <strong>lt</strong>、<strong>gt</strong>、<strong>le</strong>、<strong>ge</strong>、<strong>eq</strong>和<strong>ne</strong> 六个方法。</p><p><a href="https://docs.python.org/zh-cn/3.7/library/itertools.html" target="_blank" rel="noopener">排列组合</a></p><p>python的itertools包中提供了和排列组合相关的函数：</p><ul><li><a href="https://docs.python.org/zh-cn/3.7/library/itertools.html#itertools.combinations" target="_blank" rel="noopener">combinations</a>方法重点在组合</li><li><a href="https://docs.python.org/zh-cn/3.7/library/itertools.html#itertools.permutations" target="_blank" rel="noopener">permutations</a>方法重在排列</li><li><a href="https://docs.python.org/zh-cn/3.7/library/itertools.html#itertools.product" target="_blank" rel="noopener">product</a> 用于求多个可迭代对象的笛卡尔积(Cartesian Product)，它跟嵌套的 for循环等价。即：product(A, B) 和 ((x,y) for x in A for y in B)的效果是一样的。</li></ul><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> combinations, permutations, product<span class="hljs-meta">&gt;&gt;&gt; </span>list(combinations(<span class="hljs-string">'abc'</span>,<span class="hljs-number">2</span>))[(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>), (<span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>)]<span class="hljs-meta">&gt;&gt;&gt; </span>list(permutations(<span class="hljs-string">'abc'</span>,<span class="hljs-number">2</span>))[(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>), (<span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>), (<span class="hljs-string">'c'</span>, <span class="hljs-string">'a'</span>), (<span class="hljs-string">'c'</span>, <span class="hljs-string">'b'</span>)]<span class="hljs-meta">&gt;&gt;&gt; </span>list(product(<span class="hljs-string">'abc'</span>,repeat=<span class="hljs-number">2</span>))[(<span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>), (<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>), (<span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-string">'b'</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>), (<span class="hljs-string">'c'</span>, <span class="hljs-string">'a'</span>), (<span class="hljs-string">'c'</span>, <span class="hljs-string">'b'</span>), (<span class="hljs-string">'c'</span>, <span class="hljs-string">'c'</span>)]<span class="hljs-meta">&gt;&gt;&gt; </span>list(product(<span class="hljs-string">'abc'</span>,<span class="hljs-string">'de'</span>))[(<span class="hljs-string">'a'</span>, <span class="hljs-string">'d'</span>), (<span class="hljs-string">'a'</span>, <span class="hljs-string">'e'</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-string">'d'</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-string">'e'</span>), (<span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>), (<span class="hljs-string">'c'</span>, <span class="hljs-string">'e'</span>)]</code></pre><p><a href="https://blog.csdn.net/transformed/article/details/89879193" target="_blank" rel="noopener">cmp_to_key</a></p><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> cmp_to_key L=[<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">23</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] sorted(L,key=cmp_to_key(<span class="hljs-keyword">lambda</span> x,y:y-x))<span class="hljs-comment"># Output：</span><span class="hljs-comment"># [23, 9, 2, 2, 1]</span>  sorted(L,key=cmp_to_key(<span class="hljs-keyword">lambda</span> x,y:x-y))<span class="hljs-comment"># [1, 2, 2, 9, 23]</span></code></pre><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>总结Python常用数据结构的操作的时间复杂度。</p><p><a href="https://www.jianshu.com/p/a8fa3d31aa40" target="_blank" rel="noopener">参考一</a> </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.python.org/zh-cn/3.7/library/stdtypes.html" target="_blank" rel="noopener">python3.7.6文档：内置类型</a></p><p><a href="https://github.com/JiaxingZhao/Python--Antic/blob/master/Python%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB" target="_blank" rel="noopener">Python知识点汇总</a></p><p><a href="https://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">Python3教程</a></p><p><a href="https://blog.csdn.net/liuchunming033/article/details/51493367" target="_blank" rel="noopener">Python语言中的引用与拷贝</a></p><p><a href="https://www.jianshu.com/p/801318c77ab5" target="_blank" rel="noopener">Python标准库模块之heapq</a></p><p><a href="https://blog.csdn.net/LaoYuanPython/article/details/95082169" target="_blank" rel="noopener">为什么Python中称lt、gt等为“富比较”方法</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
