<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java常用集合</title>
    <link href="/2020/07/22/Java%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/"/>
    <url>/2020/07/22/Java%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p>文章主要归纳介绍 Java 的集合框架与设计结构。包括 Java 提供的主要集合类型（Collections 和 Map），对应的数据结构、算法，考虑不同场景下的具体技术选择。</p><pre><code class="hljs markdown"><span class="xml"><span class="hljs-comment">&lt;!-- more --&gt;</span></span></code></pre><h2 id="Java-集合总览"><a href="#Java-集合总览" class="headerlink" title="Java 集合总览"></a>Java 集合总览</h2><p>总的来说，Java 集合框架涉及很多方面：</p><ul><li>Java 集合框架的设计结构；</li><li>Java 提供的主要集合类型（Collections 和 Map），对应的数据结构、算法，思考具体技术选择；</li><li>Java 集合不同场景下的性能，如并发等领域；</li></ul><h2 id="Java-集合框架设计结构"><a href="#Java-集合框架设计结构" class="headerlink" title="Java 集合框架设计结构"></a>Java 集合框架设计结构</h2><p>Java中提供了丰富的集合接口和类，它们来自于java.util包。Java集合类型分为：Collection和Map，Collection子接口有：Set、Queue和List等接口。每一种集合接口定义和描述了一种数据结构。</p><p><strong>Collection 接口</strong>是所有集合的根，然后扩展开提供了三大类集合，分别是：</p><ul><li><strong>List</strong>，有序集合，提供方便的访问、插入、删除等操作；</li><li><strong>Set</strong>，不允许重复元素，不存在两个对象 equals 返回 true。在需要保证元素唯一性的场景下使用较多；</li><li><strong>Queue/Deque</strong>，除了集合的基本功能，它还支持先入先出FIFO或后入先出LIFO等约束行为。并发包中有BlockingQueue。</li></ul><p><strong>Map</strong>允许按照某个键来访问元素。Map集合由两个集合构成：键集合，值集合。键集合是Set类型，不能有重复的元素。值集合是Collection类型，可以有重复的元素。</p><p>每种集合的通用逻辑，都被抽象到相应的抽象类之中，比如 AbstractList 就集中了各种 List 操作的通用部分。这些集合不是完全孤立的，例如LinkedList 实现了 List 和 Deque。</p><p><img src="D:%5Cblog%5Csource%5Cimage%5Cjava_collection.png" srcset="/img/loading.gif" alt=""></p><p><img src="D:%5Cblog%5Csource%5Cimage%5Cjava_map.png" srcset="/img/loading.gif" alt=""></p><p><strong>注：</strong></p><ul><li>Iterator通用迭代器、ListIterator针对 List 特化的迭代器</li><li>Comparator比较器、Comparable 排序接口</li><li>Collections常用算法类、Arrays静态数组的排序、查找算法</li></ul><h2 id="Java-主要集合类型"><a href="#Java-主要集合类型" class="headerlink" title="Java 主要集合类型"></a>Java 主要集合类型</h2><p>重点关注常用的实现类，掌握对应的数据结构、算法，能够根据不同的场景，进行具体的技术选择。</p><p><img src="D:%5Cblog%5Csource%5Cimage%5Cjava_common_collection.png" srcset="/img/loading.gif" alt=""></p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Vector、ArrayList 和 LinkedList 实现了 List，是<strong>有序集合</strong>。都提供按照位置进行定位、添加或者删除的操作，提供迭代器以遍历其内容等。但因为具体的设计区别，在行为、性能、线程安全等方面，表现又有很大不同。</p><ul><li>Vector 是 Java 早期提供的<strong>线程安全的动态数组</strong>，内部使用<strong>对象数组</strong>来保存数据。如果不需要线程安全，并不建议选择，毕竟同步有额外开销。可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据；</li><li>ArrayList 的应用更加广泛，使用<strong>动态数组</strong>实现，<strong>不是线程安全</strong>的，所以性能要好很多。ArrayList 也可以根据需要调整容量，两者的调整逻辑有所区别，<strong>Vector 在扩容时会提高 1 倍，而 ArrayList 增加 50%；</strong></li><li>LinkedList 是 Java 提供的<strong>双向链表</strong>，不需要像上面两种那样调整容量，但是因为存在额外的前驱和后继节点指针，所以占用的内存比 ArrayList 多一些。任意位置的插入删除很方便，不支持随机取值，只能从一端开始遍历，直到找到查询的对象。它<strong>不是线程安全的。</strong></li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>HashSet、LinkedHashSet 和 TreeSet 实现了Set。特点是<strong>元素不重复</strong>，<strong>存取无序</strong>。</p><ul><li>HashSet 以 HashMap 为基础实现。利用<strong>哈希算法</strong>，理想情况下添加、删除、包含等操作的<strong>时间复杂度为常数</strong>，它不保证有序。</li><li>LinkedHashSet 内部构建了一个记录插入顺序的双向链表，因此提供了<strong>按照插入顺序进行遍历</strong>的能力，也保证常数时间的包含、添加、删除等操作，这些<strong>操作性能略低于 HashSet</strong>，因为需要维护链表的开销；</li><li>TreeSet 默认利用 TreeMap 实现。支持自然顺序访问，包含、添加、删除、等操作相对低效（log(n) ）；</li></ul><p>在遍历元素时，HashSet 性能受自身容量影响，所以初始化时，除非有必要，不然不要将其背后的 HashMap 容量设置过大。而对于 LinkedHashSet，由于其内部链表提供的方便，所以遍历性能只和元素多少有关系。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Hashtable、HashMap、TreeMap 是最常见的 Map 的实现，<strong>以键值对的形式存储和操作数据的集合类型。</strong></p><ul><li>Hashtable 是早期 Java 类库提供的一个哈希表实现，本身<strong>是同步的</strong>，<strong>不支持 null 键和值</strong>，由于同步导致的性能开销，所以已经<strong>很少被推荐使用</strong>；</li><li>HashMap 应用更加广泛，利用哈希表实现。<strong>HashMap 不是同步的，支持 null 键和值等</strong>。通常情况下HashMap 的 put 或 get 操作的时间复杂度为常数。所以它是<strong>绝大部分利用键值对存取场景的首选</strong>，比如，实现一个用户 ID 和用户信息对应的运行时存储结构；<ul><li>大部分使用 Map 的场景，通常就是<strong>放入、访问或者删除</strong>，对顺序没有特别要求，HashMap 在这种情况下基本是最好的选择。</li></ul></li><li>LinkedHashMap 继承于HashMap，是基于HashMap和双向链表来实现的。LinkedHashMap 是有序的，可分为插入顺序和访问顺序。如果是访问顺序，那put和get操作已存在的Entry时，都会<strong>把Entry移动到双向链表的表尾(</strong>其实是先删除再插入)，存取数据时和 HashMap 一样，使用 Entry[] 的方式，双向链表只是为了保证顺序。LinkedHashMap <strong>不是线程安全</strong>的；<ul><li>这种特点适用于一些特定应用场景，例如：构建一个空间占用敏感的资源池，可以自动将最不常被访问的对象释放。那么，表满时需要删除时候就是头部元素。</li></ul></li><li>TreeMap 是基于<strong>红黑树</strong>实现的一种按序访问的 Map，TreeMap能够把它保存的记录根据键进行排序，默认是按键值的升序排序，也可以指定排序的比较器，具体顺序可以由指定的 <strong>Comparator</strong> 决定。用 Iterator 遍历时，得到的记录是排过序的。它的 get、put、remove 操作的时间复杂度是 O(log(n))，所以TreeMap实际使用的比较少。<ul><li>TreeMap 和 LinkedHashMap 都可以保证某种顺序，但二者还是不同的。TreeMap 的整体顺序由键的顺序关系决定，即通过 Comparator 或 Comparable（自然顺序）决定。</li></ul></li></ul><h4 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h4><p>HashMap 的性能表现非常依赖于哈希值的有效性，需要掌握相关内容。</p><h5 id="Java中equals和-的区别"><a href="#Java中equals和-的区别" class="headerlink" title="Java中equals和==的区别"></a>Java中equals和==的区别</h5><ul><li>== 的作用：<ul><li>基本类型：比较的就是值是否相同；</li><li>引用类型：比较的就是地址值是否相同</li></ul></li><li>equals() 的作用：<ul><li>引用类型：默认情况下，比较的是地址值。但是一般来说，意义不大。所以，一些类库重写了这个方法，如String、Integer、Date。这些类当中 equals 有其自身的实现，一般是用来比较对象的成员变量值是否相同，而不再是比较类在堆内存中的存放地址了。</li></ul></li></ul><h5 id="hashCode（）与-equals（）的相关规定"><a href="#hashCode（）与-equals（）的相关规定" class="headerlink" title="hashCode（）与 equals（）的相关规定"></a>hashCode（）与 equals（）的相关规定</h5><ul><li>如果两个对象相等（equals 相等），那么 hashCode 一定相等；</li><li>两个对象相等，对两个对象分别调用 equals 方法都返回 true；</li><li>两个对象有相同的哈希值(hash code)，它们不一定相等；</li><li>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖，所以<strong>重写了 equals 也要重写 hashCode；</strong></li><li>equals 有对称、反射、传递等特性。</li></ul><h4 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h4><p>掌握HashMap 设计与实现的基本原理与方法，对深入理解集合和数据结构有一些帮助。</p><ul><li>HashMap 内部实现基本点分析;</li><li>容量（capacity）和负载系数（load factor）;</li><li>树化 。</li></ul><p>HashMap 内部的结构如下图，它可以看作是<strong>数组和链表结合组成</strong>的复合结构，数组被分为一个个<strong>桶</strong>，通过<strong>哈希值决定键值对在这个数组的寻址</strong>；<strong>哈希值相同的键值对，则以链表形式存储</strong>。需要注意的是，如果链表大小超过阈值（TREEIFY_THRESHOLD, 8），链表就会被改造为树形结构。</p><p><img src="D:%5Cblog%5Csource%5Cimage%5Chash_buckets.png" srcset="/img/loading.gif" alt=""></p><h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h5><p>putVal 方法逻辑比较集中，从初始化、扩容到树化都和它有关，阅读源码时需要多加关注。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><span class="hljs-function"><span class="hljs-params">               <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;    HashMap.Node&lt;K,V&gt;[] tab; HashMap.Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)        n = (tab = resize()).length;    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span>            treeifyBin(tab, hash);    &#125;    <span class="hljs-keyword">if</span> (++size &gt; threshold)        resize();&#125;</code></pre><ul><li><p>如果表格是 null，resize 方法会初始化它；</p></li><li><p>resize 方法兼顾两个职责，创建初始存储表格，或者在容量不满足需求的时候，进行扩容resize；</p></li><li><p>在放置新的键值对的过程中，如果++size &gt; threshold，就会发生扩容</p></li><li><p>具体键值对在哈希表中的位置（数组 index）取决于下面的位运算：</p><pre><code class="hljs java">i = (n - <span class="hljs-number">1</span>) &amp; hash</code></pre></li></ul><p>将高位数据移位到低位进行异或运算的原因是：有些数据计算出的哈希值差异主要在高位，而 HashMap 里的哈希寻址是忽略容量以上的高位的，这种处理可以有效避免类似情况下的哈希碰撞。</p><pre><code class="hljs processing"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> hash(<span class="hljs-keyword">Object</span> kye) &#123;    <span class="hljs-built_in">int</span> h;    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">key</span> == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = <span class="hljs-built_in">key</span>.hashCode()) ^ (h &gt;&gt;&gt;<span class="hljs-number">16</span>;&#125;</code></pre><h5 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h5><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;    Node&lt;K,V&gt;[] oldTab = table;    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;    <span class="hljs-keyword">int</span> oldThr = threshold;    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;            threshold = Integer.MAX_VALUE;            <span class="hljs-keyword">return</span> oldTab;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span>        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span>            newCap = oldThr;        <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span>            newCap = DEFAULT_INITIAL_CAPACITY;            newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);        &#125;        <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?                      (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);        &#125;        threshold = newThr;        <span class="hljs-meta">@SuppressWarnings</span>(&#123;<span class="hljs-string">"rawtypes"</span>,<span class="hljs-string">"unchecked"</span>&#125;)            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];        table = newTab;        <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// ....</span>    &#125;        <span class="hljs-keyword">return</span> newTab;</code></pre><ul><li>不考虑极端情况，容量理论最大极限由 MAXIMUM_CAPACITY 指定，数值为 1&lt;&lt;30，也就是 2 的 30 次方；</li><li>门限值 = 负载因子 x 容量，如果构建 HashMap 的时候没有指定，那么依据相应的默认常量值；</li><li>门限通常以倍数进行调整 （newThr = oldThr &lt;&lt; 1），当元素个数超过门限大小时，则调整 Map 大小；</li><li>扩容后，需要将老的数组中的元素重新放置到新的数组，这是扩容的一个主要开销来源。</li></ul><h5 id="容量、负载因子和树化"><a href="#容量、负载因子和树化" class="headerlink" title="容量、负载因子和树化"></a>容量、负载因子和树化</h5><p>容量和负载系数决定了可用的桶的数量：</p><ul><li>空桶太多会浪费空间；</li><li>可用空间较少则会严重影响操作的性能。<ul><li>极端情况下，假设只有一个桶，就退化成了链表，操作的时间复杂度不能保证。</li></ul></li></ul><p>对于<strong>容量</strong>，如果能够知道 HashMap 要存取的键值对数量，可以考虑预先设置合适的容量大小。需要满足：</p><ul><li>负载因子 * 容量 &gt; 元素数量，所以预先设置的容量需要大于 “预估元素数量 / 负载因子”；</li><li>是 2 的幂数；</li></ul><p>对于<strong>负载因子</strong>：</p><ul><li>如果没有特别需求，不要轻易进行更改，因为 JDK 自身的默认负载因子是非常符合通用场景的需求的；</li><li>如果确实需要调整，建议不要设置超过 0.75 的数值，因为会显著增加冲突，降低 HashMap 的性能；</li><li>如果使用太小的负载因子，按照上面的公式，可能会导致频繁的扩容，增加无谓的开销，本身访问性能也会受影响。</li></ul><p><strong>树化</strong>的原因是主要是，在元素放置过程中，如果哈希冲突频繁发生，元素都被放置到同一个桶里，会形成一个比较长的链表，而链表查找的时间复杂度是线性的，严重影响存取性能。树化对应的逻辑主要在 putVal 和 treeifyBin方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> hash)</span> </span>&#123;    <span class="hljs-keyword">int</span> n, index; Node&lt;K,V&gt; e;    <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)        resize();    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">//树化改造逻辑</span>    &#125;&#125;</code></pre><p>结合putVal 和 treeifyBin 这两个方法，可以看到，当 binCount 大于 TREEIFY_THRESHOLD 时：</p><ul><li>如果容量小于 MIN_TREEIFY_CAPACITY，只会进行简单的扩容；</li><li>如果容量大于 MIN_TREEIFY_CAPACITY ，则会进行树化改造。</li></ul><pre><code class="hljs html">static final int TREEIFY_THRESHOLD = 8;static final int UNTREEIFY_THRESHOLD = 6;</code></pre><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>java.util.Collections工具类为集合框架提供了很多有用的方法，这些方法都是静态的，在编程中可以直接调用。</p><h3 id="默认排序算法"><a href="#默认排序算法" class="headerlink" title="默认排序算法"></a>默认排序算法</h3><p>理解 Java 提供的默认排序算法的排序方式以及设计思路：需要区分是 Arrays.sort() 还是 Collections.sort()。对于小数据集，会直接进行二分插入排序。</p><ul><li>Arrays.sort() 对<strong>原始数据类型的数组</strong>，默认升序排序。如果要实现降序排列，需要借助比较器Comparator。</li><li>对于<strong>原始数据类型</strong>，目前使用的是所谓<strong>双轴快速排序</strong>（Dual-Pivot QuickSort），是一种改进的快速排序算法，早期版本是相对传统的快速排序；</li><li>Collections.sort() 对<strong>对象数据类型的List</strong> 进行排序。</li><li>对于<strong>对象数据类型</strong>，目前则是使用<strong>TimSort</strong>，思想上也是一种<strong>归并和二分插入排序</strong>结合的优化排序算法。TimSort 的思路是<strong>查找数据集中已经排好序的分区</strong>，然后<strong>合并这些分区</strong>，达到排序的目的。</li></ul><p>另外，Java 8 引入了<strong>并行排序算法</strong>（直接使用 parallelSort 方法），这是为了充分利用现代多核处理器的计算能力，底层实现基于 fork-join 框架，当处理的数据集比较小的时候，差距不明显，甚至还表现差一点；但是，当数据集增长到数万或百万以上时，提高就非常大了，具体还是取决于处理器和系统环境。</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p><strong>问：</strong>思考一个应用场景，实现一个云计算任务调度系统，可以保证 VIP 客户的任务被优先处理，可以利用哪些数据结构或者标准的集合类型呢？更进一步讲，类似场景大多是基于什么数据结构呢？</p><p><strong>答：</strong>由于任务有前后顺序关系，所以考虑使用<strong>优先级队列</strong>，如PriorityQueue、PriorityBlockingQueue。将VIP用户的优先级设置为最高，优先处理。借鉴操作系统中的调度算法，还可以设计各种公平的优先级选择算法（基于<strong>排队先后顺序、调度任务所需的时间长短</strong>进行排序），与 PriorityQueue 结合使用。</p><p><strong>消息队列</strong>可以对用户请求进行削锋，前台快速响应，后台后续进行处理操作。其他的优化有：利用分布式系统的优点，将VIP用户的请求分发到算力更高的服务器上处理。达到高可用的目的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Java 编程思想</p><p>Java 核心卷</p><p><a href="<https://time.geekbang.org/column/intro/100006701>/">极客时间 - Java精讲</a></p><p><a href="http://c.biancheng.net/java/" target="_blank" rel="noopener">C语言中文网 - Java教程</a></p><p><a href="http://www.justdojava.com/2019/09/16/java-collection-1/" target="_blank" rel="noopener">集合系列 - 初探 java 集合框架图</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Collection</tag>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库基础</title>
    <link href="/2020/07/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统基础</title>
    <link href="/2020/07/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络基础</title>
    <link href="/2020/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM基础</title>
    <link href="/2020/07/22/JVM%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/22/JVM%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程基础</title>
    <link href="/2020/07/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java OOP一些理解</title>
    <link href="/2020/07/22/Java-OOP%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <url>/2020/07/22/Java-OOP%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="面向过程编程及面向过程编程语言"><a href="#面向过程编程及面向过程编程语言" class="headerlink" title="面向过程编程及面向过程编程语言"></a>面向过程编程及面向过程编程语言</h1><p>面向过程编程<strong>以过程（或方法）作为组织代码的基本单元</strong>。它最主要的特点就是<strong>数据和方法相分离</strong>。面向过程编程语言最大的特点就是不支持丰富的<strong>面向对象编程特性</strong>，比如继承、多态、封装。</p><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>面向对象编程<strong>以类为组织代码的基本单元</strong>，一般来说，它具有以下优势。</p><ul><li>对于<strong>大规模复杂的程序的开发</strong>，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程更能应对这种复杂类型的程序开发；</li><li>面向对象编程具有更加<strong>丰富的特性</strong>，如封装、抽象、继承、多态。代码易扩展、易复用、易维护；</li></ul><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="访问权限控制"><a href="#访问权限控制" class="headerlink" title="访问权限控制"></a>访问权限控制</h3><p>封装主要关于<strong>信息隐藏、数据保护</strong>。编程语言需要提供<strong>访问权限控制</strong>这样的语法机制来支持。Java 使用访问控制符来保护对<strong>类、变量、方法和构造方法</strong>的访问。Java 支持 4 种不同的访问权限：</p><ul><li><strong>private</strong> : 访问权限限制的最窄的修饰符。同一类内可见。使用对象：变量、方法。 <strong>不能修饰类（外部类）</strong></li><li><strong>default</strong> (默认）: 通常称为“默认访问权限“或者“包访问权限”，不使用任何修饰符。同一包内可见。使用对象：类、接口、变量、方法。</li><li><strong>protected</strong> : 介于public 和 private 之间的一种访问修饰符。同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>不能修饰类（外部类）</strong>。</li><li><strong>public</strong> : 访问限制最宽的修饰符。允许跨包访问，所有类可见。使用对象：类、接口、变量、方法</li></ul><h3 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h3><p>如果对类中属性的访问不做限制，任何代码都可以访问、修改类中的属性，虽然看起来更加灵活，但是<strong>过度灵活也意味着不可控</strong>。属性可以随意被修改，修改逻辑可能散落在代码中的各个角落，影响代码的<strong>可读性、可维护性</strong>。</p><p>通过有限的方法，暴露必要的操作，能<strong>提高类的易用性</strong>。如果把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就要对业务细节有足够的了解。这对于调用者来说也是一种负担。如果将属性<strong>封装</strong>起来，只暴露必要的<strong>方法</strong>给调用者使用，调用者就不需要了解太多的业务细节，可以降低使用成本，减少用错的概率。</p><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p><strong>抽象关注的是如何隐藏方法的具体实现</strong>，让调用者只需要关心方法提供了哪些功能，不需要知道实现细节。</p><p>面向对象编程常常借助编程语言提供的<strong>接口</strong>或者<strong>抽象类</strong>这两种语法机制实现抽象这一特性。</p><p><strong>抽象有时候会被排除在面向对象特性之外</strong>。因为抽象是一个非常通用的设计思想，不单单用在面向对象编程中，也可以用来指导架构设计等。这个特性也并不需要编程语言提供特殊的语法机制来支持，只需要提供“函数”这一语法机制，就可以实现抽象特性。</p><h3 id="抽象的意义"><a href="#抽象的意义" class="headerlink" title="抽象的意义"></a>抽象的意义</h3><p>面对复杂的系统，人脑能承受的信息是有限的，所以要忽略一些非关键的实现细节。抽象作为一种<strong>只关注功能点不关注实现</strong>的设计思路，可以过滤掉非必要的信息。</p><p>抽象作为一个非常宽泛的<strong>设计思想</strong>，在代码设计中起到重要的指导作用。很多设计原则都体现了抽象这种设计思想，比如<strong>基于接口而非实现编程</strong>、<strong>开闭原则</strong>（对扩展开放、对修改关闭）、<strong>代码解耦</strong>（降低代码的耦合性）等。</p><p>换一个角度考虑，定义类的方法的时候，不要暴露太多的实现细节，以保证在修改方法的实现的时候，不用再修改其定义。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承用来表示<strong>类之间的 is-a 关系</strong>，比如猫是一种哺乳动物。继承可以分为两种模式，<strong>单继承和多继承</strong>。</p><p>Java 使用 <strong>extends</strong> 关键字来实现继承，C++ 使用冒号（class B : public A），Python 使用 paraentheses()。有些编程语言只支持单继承，不支持多重继承，比如 Java。有些编程语言两种方式都支持，比如 C++、Python。</p><h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><p>多重继承存在钻石问题，即菱形继承。假设类 B 和类 C 继承自类 A，都重写了类 A 中的同一个方法，而类 D 同时继承了类 B 和类 C，那么此时类 D 会继承 B、C 的方法，那对于 B、C 重写的 A 中的方法，类 D 继承哪一个就无法确定。</p><p>Java支持多接口实现，因为接口中的方法是抽象的，即便一个类实现了多个接口，且这些接口中存在同名方法，但在实现接口的时候，这个同名方法需要由这个实现类自己来实现，所以避免了二义性的问题。</p><h3 id="继承的意义"><a href="#继承的意义" class="headerlink" title="继承的意义"></a>继承的意义</h3><p>继承最大的优点是<strong>代码复用</strong>。假如两个类有一些相同的属性和方法，就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。两个子类可以重用父类中的代码。不过，通过其他方式，比如利用<strong>组合关系</strong>而不是<strong>继承关系</strong>，也可以达到代码复用的目的。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是同一个行为具有多个不同表现形式或形态的能力，同一个接口，使用不同的实例而执行不同操作。<strong>子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现</strong>。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="继承-方法重写"><a href="#继承-方法重写" class="headerlink" title="继承 + 方法重写"></a>继承 + 方法重写</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicArray</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> capacity = DEFAULT_CAPACITY;  <span class="hljs-keyword">protected</span> Integer[] elements = <span class="hljs-keyword">new</span> Integer[DEFAULT_CAPACITY];    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.size; &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123; <span class="hljs-keyword">return</span> elements[index];&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Integer e)</span> </span>&#123;    ensureCapacity();    elements[size++] = e;  &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacity</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 如果数组满了就扩容...</span>  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortedDynamicArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DynamicArray</span> </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Integer e)</span> </span>&#123;    ensureCapacity();    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">for</span> (i = size-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; --i) &#123; <span class="hljs-comment">//保证数组中的数据有序</span>      <span class="hljs-keyword">if</span> (elements[i] &gt; e) &#123;        elements[i+<span class="hljs-number">1</span>] = elements[i];      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">break</span>;      &#125;    &#125;    elements[i+<span class="hljs-number">1</span>] = e;    ++size;  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(DynamicArray dynamicArray)</span> </span>&#123;    dynamicArray.add(<span class="hljs-number">5</span>);    dynamicArray.add(<span class="hljs-number">1</span>);    dynamicArray.add(<span class="hljs-number">3</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dynamicArray.size(); ++i) &#123;      System.out.println(dynamicArray.get(i));    &#125;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;    DynamicArray dynamicArray = <span class="hljs-keyword">new</span> SortedDynamicArray();    test(dynamicArray); <span class="hljs-comment">// 打印结果：1、3、5</span>  &#125;&#125;</code></pre><p>多态需要<strong>编程语言提供特殊的语法机制</strong>来实现。在上面的例子中，用到了三个语法机制来实现多态。</p><ul><li><strong>父类对象可以引用子类对象</strong>。可以将 SortedDynamicArray 传递给 DynamicArray。</li><li><strong>继承</strong>。SortedDynamicArray 继承了 DynamicArray，才能将 SortedDyamicArray 传递给 DynamicArray；</li><li><strong>子类可以重写（override）父类中的方法</strong>。SortedDyamicArray 重写了 DynamicArray 中的 add() 方法。</li></ul><p>这三种语法机制配合在一起，实现了在 test() 方法中，子类 SortedDyamicArray 替换父类 DynamicArray，执行子类 SortedDyamicArray 的 add() 方法，实现了多态特性。</p><p>对于多态的实现方式，除了利用<strong>继承加方法重写</strong>这种方式外，还有其他两种比较常见的的实现方式，一个是利用<strong>接口类语法</strong>，另一个是利用 <strong>duck-typing 语法</strong>。不过，并不是每种编程语言都支持接口类或者 duck-typing 这两种语法机制，比如 C++ 不支持接口类语法，而 duck-typing 只有一些动态语言才支持，比如 Python、JavaScript 等。</p><h4 id="接口类语法"><a href="#接口类语法" class="headerlink" title="接口类语法"></a>接口类语法</h4><p>Iterator 是一个接口类，定义了一个可以遍历集合数据的迭代器。Array 和 LinkedList 都实现了接口类 Iterator。通过<strong>传递不同类型的实现类（Array、LinkedList）到 print(Iterator iterator) 函数中，支持动态的调用不同的 next()、hasNext() 实现</strong>。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span> </span>&#123;  <span class="hljs-function">String <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;  <span class="hljs-function">String <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;  <span class="hljs-function">String <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Array</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span> </span>&#123;  <span class="hljs-keyword">private</span> String[] data;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-comment">// 省略其它方法...</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span> </span>&#123;  <span class="hljs-keyword">private</span> LinkedListNode head;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-comment">// 省略其它方法... </span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Iterator iterator)</span> </span>&#123;    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;      System.out.println(iterator.next());    &#125;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Iterator arrayIterator = <span class="hljs-keyword">new</span> Array();    print(arrayIterator);        Iterator linkedListIterator = <span class="hljs-keyword">new</span> LinkedList();    print(linkedListIterator);  &#125;&#125;</code></pre><p>Java 通过<strong>继承实现多态特性</strong>，必须要求两个<strong>类之间有继承关系</strong>。通过<strong>接口实现多态特性</strong>，<strong>类必须实现对应的接口</strong>。</p><h3 id="多态的意义"><a href="#多态的意义" class="headerlink" title="多态的意义"></a>多态的意义</h3><p>多态特性能<strong>提高代码的可扩展性和复用性</strong>。利用多态，一个 print() 函数可以实现遍历打印不同类型集合的数据。当需要再增加一种要遍历打印的类型的时候，比如 HashMap，只需让 HashMap 实现 Iterator 接口，重新实现自己的 hasNext()、next() 等方法就可以了，不需要改动 print() 函数的代码，提高了代码的可扩展性。</p><p>多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等。</p><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="违反OOP风格的代码设计"><a href="#违反OOP风格的代码设计" class="headerlink" title="违反OOP风格的代码设计"></a>违反OOP风格的代码设计</h2><h3 id="滥用-getter、setter-方法"><a href="#滥用-getter、setter-方法" class="headerlink" title="滥用 getter、setter 方法"></a>滥用 getter、setter 方法</h3><ul><li>设计实现类的时候，除非真的需要，否则尽量不要给属性定义 setter 方法；</li><li>尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器，也要防范集合内部数据被修改的风险。</li></ul><h3 id="Constants-类、Utils-类的设计问题"><a href="#Constants-类、Utils-类的设计问题" class="headerlink" title="Constants 类、Utils 类的设计问题"></a>Constants 类、Utils 类的设计问题</h3><ul><li>对于这两种类的设计，尽量能做到职责单一，定义一些细化的小类，比如 RedisConstants、FileUtils，而不是定义一个大而全的 Constants 类、Utils 类；</li><li>如果能将这些类中的属性和方法，划分归并到其他业务类中，能极大地提高类的内聚性和代码的可复用性。</li></ul><h2 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h2><p>面向对象编程中，抽象类和接口是两个经常使用的语法概念，是面向对象四大特性以及很多设计模式、设计思想、设计原则编程实现的基础，例如：</p><ul><li>使用<strong>接口来实现面向对象的抽象特性、多态特性</strong>和<strong>基于接口而非实现</strong>的设计原则；</li><li>使用<strong>抽象类来实现面向对象的继承特性和模板设计模式</strong>等。</li></ul><p>继承关系是 is-a 的关系，接口表示 has-a 关系，表示<strong>具有某些功能</strong>。接口，有一个更形象的叫法：<strong>协议</strong>。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul><li>抽象类<strong>不允许被实例化</strong>，只能被<strong>继承</strong>；</li><li>抽象类可以包含属性和方法。抽象类中的成员变量可以是各种类型的，接口中的成员变量只能是 <strong>public static final</strong> 类型的；<ul><li>抽象类中的方法可以有方法体；</li><li>也可以不包含方法体。不包含代码实现的方法叫作<strong>抽象方法</strong>；</li></ul></li><li>子类继承抽象类，<strong>必须实现抽象类中的所有抽象方法</strong>。</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li><p>接口是隐式抽象的，声明接口时不必使用<strong>abstract</strong>关键字；</p></li><li><p>接口没有构造方法，接口不能实例化；</p></li><li><p>接口支持多继承；</p></li><li><p>接口中<strong>没有成员变量</strong>，<strong>只有方法声明，没有方法实现</strong>，实现接口的类<strong>必须实现接口中的所有方法</strong>；</p><ul><li>接口不包含任何<strong>非常量成员</strong>，任何 field 都是隐含着 public static final 的意义；</li></ul></li><li><p>接口没有<strong>非静态方法实现</strong>，要么是隐式的抽象方法（声明时不需要<strong>abstract</strong>关键字），要么是静态方法；</p><ul><li>JDK 1.8版本及以上，接口里可以有静态方法和方法体了，只有静态方法可以在接口中实现</li></ul></li></ul><h3 id="抽象类-OR-接口"><a href="#抽象类-OR-接口" class="headerlink" title="抽象类 OR 接口"></a>抽象类 OR 接口</h3><ul><li><strong>抽象类是一种自下而上的设计思路</strong>，先有子类的代码重复，然后抽象成上层的父类（抽象类）；</li><li>如果表示 <strong>is-a</strong> 的关系，为了解决<strong>代码复用</strong>的问题，使用<strong>抽象类</strong>；</li><li>接口是一种<strong>自上而下的设计思路</strong>，一般是先设计接口，再考虑具体的实现；</li><li>如果表示 <strong>has-a</strong> 关系，为了解决<strong>抽象</strong>而非代码复用的问题，使用<strong>接口</strong>；</li></ul><h2 id="基于接口而非实现编程"><a href="#基于接口而非实现编程" class="headerlink" title="基于接口而非实现编程"></a>基于接口而非实现编程</h2><p>“基于接口而非实现编程”，也可以表达为“<strong>基于抽象而非实现编程</strong>”。软件开发时一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。</p><p>本质上看，<strong>“接口”是一组“协议”或者“约定”，是功能提供者给使用者的一个“功能列表”</strong>。“接口”在不同的应用场景下会有不同的解读，比如服务端与客户端之间的“接口”，类库提供的“接口”，甚至是一组通信的协议都可以叫作“接口”。落实到具体的编码，“基于接口而非实现编程”原则中的“接口”，可以理解为编程语言中的<strong>接口或者抽象类</strong>。</p><p>这条原则能有效地提高代码质量。可以<strong>将接口和实现相分离，封装不稳定的实现，暴露稳定的接口</strong>。上游系统面向接口而非实现编程，<strong>不依赖不稳定的实现细节</strong>，当实现发生变化时，上游系统的代码基本上不需要改动，以此<strong>降低耦合性，提高扩展性</strong>。</p><h3 id="应用原则"><a href="#应用原则" class="headerlink" title="应用原则"></a>应用原则</h3><p>编写代码时遵从基于接口而非实现编程的原则：</p><ul><li><strong>函数的命名不能暴露任何实现细节</strong>；</li><li><strong>封装具体的实现细节</strong>；</li><li><strong>为实现类定义抽象的接口</strong>。具体的实现类依赖统一的接口定义，使用者依赖接口而非具体的实现类来编程。</li></ul><p>越不稳定的系统，越要在代码的扩展性、维护性上下功夫。不过，如果业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，没有必要为其设计接口，也没有必要基于接口编程，那么直接使用实现类就可以了。</p><h2 id="组合优于继承"><a href="#组合优于继承" class="headerlink" title="组合优于继承"></a>组合优于继承</h2><h3 id="继承的缺点"><a href="#继承的缺点" class="headerlink" title="继承的缺点"></a>继承的缺点</h3><p>继承层次越来越深，会使得继承关系会越来越复杂，引发以下问题：</p><ul><li>代码的可读性变差。因为要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码，一直追溯到最顶层父类的代码；</li><li>破坏了类的封装特性，降低可维护性。父类的实现细节暴露给子类，子类的实现依赖父类的实现，两者高度耦合。父类代码的修改会影响所有子类的逻辑。</li></ul><h3 id="组合的优势"><a href="#组合的优势" class="headerlink" title="组合的优势"></a>组合的优势</h3><p>可以利用组合（composition）、接口、委托（delegation）三个技术，解决继承存在的问题。</p><p>注：<strong>组合</strong>，java代码复用的一种方法。<strong>使用多个已有的对象组合为一个功能更加复杂强大的新对象</strong>。体现的是<strong>整体与部分、拥有的关系</strong>。因为在对象之间，各自的内部细节是不可见的，所以也说这种方式的代码复用是黑盒的。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyable</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span>；</span><span class="hljs-function">&#125;</span><span class="hljs-function"><span class="hljs-keyword">public</span> class FlyAbility implements Flyable </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//... &#125;</span>&#125;<span class="hljs-comment">//省略Tweetable/TweetAbility/EggLayable/EggLayAbility</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ostrich</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Tweetable</span>, <span class="hljs-title">EggLayable</span> </span>&#123;<span class="hljs-comment">//鸵鸟</span>  <span class="hljs-keyword">private</span> TweetAbility tweetAbility = <span class="hljs-keyword">new</span> TweetAbility(); <span class="hljs-comment">//组合</span>  <span class="hljs-keyword">private</span> EggLayAbility eggLayAbility = <span class="hljs-keyword">new</span> EggLayAbility(); <span class="hljs-comment">//组合</span>  <span class="hljs-comment">//... 省略其他属性和方法...</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tweet</span><span class="hljs-params">()</span> </span>&#123;    tweetAbility.tweet(); <span class="hljs-comment">// 委托</span>  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">layEgg</span><span class="hljs-params">()</span> </span>&#123;    eggLayAbility.layEgg(); <span class="hljs-comment">// 委托</span>  &#125;&#125;</code></pre><p>继承主要有三个作用：<strong>表示 is-a 关系，支持多态特性，代码复用</strong>。这三个作用都可以通过其他技术来达成。</p><ul><li>is-a 关系可以通过<strong>组合</strong>和<strong>接口的 has-a</strong> 关系来替代；</li><li>多态特性可以利用接口来实现；</li><li>代码复用可以通过组合和委托来实现。</li></ul><p>理论上讲，通过组合、接口、委托三种技术，可以替代继承。在项目中可以不用或者少用继承关系，特别是一些复杂的继承关系。</p><h3 id="组合-OR-继承"><a href="#组合-OR-继承" class="headerlink" title="组合 OR 继承"></a>组合 OR 继承</h3><p>继承改写成组合意味着要做更细粒度的类的拆分，定义更多的类和接口。类和接口的增多会增加代码的复杂程度和维护成本。实际的项目开发要根据具体的情况，具体地选择该用继承还是组合。</p><p>如果类之间的继承结构稳定，继承层次比较浅，继承关系不复杂，可以使用继承。反之，就尽量使用组合。</p><p>一些设计模式会固定使用继承或者组合。装饰者模式、策略模式、组合模式等都使用了组合关系，而模板模式使用了继承关系。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>动态规划专题</title>
    <link href="/2020/07/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/"/>
    <url>/2020/07/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法专题</title>
    <link href="/2020/07/22/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/"/>
    <url>/2020/07/22/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>字符串专题</title>
    <link href="/2020/07/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%93%E9%A2%98/"/>
    <url>/2020/07/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>哈希表专题</title>
    <link href="/2020/07/22/%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%93%E9%A2%98/"/>
    <url>/2020/07/22/%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>栈和队列专题</title>
    <link href="/2020/07/22/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%98/"/>
    <url>/2020/07/22/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树专题</title>
    <link href="/2020/07/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%98/"/>
    <url>/2020/07/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>链表专题</title>
    <link href="/2020/07/22/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/"/>
    <url>/2020/07/22/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python Tips</title>
    <link href="/2020/07/21/Python-Tips/"/>
    <url>/2020/07/21/Python-Tips/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
