<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java 常用集合</title>
    <link href="/2020/07/22/Java%20%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/"/>
    <url>/2020/07/22/Java%20%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p>文章主要归纳介绍 Java 的集合框架与设计结构。包括 Java 提供的主要集合类型（Collections 和 Map）及其对应的数据结构、算法，并考虑不同场景下的具体技术选择。</p><a id="more"></a><h2 id="Java-集合框架设计结构"><a href="#Java-集合框架设计结构" class="headerlink" title="Java 集合框架设计结构"></a>Java 集合框架设计结构</h2><p>Java中提供了丰富的集合接口和类，它们来自于java.util包。Java集合类型分为：Collection和Map，Collection子接口有：Set、Queue和List等接口。每一种集合接口定义和描述了一种数据结构。</p><p><strong>Collection 接口</strong>是所有集合的根，然后扩展开提供了三大类集合，分别是：</p><ul><li><strong>List</strong>，有序集合，提供方便的访问、插入、删除等操作；</li><li><strong>Set</strong>，不允许重复元素，不存在两个对象 equals 返回 true。在需要保证元素唯一性的场景下使用较多；</li><li><strong>Queue/Deque</strong>，除了集合的基本功能，它还支持先入先出FIFO或后入先出LIFO等约束行为。并发包中有BlockingQueue。</li></ul><p><strong>Map</strong>允许按照某个键来访问元素。Map集合由两个集合构成：键集合，值集合。键集合是Set类型，不能有重复的元素。值集合是Collection类型，可以有重复的元素。</p><p>每种集合的通用逻辑，都被抽象到相应的抽象类之中，比如 AbstractList 就集中了各种 List 操作的通用部分。这些集合不是完全孤立的，例如LinkedList 实现了 List 和 Deque。</p><p><img src="java_collection.png" srcset="/img/loading.gif" alt=""></p><p><img src="java_map.png" srcset="/img/loading.gif" alt=""></p><p><strong>注：</strong></p><ul><li>Iterator通用迭代器、ListIterator针对 List 特化的迭代器</li><li>Comparator比较器、Comparable 排序接口</li><li>Collections常用算法类、Arrays静态数组的排序、查找算法</li></ul><h2 id="Java-主要集合类型"><a href="#Java-主要集合类型" class="headerlink" title="Java 主要集合类型"></a>Java 主要集合类型</h2><p>重点关注常用的实现类，掌握对应的数据结构、算法，能够根据不同的场景，进行具体的技术选择。</p><p><img src="java_common_collection.png" srcset="/img/loading.gif" alt=""></p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Vector、ArrayList 和 LinkedList 实现了 List，是<strong>有序集合</strong>。都提供按照位置进行定位、添加或者删除的操作，提供迭代器以遍历其内容等。但因为具体的设计区别，在行为、性能、线程安全等方面，表现又有很大不同。</p><ul><li>Vector 是 Java 早期提供的<strong>线程安全的动态数组</strong>，内部使用<strong>对象数组</strong>来保存数据。如果不需要线程安全，并不建议选择，毕竟同步有额外开销。可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据；</li><li>ArrayList 的应用更加广泛，使用<strong>动态数组</strong>实现，<strong>不是线程安全</strong>的，所以性能要好很多。ArrayList 也可以根据需要调整容量，两者的调整逻辑有所区别，<strong>Vector 在扩容时会提高 1 倍，而 ArrayList 增加 50%；</strong></li><li>LinkedList 是 Java 提供的<strong>双向链表</strong>，不需要像上面两种那样调整容量，但是因为存在额外的前驱和后继节点指针，所以占用的内存比 ArrayList 多一些。任意位置的插入删除很方便，不支持随机取值，只能从一端开始遍历，直到找到查询的对象。它<strong>不是线程安全的。</strong></li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>HashSet、LinkedHashSet 和 TreeSet 实现了Set。特点是<strong>元素不重复</strong>，<strong>存取无序</strong>。</p><ul><li>HashSet 以 HashMap 为基础实现。利用<strong>哈希算法</strong>，理想情况下添加、删除、包含等操作的<strong>时间复杂度为常数</strong>，它不保证有序。</li><li>LinkedHashSet 内部构建了一个记录插入顺序的双向链表，因此提供了<strong>按照插入顺序进行遍历</strong>的能力，也保证常数时间的包含、添加、删除等操作，这些<strong>操作性能略低于 HashSet</strong>，因为需要维护链表的开销；</li><li>TreeSet 默认利用 TreeMap 实现。支持自然顺序访问，包含、添加、删除、等操作相对低效（log(n) ）；</li></ul><p>在遍历元素时，HashSet 性能受自身容量影响，所以初始化时，除非有必要，不然不要将其背后的 HashMap 容量设置过大。而对于 LinkedHashSet，由于其内部链表提供的方便，所以遍历性能只和元素多少有关系。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Hashtable、HashMap、TreeMap 是最常见的 Map 的实现，<strong>以键值对的形式存储和操作数据的集合类型。</strong></p><ul><li>Hashtable 是早期 Java 类库提供的一个哈希表实现，本身<strong>是同步的</strong>，<strong>不支持 null 键和值</strong>，由于同步导致的性能开销，所以已经<strong>很少被推荐使用</strong>；</li><li>HashMap 应用更加广泛，利用哈希表实现。<strong>HashMap 不是同步的，支持 null 键和值等</strong>。通常情况下HashMap 的 put 或 get 操作的时间复杂度为常数。所以它是<strong>绝大部分利用键值对存取场景的首选</strong>，比如，实现一个用户 ID 和用户信息对应的运行时存储结构；<ul><li>大部分使用 Map 的场景，通常就是<strong>放入、访问或者删除</strong>，对顺序没有特别要求，HashMap 在这种情况下基本是最好的选择。</li></ul></li><li>LinkedHashMap 继承于HashMap，是基于HashMap和双向链表来实现的。LinkedHashMap 是有序的，可分为插入顺序和访问顺序。如果是访问顺序，那put和get操作已存在的Entry时，都会<strong>把Entry移动到双向链表的表尾(</strong>其实是先删除再插入)，存取数据时和 HashMap 一样，使用 Entry[] 的方式，双向链表只是为了保证顺序。LinkedHashMap <strong>不是线程安全</strong>的；<ul><li>这种特点适用于一些特定应用场景，例如：构建一个空间占用敏感的资源池，可以自动将最不常被访问的对象释放。那么，表满时需要删除时候就是头部元素。</li></ul></li><li>TreeMap 是基于<strong>红黑树</strong>实现的一种按序访问的 Map，TreeMap能够把它保存的记录根据键进行排序，默认是按键值的升序排序，也可以指定排序的比较器，具体顺序可以由指定的 <strong>Comparator</strong> 决定。用 Iterator 遍历时，得到的记录是排过序的。它的 get、put、remove 操作的时间复杂度是 O(log(n))，所以TreeMap实际使用的比较少。<ul><li>TreeMap 和 LinkedHashMap 都可以保证某种顺序，但二者还是不同的。TreeMap 的整体顺序由键的顺序关系决定，即通过 Comparator 或 Comparable（自然顺序）决定。</li></ul></li></ul><h4 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h4><p>HashMap 的性能表现非常依赖于哈希值的有效性，需要掌握相关内容。</p><h5 id="Java中equals和-的区别"><a href="#Java中equals和-的区别" class="headerlink" title="Java中equals和==的区别"></a>Java中equals和==的区别</h5><ul><li>== 的作用：<ul><li>基本类型：比较的就是值是否相同；</li><li>引用类型：比较的就是地址值是否相同</li></ul></li><li>equals() 的作用：<ul><li>引用类型：默认情况下，比较的是地址值。但是一般来说，意义不大。所以，一些类库重写了这个方法，如String、Integer、Date。这些类当中 equals 有其自身的实现，一般是用来比较对象的成员变量值是否相同，而不再是比较类在堆内存中的存放地址了。</li></ul></li></ul><h5 id="hashCode（）与-equals（）的相关规定"><a href="#hashCode（）与-equals（）的相关规定" class="headerlink" title="hashCode（）与 equals（）的相关规定"></a>hashCode（）与 equals（）的相关规定</h5><ul><li>如果两个对象相等（equals 相等），那么 hashCode 一定相等；</li><li>两个对象相等，对两个对象分别调用 equals 方法都返回 true；</li><li>两个对象有相同的哈希值(hash code)，它们不一定相等；</li><li>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖，所以<strong>重写了 equals 也要重写 hashCode；</strong></li><li>equals 有对称、反射、传递等特性。</li></ul><h4 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h4><p>掌握HashMap 设计与实现的基本原理与方法，对深入理解集合和数据结构有一些帮助。</p><ul><li>HashMap 内部实现基本点分析;</li><li>容量（capacity）和负载系数（load factor）;</li><li>树化 。</li></ul><p>HashMap 内部的结构如下图，它可以看作是<strong>数组和链表结合组成</strong>的复合结构，数组被分为一个个<strong>桶</strong>，通过<strong>哈希值决定键值对在这个数组的寻址</strong>；<strong>哈希值相同的键值对，则以链表形式存储</strong>。需要注意的是，如果链表大小超过阈值（TREEIFY_THRESHOLD, 8），链表就会被改造为树形结构。</p><p><img src="hash_buckets.png" srcset="/img/loading.gif" alt=""></p><h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h5><p>putVal 方法逻辑比较集中，从初始化、扩容到树化都和它有关，阅读源码时需要多加关注。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><span class="hljs-function"><span class="hljs-params">               <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;    HashMap.Node&lt;K,V&gt;[] tab; HashMap.Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)        n = (tab = resize()).length;    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span>            treeifyBin(tab, hash);    &#125;    <span class="hljs-keyword">if</span> (++size &gt; threshold)        resize();&#125;</code></pre><ul><li><p>如果表格是 null，resize 方法会初始化它；</p></li><li><p>resize 方法兼顾两个职责，创建初始存储表格，或者在容量不满足需求的时候，进行扩容resize；</p></li><li><p>在放置新的键值对的过程中，如果++size &gt; threshold，就会发生扩容</p></li><li><p>具体键值对在哈希表中的位置（数组 index）取决于下面的位运算：</p><pre><code class="hljs java">i = (n - <span class="hljs-number">1</span>) &amp; hash</code></pre></li></ul><p>将高位数据移位到低位进行异或运算的原因是：有些数据计算出的哈希值差异主要在高位，而 HashMap 里的哈希寻址是忽略容量以上的高位的，这种处理可以有效避免类似情况下的哈希碰撞。</p><pre><code class="hljs processing"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> hash(<span class="hljs-keyword">Object</span> kye) &#123;    <span class="hljs-built_in">int</span> h;    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">key</span> == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = <span class="hljs-built_in">key</span>.hashCode()) ^ (h &gt;&gt;&gt;<span class="hljs-number">16</span>;&#125;</code></pre><h5 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h5><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;    Node&lt;K,V&gt;[] oldTab = table;    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;    <span class="hljs-keyword">int</span> oldThr = threshold;    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;            threshold = Integer.MAX_VALUE;            <span class="hljs-keyword">return</span> oldTab;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span>        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span>            newCap = oldThr;        <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span>            newCap = DEFAULT_INITIAL_CAPACITY;            newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);        &#125;        <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?                      (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);        &#125;        threshold = newThr;        <span class="hljs-meta">@SuppressWarnings</span>(&#123;<span class="hljs-string">"rawtypes"</span>,<span class="hljs-string">"unchecked"</span>&#125;)            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];        table = newTab;        <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// ....</span>    &#125;        <span class="hljs-keyword">return</span> newTab;</code></pre><ul><li>不考虑极端情况，容量理论最大极限由 MAXIMUM_CAPACITY 指定，数值为 1&lt;&lt;30，也就是 2 的 30 次方；</li><li>门限值 = 负载因子 x 容量，如果构建 HashMap 的时候没有指定，那么依据相应的默认常量值；</li><li>门限通常以倍数进行调整 （newThr = oldThr &lt;&lt; 1），当元素个数超过门限大小时，则调整 Map 大小；</li><li>扩容后，需要将老的数组中的元素重新放置到新的数组，这是扩容的一个主要开销来源。</li></ul><h5 id="容量、负载因子和树化"><a href="#容量、负载因子和树化" class="headerlink" title="容量、负载因子和树化"></a>容量、负载因子和树化</h5><p>容量和负载系数决定了可用的桶的数量：</p><ul><li>空桶太多会浪费空间；</li><li>可用空间较少则会严重影响操作的性能。<ul><li>极端情况下，假设只有一个桶，就退化成了链表，操作的时间复杂度不能保证。</li></ul></li></ul><p>对于<strong>容量</strong>，如果能够知道 HashMap 要存取的键值对数量，可以考虑预先设置合适的容量大小。需要满足：</p><ul><li>负载因子 * 容量 &gt; 元素数量，所以预先设置的容量需要大于 “预估元素数量 / 负载因子”；</li><li>是 2 的幂数；</li></ul><p>对于<strong>负载因子</strong>：</p><ul><li>如果没有特别需求，不要轻易进行更改，因为 JDK 自身的默认负载因子是非常符合通用场景的需求的；</li><li>如果确实需要调整，建议不要设置超过 0.75 的数值，因为会显著增加冲突，降低 HashMap 的性能；</li><li>如果使用太小的负载因子，按照上面的公式，可能会导致频繁的扩容，增加无谓的开销，本身访问性能也会受影响。</li></ul><p><strong>树化</strong>的原因是主要是，在元素放置过程中，如果哈希冲突频繁发生，元素都被放置到同一个桶里，会形成一个比较长的链表，而链表查找的时间复杂度是线性的，严重影响存取性能。树化对应的逻辑主要在 putVal 和 treeifyBin方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> hash)</span> </span>&#123;    <span class="hljs-keyword">int</span> n, index; Node&lt;K,V&gt; e;    <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)        resize();    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">//树化改造逻辑</span>    &#125;&#125;</code></pre><p>结合putVal 和 treeifyBin 这两个方法，可以看到，当 binCount 大于 TREEIFY_THRESHOLD 时：</p><ul><li>如果容量小于 MIN_TREEIFY_CAPACITY，只会进行简单的扩容；</li><li>如果容量大于 MIN_TREEIFY_CAPACITY ，则会进行树化改造。</li></ul><pre><code class="hljs html">static final int TREEIFY_THRESHOLD = 8;static final int UNTREEIFY_THRESHOLD = 6;</code></pre><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>java.util.Collections工具类为集合框架提供了很多有用的方法，这些方法都是静态的，在编程中可以直接调用。</p><h3 id="默认排序算法"><a href="#默认排序算法" class="headerlink" title="默认排序算法"></a>默认排序算法</h3><p>理解 Java 提供的默认排序算法的排序方式以及设计思路：需要区分是 Arrays.sort() 还是 Collections.sort()。对于小数据集，会直接进行二分插入排序。</p><ul><li>Arrays.sort() 对<strong>原始数据类型的数组</strong>，默认升序排序。如果要实现降序排列，需要借助比较器Comparator。</li><li>对于<strong>原始数据类型</strong>，目前使用的是所谓<strong>双轴快速排序</strong>（Dual-Pivot QuickSort），是一种改进的快速排序算法，早期版本是相对传统的快速排序；</li><li>Collections.sort() 对<strong>对象数据类型的List</strong> 进行排序。</li><li>对于<strong>对象数据类型</strong>，目前则是使用<strong>TimSort</strong>，思想上也是一种<strong>归并和二分插入排序</strong>结合的优化排序算法。TimSort 的思路是<strong>查找数据集中已经排好序的分区</strong>，然后<strong>合并这些分区</strong>，达到排序的目的。</li></ul><p>另外，Java 8 引入了<strong>并行排序算法</strong>（直接使用 parallelSort 方法），这是为了充分利用现代多核处理器的计算能力，底层实现基于 fork-join 框架，当处理的数据集比较小的时候，差距不明显，甚至还表现差一点；但是，当数据集增长到数万或百万以上时，提高就非常大了，具体还是取决于处理器和系统环境。</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p><strong>问：</strong>思考一个应用场景，实现一个云计算任务调度系统，可以保证 VIP 客户的任务被优先处理，可以利用哪些数据结构或者标准的集合类型呢？更进一步讲，类似场景大多是基于什么数据结构呢？</p><p><strong>答：</strong>由于任务有前后顺序关系，所以考虑使用<strong>优先级队列</strong>，如PriorityQueue、PriorityBlockingQueue。将VIP用户的优先级设置为最高，优先处理。借鉴操作系统中的调度算法，还可以设计各种公平的优先级选择算法（基于<strong>排队先后顺序、调度任务所需的时间长短</strong>进行排序），与 PriorityQueue 结合使用。</p><p><strong>消息队列</strong>可以对用户请求进行削锋，前台快速响应，后台后续进行处理操作。其他的优化有：利用分布式系统的优点，将VIP用户的请求分发到算力更高的服务器上处理。达到高可用的目的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Java 编程思想</p><p>Java 核心卷</p><p><a href="<https://time.geekbang.org/column/intro/100006701>/">极客时间 - Java精讲</a></p><p><a href="http://c.biancheng.net/java/" target="_blank" rel="noopener">C语言中文网 - Java教程</a></p><p><a href="http://www.justdojava.com/2019/09/16/java-collection-1/" target="_blank" rel="noopener">集合系列 - 初探 java 集合框架图</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Collection</tag>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库基础</title>
    <link href="/2020/07/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统基础</title>
    <link href="/2020/07/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络基础</title>
    <link href="/2020/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM基础</title>
    <link href="/2020/07/22/JVM%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/22/JVM%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 多线程基础</title>
    <link href="/2020/07/22/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/22/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>软件并发已经成为现代软件开发的基础能力，而 Java 精心设计的高效并发机制，是构建大规模应用的基础之一。本文介绍 Java 并发编程基础知识。主要内容为 进程与线程概述、线程生命周期、Java 中如何实现线程、synchronized与锁、volatile、线程池、Java并发包、CAS与原子操作。</p><a id="more"></a><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是<strong>应用程序在内存中分配的空间，也就是正在运行的程序</strong>，各个进程之间互不干扰。同时进程保存着程序每一个时刻运行的状态。进程的出现，使操作系统的性能大大提升，但是如果一个进程在一段时间只执行一个任务，那么当进程有多个子任务时，只能逐个执行这些子任务，效率较低。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>为了提高 CPU 和 IO 设备的综合利用率，线程个概念被提出并应用。线程是一个比进程更小的执行单位，一个进程包含了多个线程，同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，而<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>是私有的，每个线程负责一个单独的子任务。</p><h3 id="进程和线程的异同"><a href="#进程和线程的异同" class="headerlink" title="进程和线程的异同"></a>进程和线程的异同</h3><ul><li><p><strong>进程是操作系统进行资源分配的基本单位</strong>，<strong>线程是系统调度的最小单元</strong>；</p></li><li><p>线程是程序执行的最小单位，更加轻量级，线程间的切换和调度的成本远远小于进程。多线程可以在多核 CPU 上同时运行，减少了线程上下文切换的开销；</p></li><li><p>多线程并发编程是高并发系统的基础，好多线程机制可以提高系统整体的并发能力及性能；</p></li><li><p>一个进程可以包含多个线程，线程作为任务的真正执行者，有<strong>自己的栈、寄存器、本地存储（Thread Local）</strong>等，但是会<strong>和进程内其他线程共享文件描述符、虚拟地址空间等</strong>；</p></li><li><p>Java 中进程的内存占用如下图所示</p><p><img src="JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86.png" srcset="/img/loading.gif" alt=""></p></li></ul><h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>Java 5 以后，线程生命周期的不同状态被明确定义在其公共内部枚举类型 java.lang.Thread.State 中，分别是：</p><ul><li><p>新建（<strong>NEW</strong>），表示线程被创建出来还<strong>没真正启动</strong>的状态，可以认为它是个 Java 内部状态；</p></li><li><p>就绪（<strong>RUNNABLE</strong>），表示该线程已经在 JVM 中执行，当然由于执行需要计算资源，它<strong>可能是正在运行</strong>，也可能还在<strong>等待系统分配给它 CPU 片段，在就绪队列里面排队</strong>。在其他一些分析中，会额外区分一种状态 <strong>RUNNING</strong>，但是从 Java API 的角度，并不能表示出来；</p></li><li><p>阻塞（<strong>BLOCKED</strong>），这个状态和同步非常相关，<strong>阻塞表示线程在等待 Monitor lock</strong>。比如，线程试图<strong>通过 synchronized 去获取某个锁</strong>，但是其他线程已经独占了，那么当前线程就会处于阻塞状态；</p></li><li><p>等待（<strong>WAITING</strong>），表示正在<strong>等待其他线程采取某些操作</strong>。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（<strong>wait</strong>），另外的生产者线程去准备任务数据，然后通过类似 <strong>notify</strong> 等动作，通知消费线程可以继续工作了。<strong>Thread.join() 也会令线程进入等待状态</strong>。计时等待（<strong>TIMED_WAIT</strong>），其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如 <strong>wait 或 join 等方法的指定超时</strong>版本，如下面示例：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;</code></pre></li><li><p>终止（<strong>TERMINATED</strong>），不管是<strong>意外退出还是正常执行结束，线程已经完成使命，终止运行</strong>。第二次调用 start() 方法的时候，线程可能处于终止或者其他（非 NEW）状态，但是不论如何，都<strong>不可以再次启动</strong>。</p></li></ul><h3 id="线程操作"><a href="#线程操作" class="headerlink" title="线程操作"></a>线程操作</h3><ul><li>start()：启动线程并执行相应的 run() 方法；</li><li>run()：子线程要执行的逻辑代码在 run() 中完成；</li><li>sleep()：让当前线程停止执行，把 CPU 让给其他线程执行，但<strong>不会释放对象锁和监控的状态</strong>，到了指定时间后线程又会自动恢复运行状态；<ul><li>注：线程睡眠到期自动苏醒，并返回到<strong>可运行状态</strong>，不是运行状态。sleep() 中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始执行；</li></ul></li><li>wait()：使一个线程处于等待（阻塞）状态，并且<strong>释放所持有的对象的锁</strong>；</li><li>join()：t.join() 方法只会使主线程（调用 t.join() 的线程）进入等待池并等待 t线程 执行完毕后才会被唤醒。不影响同一时刻处在运行状态的其他线程；<ul><li>使用场景示例：主线程创建并启动了线程，如果子线程中药进行大量耗时运算，主线程往往会早于子线程结束之前结束。如果主线程想等待子线程执行完成之后再结束，比如主线程要获取子线程处理的数据，就要用到 join() 方法；</li></ul></li><li>yield()：告诉调度器主动让出 CPU；<ul><li>注：让出 CPU 不代表当前线程不执行了。当前线程让出 CPU 后，还会进行 CPU 资源的争夺，但是不保证一定能够再次分配到；</li></ul></li><li>getPriority()：获取当前线程的优先级；<ul><li>注：两个等待的线程，优先级高的线程容易被 CPU 执行。优先级分为1~10等级，默认优先级是5；</li></ul></li><li>setPriority()：设置线程的优先级；</li><li>getId()：取得线程唯一标识；</li><li>isAlive()：判断当前线程是否处于活动状态，活动状态就是已经启动尚未终止；</li><li>currentThread()：返回代码段正在被哪个线程调用；</li><li>resume()、stop()、suspend() 方法被标记为过时，在 JDK 最新版本中，destory/stop 方法将被移除；</li><li>基类 Object 提供了一些基础的 wait() / notify() / notifyAll() 方法；<ul><li>如果持有某个对象的 Monitor 锁，调用 wait 会让当前线程处于等待状态，直到其他线程 notify 或者 notifyAll。所以，这些方法本质上是提供了 Monitor 的获取和释放的能力，是基本的线程间通信方式；</li></ul></li><li>并发类库中的工具，比如 CountDownLatch.await() 会让当前线程进入等待状态，直到 latch 被计数为 0，这可以看作是线程间通信的 Signal；</li></ul><h2 id="Java-中如何实现线程"><a href="#Java-中如何实现线程" class="headerlink" title="Java 中如何实现线程"></a>Java 中如何实现线程</h2><h3 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h3><ul><li><strong>创建一个任务类继承 Thread 类</strong>，Thread类实现了Runnable接口，所以自定义的任务类也实现了Runnable接口；<ul><li>扩展 java.lang.Thread 类来创建线程，java.lang.Thread 类主要有两个方法：<ul><li>start()：调用自定义对象的start()方法，可以启动线程；</li><li>run()：run()方法定义了具体的任务代码或处理逻辑，Thread 的子类应该重写run()方法；</li></ul></li><li>创建一个任务类对象，可以用 Thread 或者 Runnable 作为自定义的变量类型；</li><li>调用自定义对象的 start() 方法，启动一个线程；</li></ul></li><li><strong>定义一个任务类实现 Runnable 接口</strong>；<ul><li>实现 Runnable 接口中的 run() 方法；</li><li>定义了任务类后，为任务类创建一个任务对象；</li><li>任务必须在线程中执行，创建一个 Thread 类的对象，将前面创建的实现了 Runnable 接口的<strong>任务类对象作为参数传递给Thread类的构造方法</strong>；</li><li>调用Thread类对象的 start() 方法，启动一个线程。</li></ul></li></ul><h2 id="synchronized-与锁"><a href="#synchronized-与锁" class="headerlink" title="synchronized 与锁"></a>synchronized 与锁</h2><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>线程安全是一个多线程环境下<strong>正确性的概念</strong>，也就是保证多线程环境下<strong>共享的</strong>、<strong>可修改</strong>的<strong>状态</strong>的正确性，这里的状态反映在程序中其实可以看作是<strong>数据</strong>。换个角度来看，如果状态不是共享的，或者不是可修改的，也就不存在线程安全问题。线程安全需要保证几个基本特性：</p><ul><li>原子性：相关操作不会中途被其他线程干扰，一般通过<strong>同步机制</strong>实现；</li><li>可见性：一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为<strong>将线程本地状态反映到主内存上</strong>，<strong>volatile</strong> 可以负责保证可见性的；</li><li>有序性：保证线程内串行语义，<strong>避免指令重排</strong>等； </li></ul><h3 id="synchronized-与-ReentrantLock"><a href="#synchronized-与-ReentrantLock" class="headerlink" title="synchronized 与 ReentrantLock"></a>synchronized 与 ReentrantLock</h3><p>synchronized 是 Java 内建的同步机制，所以也称为 Intrinsic Locking，它提供了互斥的语义和可见性，<strong>当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在那里</strong>。</p><ul><li>Java 5 以前，synchronized 是仅有的同步手段，在代码中，synchronized 可以用来<strong>修饰方法</strong>，也可以使用在特定的<strong>代码块</strong>儿上，<strong>本质上 synchronized 方法等同于把方法全部语句用 synchronized 块包起</strong>；</li><li>synchronized 依赖于 <strong>JVM</strong>，ReentrantLock 依赖于 <strong>API</strong>，synchronized 是依赖于 JVM 实现的，没有直接暴露给用户；ReentrantLock 是 JDK 层面实现的（需要 lock() 和 unlock() 方法配合 try/finally 来完成），所以可以查看它的源代码；</li><li>ReentrantLock，是 Java 5 提供的锁实现，语义和 synchronized 基本相同。再入锁通过代码直接调用 lock() 方法获取，代码书写也更加灵活。ReentrantLock 提供了很多实用的方法，能够实现很多 synchronized 无法做到的<strong>细节控制</strong>，比如可以控制 fairness，也就是<strong>公平性</strong>，或者利用<strong>定义条件</strong>等。但是，编码中也需要注意，必须要<strong>明确调用 unlock() 方法释放</strong>，不然就会一直持有该锁；<ul><li>与 synchronized 相比，ReentrantLock 增加了一些高级功能，主要有三点：等待可中断；可实现公平锁；可实现选择性通知（锁可以绑定多个条件）；</li></ul></li><li>synchronized 和 ReentrantLock 的性能不能一概而论，早期版本 synchronized 在很多场景下性能相差较大，在后续版本进行了较多改进，在低竞争场景中表现可能优于 ReentrantLock；</li></ul><h3 id="syschronized-实现原理"><a href="#syschronized-实现原理" class="headerlink" title="syschronized 实现原理"></a>syschronized 实现原理</h3><p>synchronized 代码块由一对 monitorenter / monitorexit 指令实现，Monitor 对象是同步的基本实现单元。</p><ul><li>Java 6 之前，Monitor 的实现完全依靠<strong>操作系统内部的互斥锁</strong>，因为需要进行<strong>用户态到内核态的切换</strong>，所以同步操作是一个<strong>重量级操作</strong>；</li></ul><h3 id="锁的升级、降级"><a href="#锁的升级、降级" class="headerlink" title="锁的升级、降级"></a>锁的升级、降级</h3><ul><li>现代的（Oracle）JDK 中，JVM 对此进行了改进，提供了<strong>三种不同的 Monitor 实现</strong>，也就是常说的三种不同的锁：<strong>偏斜锁</strong>（Biased Locking）、<strong>轻量级锁</strong>和<strong>重量级锁</strong>，大大改进了其性能；</li><li>锁的升级、降级，指的是 <strong>JVM 优化 synchronized 运行的机制</strong>，当 JVM 检测到不同的竞争状况时，会<strong>自动切换到适合的锁实现</strong>，这种切换就是锁的升级、降级；</li><li>当<strong>没有竞争</strong>出现时，默认会使用偏斜锁。JVM 会利用 <strong>CAS 操作</strong>（compare and swap），在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，<strong>大部分对象生命周期中最多会被一个线程锁定</strong>，使用<strong>偏斜锁可以降低无竞争开销</strong>；</li><li>如果有<strong>另外的线程试图锁定某个已经被偏斜过的对象</strong>，JVM 就需要撤销（revoke）偏斜锁，并切换到<strong>轻量级锁实现</strong>。轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，<strong>如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁；</strong></li><li>有的观点认为 Java 不会进行锁降级。有的观点认为，锁降级是会发生的，当 <strong>JVM 进入安全点</strong>（SafePoint）的时候，会检查是否有闲置的 Monitor，然后试图进行降级。</li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个共享变量的值，而另外一个线程还继续使用它的本地内存中共享变量的副本，造成<strong>数据的不一致</strong>。</p><p>注：在多个线程之间能够被共享的变量被称为共享变量。共享变量包括所有的实例变量，静态变量和数组元素。他们都被存放在堆内存中，volatile 只作用于共享变量。</p><h3 id="volatile-定义"><a href="#volatile-定义" class="headerlink" title="volatile 定义"></a>volatile 定义</h3><p>java 编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java 语言提供了 volatile，在某些情况下比锁更加方便。如果一个字段被声明成 volatile，java 线程内存模型确保所有线程看到这个变量的值是一致的。</p><p>Volatile 是<strong>轻量级的 synchronized</strong>，它在多处理器开发中保证了共享变量的“<strong>可见性</strong>”。可见性指的是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h3><p>池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。线程池提供了一种限制和管理资源的技术。 每个线程池维护一些基本统计信息，例如已完成任务的数量。</p><ul><li><strong>降低资源消耗</strong>：通过重复利用已创建的线程降低线程创建和销毁造成的消耗；</li><li>*<em>提高响应速度 *</em>：当任务到达时，任务可以不需要的等待线程的创建就能立即执行；</li><li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控；</li></ul><h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p>通常开发者可以利用 Executors 提供的通用线程池创建方法，创建不同配置的线程池，主要区别在于不同的 ExecutorService 类型或者不同的初始参数。Executors 目前提供了 5 种不同的线程池创建配置：</p><ul><li>newCachedThreadPool()：<strong>用来处理大量短时间工作任务的线程池</strong>，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</li><li>newFixedThreadPool(int nThreads)：<strong>重用指定数目（nThreads）的线程，底层使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的</strong>。如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；</li><li>newSingleThreadExecutor()：<strong>工作线程数目被限制为 1</strong>，操作一个无界的工作队列，<strong>保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态</strong>，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；</li><li>newSingleThreadScheduledExecutor() 和 newScheduledThreadPool(int corePoolSize)：创建的是个 ScheduledExecutorService，可以进行<strong>定时或周期性的工作调度</strong>，区别在于单一工作线程还是多个工作线程；</li><li>newWorkStealingPool(int parallelism)：Java 8 加入这个创建方法，内部会构建ForkJoinPool，利用Work-Stealing算法，<strong>并行地处理任务，不保证处理顺序</strong>；</li></ul><p>注：</p><ul><li>newFixedThreadPool 和 newSingleThreadExecutor：允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致OOM。</li><li>newCachedThreadPool 和 newScheduledThreadPool：允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</li></ul><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><h4 id="线程池创建"><a href="#线程池创建" class="headerlink" title="线程池创建"></a>线程池创建</h4><p>可以通过 ThreadPoolExecutor 创建一个线程池。</p><pre><code class="hljs java"><span class="hljs-keyword">new</span>  ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, handler);</code></pre><ul><li>corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，<strong>即使其他空闲的基本线程能够执行新任务也会创建线程</strong>，等到<strong>需要执行的任务数大于线程池基本大小</strong>时就不再创建。如果调用了线程池的 prestartAllCoreThreads 方法，线程池会提前创建并启动所有基本线程；</li><li>runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列：<ul><li>ArrayBlockingQueue：基于数组结构的有界阻塞队列，按 FIFO 原则对元素排序；</li><li>LinkedBlockingQueue：基于链表结构的阻塞队列，按 FIFO 原则对元素排序，吞吐量通常高于 ArrayBlockingQueue。静态工厂方法 Executors.newFixedThreadPool() 使用了这个队列；</li><li>SynchronousQueue：不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 LinkedBlockingQueue，静态工厂方法 Executors.newCachedThreadPool 使用了这个队列；</li><li>PriorityBlockingQueue：具有优先级的无界阻塞队列；</li></ul></li><li>maximumPoolSize（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果；</li><li>ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字；</li><li>RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是 AbortPolicy，表示无法处理新任务时抛出异常。以下是 JDK1.5 提供的四种策略：<ul><li>AbortPolicy：直接抛出异常；</li><li>CallerRunsPolicy：只用调用者所在线程来运行任务；</li><li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务；</li><li>DiscardPolicy：不处理，丢弃掉；</li><li>也可以根据应用场景需要来实现 RejectedExecutionHandler 接口自定义策略。如记录日志或持久化不能处理的任务；</li></ul></li><li>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率；</li><li>TimeUnit（线程活动保持时间的单位）：可选的单位有天，小时，分钟，毫秒，微秒 (千分之一毫秒) 和毫微秒 (千分之一微秒)；</li></ul><h4 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h4><p>可以通过 execute() 和 submit() 方法向线程池提交任务。</p><ul><li><p>execute() 用于提交不需要返回值的任务，无法判断任务是否被线程池执行成功；</p><pre><code class="hljs java">threadsPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-comment">// TODO Auto-generated method stub</span>            &#125;        &#125;);</code></pre></li></ul><ul><li><p>submit() 方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get() 方法获取返回值，get() 方法会阻塞当前线程直到任务完成，而 get(long timeout，TimeUnit unit) 方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完；</p><pre><code class="hljs java">Future&lt;Object&gt; future = executor.submit(harReturnValuetask);<span class="hljs-keyword">try</span> &#123;     Object s = future.get();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;    <span class="hljs-comment">// 处理中断异常 </span>&#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;    <span class="hljs-comment">// 处理无法执行任务异常 </span>&#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-comment">// 关闭线程池 </span>    executor.shutdown();&#125;</code></pre></li></ul><h4 id="线程池关闭"><a href="#线程池关闭" class="headerlink" title="线程池关闭"></a>线程池关闭</h4><p>可以通过调用线程池的 shutdown 或 shutdownNow 方法来关闭线程池，它们的原理是遍历线程池中的工作线程，然后逐个调用线程的 interrupt 方法来中断线程，所以无法响应中断的任务可能永远无法终止。</p><ul><li>shutdownNow 首先将线程池的状态设置成 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表；</li><li>shutdown 只是将线程池的状态设置成 SHUTDOWN 状态，然后中断所有没有正在执行任务的线程；</li></ul><p>只要调用了这两个关闭方法的其中一个，isShutdown 方法就会返回 true。当所有的任务都已关闭后, 才表示线程池关闭成功，这时调用 isTerminaed 方法会返回 true。至于调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定。通常调用 shutdown 来关闭线程池，如果任务不一定要执行完，则可以调用 shutdownNow。</p><h4 id="线程池工作流程"><a href="#线程池工作流程" class="headerlink" title="线程池工作流程"></a>线程池工作流程</h4><p>线程池的主要工作流程如下图所示：</p><p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" alt=""></p><p>当提交一个新任务到线程池时，线程池的处理流程如下：</p><ol><li>首先线程池判断<strong>基本线程池</strong>是否已满？没满，创建一个工作线程来执行任务，否则：</li><li>其次线程池判断<strong>工作队列</strong>是否已满？没满，则将新提交的任务存储在工作队列里，否则：</li><li>最后线程池判断<strong>整个线程池</strong>是否已满？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务；</li></ol><p>源码分析部分以及下面的线程池配置部分可以参见方腾飞老师<a href="https://www.infoq.cn/article/java-threadPool" target="_blank" rel="noopener">JAVA 线程池的分析和使用</a>的博客，以及 <a href="https://snailclimb.gitee.io/javaguide/#/docs/java/Multithread/JavaConcurrencyAdvancedCommonInterviewQuestions?id=_41-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8%e7%ba%bf%e7%a8%8b%e6%b1%a0%ef%bc%9f" target="_blank" rel="noopener">JavaGuide的线程池总结</a>。</p><h4 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h4><p>合理的配置线程池，需要从以下几个角度分析任务特性：</p><ol><li>任务的性质：CPU 密集型任务，IO 密集型任务和混合型任务。</li><li>任务的优先级：高，中和低。</li><li>任务的执行时间：长，中和短。</li><li>任务的依赖性：是否依赖其他系统资源，如数据库连接。</li></ol><h2 id="Java-并发包"><a href="#Java-并发包" class="headerlink" title="Java 并发包"></a>Java 并发包</h2><p>Java 提供了不同层面的线程安全支持。在传统集合框架内部，除了 <strong>Vector、Stack、Hashtable</strong> 等同步容器，还提供了<strong>同步包装器</strong>（Synchronized Wrapper），可以调用 Collections 工具类提供的包装方法，获取一个同步的包装容器（如 Collections.synchronizedMap），但是它们都是利用<strong>粗粒度的同步方式</strong>，<strong>高并发下性能较低</strong>。</p><p>鉴于Java 集合框架的典型容器类绝大多数都不是线程安全的且性能较低，Java 提供了并发包，为高度并发需求提供了更加全面的工具支持。</p><ul><li>各种并发容器，如 ConcurrentHashMap、CopyOnWriteArrayList；</li><li>各种线程安全队列（Queue/Deque），如 ArrayBlockingQueue、SynchronousQueue；</li><li>各种有序容器的线程安全版本等；</li></ul><p>线程安全的实现方式有简单的 <strong>synchronize</strong> 方式，也有更加精细化的，比如<strong>基于分离锁实现的 ConcurrentHashMap</strong> 等并发实现等。具体选择要看开发的场景需求。</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><h2 id="CAS-与原子操作"><a href="#CAS-与原子操作" class="headerlink" title="CAS 与原子操作"></a>CAS 与原子操作</h2><h3 id="CAS定义"><a href="#CAS定义" class="headerlink" title="CAS定义"></a>CAS定义</h3><p><strong>比较并交换(compare and swap, CAS)</strong>，是原子操作的一种，可用于在多线程编程中<strong>实现不被打断的数据交换操作</strong>，从而<strong>避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题</strong>。 该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。</p><ul><li><strong>记录下</strong>某块内存中的旧值；</li><li>对旧值<strong>进行一系列的操作</strong>后得到新值；</li><li>通过CAS操作将新值与旧值进行交换：<ul><li>如果这块内存的值在这期间内没被修改过，则旧值会与内存中的数据相同，这时CAS操作将会成功执行，使内存中的数据变为新值；</li><li>如果内存中的值在这期间内被修改过，则一般来说旧值会与内存中的数据不同，这时CAS操作将会失败，新值将不会被写入内存。</li></ul></li></ul><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cas</span><span class="hljs-params">(<span class="hljs-keyword">long</span> *addr, <span class="hljs-keyword">long</span> old, <span class="hljs-keyword">long</span> <span class="hljs-keyword">new</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">/* Executes atomically. */</span>    <span class="hljs-keyword">if</span>(*addr != old)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    *addr = <span class="hljs-keyword">new</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h4 id="synchronized-和-volatile-的区别"><a href="#synchronized-和-volatile-的区别" class="headerlink" title="synchronized 和 volatile 的区别"></a>synchronized 和 volatile 的区别</h4><ul><li>synchronized 关键字解决的是<strong>多个线程之间访问资源的同步性</strong>；</li><li><strong>volatile 关键字</strong>是<strong>线程同步</strong>的<strong>轻量级</strong>实现，因为它不会引起线程上下文的切换和调度，所以比 synchronized 的<strong>使用和执行成本会更低</strong>，<strong>性能</strong>比 synchronized 好；</li><li>volatile 只能用于<strong>变量</strong>，synchronized 关键字可以修饰<strong>方法以及代码块</strong>；</li><li>多线程访问 volatile 关键字<strong>不会发生阻塞</strong>，synchronized 关键字<strong>可能会发生阻塞</strong>；</li><li>volatile 关键字能保证<strong>数据的可见性</strong>，但<strong>不能保证数据的原子性</strong>，synchronized 关键字两者都能保证。</li></ul><h4 id="sleep-和-wait-方法异同"><a href="#sleep-和-wait-方法异同" class="headerlink" title="sleep() 和 wait() 方法异同"></a>sleep() 和 wait() 方法异同</h4><ul><li>都可以暂停线程的执行；</li><li>最主要的区别在于：<strong>sleep() 方法没有释放锁，而 wait() 方法释放了锁</strong>； </li><li>wait() 通常被用于<strong>线程间交互/通信</strong>，sleep() 通常被用于<strong>暂停执行</strong>；</li><li>wait() 方法被调用后，线程<strong>不会自动苏醒</strong>，需要别的线程调用同一个对象上的 <strong>notify() 或者 notifyAll() 方法</strong>；sleep() 方法执行完成后，线程会<strong>自动苏醒</strong>。或者可以使用 <strong>wait(long timeout) 超时后线程会自动苏醒</strong>；</li></ul><h4 id="start-方法会执行-run-，为什么不直接调用-run-方法"><a href="#start-方法会执行-run-，为什么不直接调用-run-方法" class="headerlink" title="start() 方法会执行 run()，为什么不直接调用 run() 方法"></a>start() 方法会执行 run()，为什么不直接调用 run() 方法</h4><ul><li>new 一个 Thread，线程进入了新建状态；</li><li>调用 start() 方法，会启动一个线程并使线程进入了<strong>就绪状态</strong>，当分配到时间片后就可以开始运行；<ul><li>start() 会执行线程的相应<strong>准备工作</strong>，然后自动执行 run() 方法的内容，这是真正的多线程工作；</li></ul></li><li>直接执行 run() 方法，会将 run() 其当成 main 线程下的一个<strong>普通方法</strong>去执行，并不会在某个线程中执行它，所以这并<strong>不是多线程工作</strong>；</li></ul><p><strong>总结： 调用 start() 方法方可启动线程并使线程进入就绪状态，而 run() 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</strong></p><h4 id="AtomicInteger-底层实现原理"><a href="#AtomicInteger-底层实现原理" class="headerlink" title="AtomicInteger 底层实现原理"></a>AtomicInteger 底层实现原理</h4><p>AtomicIntger 是对 int 类型的一个封装，提供原子性的访问和更新操作，其原子性操作的实现是基于 CAS（compare-and-swap）技术。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>JDK1.8 源码</p><p>Java 并发编程实战</p><p><a href="https://betterzero.net/2020/07/22/Java%20%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/%3Chttps://time.geekbang.org/column/intro/100006701%3E/">极客时间 - Java精讲</a></p><p><a href="https://www.infoq.cn/profile/1277812/publish" target="_blank" rel="noopener">方腾飞InfoQ并发系列文章</a></p><p><a href="https://redspider.gitbook.io/concurrent/readme" target="_blank" rel="noopener">深入浅出Java多线程</a></p><p><a href="http://www.51gjie.com/java/717.html" target="_blank" rel="noopener">javaschool</a></p><p><a href="https://cloud.tencent.com/developer/article/1497826" target="_blank" rel="noopener">一次Java线程池误用引发的线上血案和总结</a> </p><p><a href="https://blog.csdn.net/u014209205/article/details/80598209" target="_blank" rel="noopener">JAVA Future类详解</a></p><p><a href="https://www.infoq.cn/article/ftf-java-volatile/" target="_blank" rel="noopener">聊聊并发（一）—深入分析 Volatile 的实现原理</a></p><p><a href="https://blog.csdn.net/a525390802/article/details/80509457" target="_blank" rel="noopener">JVM之内存模型JMM中本地内存的理解</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java OOP一些理解</title>
    <link href="/2020/07/22/Java%20OOP%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <url>/2020/07/22/Java%20OOP%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>文章介绍面向对象编程的基础概念，主要关于其特性、优势，以及 OOP 的使用方法与误区。</p><a id="more"></a><h1 id="面向过程编程及面向过程编程语言"><a href="#面向过程编程及面向过程编程语言" class="headerlink" title="面向过程编程及面向过程编程语言"></a>面向过程编程及面向过程编程语言</h1><p>面向过程编程<strong>以过程（或方法）作为组织代码的基本单元</strong>。它最主要的特点就是<strong>数据和方法相分离</strong>。面向过程编程语言最大的特点就是不支持丰富的<strong>面向对象编程特性</strong>，比如继承、多态、封装。</p><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>面向对象编程<strong>以类为组织代码的基本单元</strong>，一般来说，它具有以下优势。</p><ul><li>对于<strong>大规模复杂的程序的开发</strong>，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程更能应对这种复杂类型的程序开发；</li><li>面向对象编程具有更加<strong>丰富的特性</strong>，如封装、抽象、继承、多态。代码易扩展、易复用、易维护；</li></ul><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="访问权限控制"><a href="#访问权限控制" class="headerlink" title="访问权限控制"></a>访问权限控制</h3><p>封装主要关于<strong>信息隐藏、数据保护</strong>。编程语言需要提供<strong>访问权限控制</strong>这样的语法机制来支持。Java 使用访问控制符来保护对<strong>类、变量、方法和构造方法</strong>的访问。Java 支持 4 种不同的访问权限：</p><ul><li><strong>private</strong> : 访问权限限制的最窄的修饰符。同一类内可见。使用对象：变量、方法。 <strong>不能修饰类（外部类）</strong></li><li><strong>default</strong> (默认）: 通常称为“默认访问权限“或者“包访问权限”，不使用任何修饰符。同一包内可见。使用对象：类、接口、变量、方法。</li><li><strong>protected</strong> : 介于public 和 private 之间的一种访问修饰符。同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>不能修饰类（外部类）</strong>。</li><li><strong>public</strong> : 访问限制最宽的修饰符。允许跨包访问，所有类可见。使用对象：类、接口、变量、方法</li></ul><h3 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h3><p>如果对类中属性的访问不做限制，任何代码都可以访问、修改类中的属性，虽然看起来更加灵活，但是<strong>过度灵活也意味着不可控</strong>。属性可以随意被修改，修改逻辑可能散落在代码中的各个角落，影响代码的<strong>可读性、可维护性</strong>。</p><p>通过有限的方法，暴露必要的操作，能<strong>提高类的易用性</strong>。如果把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就要对业务细节有足够的了解。这对于调用者来说也是一种负担。如果将属性<strong>封装</strong>起来，只暴露必要的<strong>方法</strong>给调用者使用，调用者就不需要了解太多的业务细节，可以降低使用成本，减少用错的概率。</p><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p><strong>抽象关注的是如何隐藏方法的具体实现</strong>，让调用者只需要关心方法提供了哪些功能，不需要知道实现细节。</p><p>面向对象编程常常借助编程语言提供的<strong>接口</strong>或者<strong>抽象类</strong>这两种语法机制实现抽象这一特性。</p><p><strong>抽象有时候会被排除在面向对象特性之外</strong>。因为抽象是一个非常通用的设计思想，不单单用在面向对象编程中，也可以用来指导架构设计等。这个特性也并不需要编程语言提供特殊的语法机制来支持，只需要提供“函数”这一语法机制，就可以实现抽象特性。</p><h3 id="抽象的意义"><a href="#抽象的意义" class="headerlink" title="抽象的意义"></a>抽象的意义</h3><p>面对复杂的系统，人脑能承受的信息是有限的，所以要忽略一些非关键的实现细节。抽象作为一种<strong>只关注功能点不关注实现</strong>的设计思路，可以过滤掉非必要的信息。</p><p>抽象作为一个非常宽泛的<strong>设计思想</strong>，在代码设计中起到重要的指导作用。很多设计原则都体现了抽象这种设计思想，比如<strong>基于接口而非实现编程</strong>、<strong>开闭原则</strong>（对扩展开放、对修改关闭）、<strong>代码解耦</strong>（降低代码的耦合性）等。</p><p>换一个角度考虑，定义类的方法的时候，不要暴露太多的实现细节，以保证在修改方法的实现的时候，不用再修改其定义。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承用来表示<strong>类之间的 is-a 关系</strong>，比如猫是一种哺乳动物。继承可以分为两种模式，<strong>单继承和多继承</strong>。</p><p>Java 使用 <strong>extends</strong> 关键字来实现继承，C++ 使用冒号（class B : public A），Python 使用 paraentheses()。有些编程语言只支持单继承，不支持多重继承，比如 Java。有些编程语言两种方式都支持，比如 C++、Python。</p><h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><p>多重继承存在钻石问题，即菱形继承。假设类 B 和类 C 继承自类 A，都重写了类 A 中的同一个方法，而类 D 同时继承了类 B 和类 C，那么此时类 D 会继承 B、C 的方法，那对于 B、C 重写的 A 中的方法，类 D 继承哪一个就无法确定。</p><p>Java支持多接口实现，因为接口中的方法是抽象的，即便一个类实现了多个接口，且这些接口中存在同名方法，但在实现接口的时候，这个同名方法需要由这个实现类自己来实现，所以避免了二义性的问题。</p><h3 id="继承的意义"><a href="#继承的意义" class="headerlink" title="继承的意义"></a>继承的意义</h3><p>继承最大的优点是<strong>代码复用</strong>。假如两个类有一些相同的属性和方法，就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。两个子类可以重用父类中的代码。不过，通过其他方式，比如利用<strong>组合关系</strong>而不是<strong>继承关系</strong>，也可以达到代码复用的目的。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是同一个行为具有多个不同表现形式或形态的能力，同一个接口，使用不同的实例而执行不同操作。<strong>子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现</strong>。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="继承-方法重写"><a href="#继承-方法重写" class="headerlink" title="继承 + 方法重写"></a>继承 + 方法重写</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicArray</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> capacity = DEFAULT_CAPACITY;  <span class="hljs-keyword">protected</span> Integer[] elements = <span class="hljs-keyword">new</span> Integer[DEFAULT_CAPACITY];    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.size; &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123; <span class="hljs-keyword">return</span> elements[index];&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Integer e)</span> </span>&#123;    ensureCapacity();    elements[size++] = e;  &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacity</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 如果数组满了就扩容...</span>  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortedDynamicArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DynamicArray</span> </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Integer e)</span> </span>&#123;    ensureCapacity();    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">for</span> (i = size-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; --i) &#123; <span class="hljs-comment">//保证数组中的数据有序</span>      <span class="hljs-keyword">if</span> (elements[i] &gt; e) &#123;        elements[i+<span class="hljs-number">1</span>] = elements[i];      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">break</span>;      &#125;    &#125;    elements[i+<span class="hljs-number">1</span>] = e;    ++size;  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(DynamicArray dynamicArray)</span> </span>&#123;    dynamicArray.add(<span class="hljs-number">5</span>);    dynamicArray.add(<span class="hljs-number">1</span>);    dynamicArray.add(<span class="hljs-number">3</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dynamicArray.size(); ++i) &#123;      System.out.println(dynamicArray.get(i));    &#125;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;    DynamicArray dynamicArray = <span class="hljs-keyword">new</span> SortedDynamicArray();    test(dynamicArray); <span class="hljs-comment">// 打印结果：1、3、5</span>  &#125;&#125;</code></pre><p>多态需要<strong>编程语言提供特殊的语法机制</strong>来实现。在上面的例子中，用到了三个语法机制来实现多态。</p><ul><li><strong>父类对象可以引用子类对象</strong>。可以将 SortedDynamicArray 传递给 DynamicArray。</li><li><strong>继承</strong>。SortedDynamicArray 继承了 DynamicArray，才能将 SortedDyamicArray 传递给 DynamicArray；</li><li><strong>子类可以重写（override）父类中的方法</strong>。SortedDyamicArray 重写了 DynamicArray 中的 add() 方法。</li></ul><p>这三种语法机制配合在一起，实现了在 test() 方法中，子类 SortedDyamicArray 替换父类 DynamicArray，执行子类 SortedDyamicArray 的 add() 方法，实现了多态特性。</p><p>对于多态的实现方式，除了利用<strong>继承加方法重写</strong>这种方式外，还有其他两种比较常见的的实现方式，一个是利用<strong>接口类语法</strong>，另一个是利用 <strong>duck-typing 语法</strong>。不过，并不是每种编程语言都支持接口类或者 duck-typing 这两种语法机制，比如 C++ 不支持接口类语法，而 duck-typing 只有一些动态语言才支持，比如 Python、JavaScript 等。</p><h4 id="接口类语法"><a href="#接口类语法" class="headerlink" title="接口类语法"></a>接口类语法</h4><p>Iterator 是一个接口类，定义了一个可以遍历集合数据的迭代器。Array 和 LinkedList 都实现了接口类 Iterator。通过<strong>传递不同类型的实现类（Array、LinkedList）到 print(Iterator iterator) 函数中，支持动态的调用不同的 next()、hasNext() 实现</strong>。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span> </span>&#123;  <span class="hljs-function">String <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;  <span class="hljs-function">String <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;  <span class="hljs-function">String <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Array</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span> </span>&#123;  <span class="hljs-keyword">private</span> String[] data;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-comment">// 省略其它方法...</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span> </span>&#123;  <span class="hljs-keyword">private</span> LinkedListNode head;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123; ... &#125;  <span class="hljs-comment">// 省略其它方法... </span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Iterator iterator)</span> </span>&#123;    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;      System.out.println(iterator.next());    &#125;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Iterator arrayIterator = <span class="hljs-keyword">new</span> Array();    print(arrayIterator);        Iterator linkedListIterator = <span class="hljs-keyword">new</span> LinkedList();    print(linkedListIterator);  &#125;&#125;</code></pre><p>Java 通过<strong>继承实现多态特性</strong>，必须要求两个<strong>类之间有继承关系</strong>。通过<strong>接口实现多态特性</strong>，<strong>类必须实现对应的接口</strong>。</p><h3 id="多态的意义"><a href="#多态的意义" class="headerlink" title="多态的意义"></a>多态的意义</h3><p>多态特性能<strong>提高代码的可扩展性和复用性</strong>。利用多态，一个 print() 函数可以实现遍历打印不同类型集合的数据。当需要再增加一种要遍历打印的类型的时候，比如 HashMap，只需让 HashMap 实现 Iterator 接口，重新实现自己的 hasNext()、next() 等方法就可以了，不需要改动 print() 函数的代码，提高了代码的可扩展性。</p><p>多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等。</p><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="违反OOP风格的代码设计"><a href="#违反OOP风格的代码设计" class="headerlink" title="违反OOP风格的代码设计"></a>违反OOP风格的代码设计</h2><h3 id="滥用-getter、setter-方法"><a href="#滥用-getter、setter-方法" class="headerlink" title="滥用 getter、setter 方法"></a>滥用 getter、setter 方法</h3><ul><li>设计实现类的时候，除非真的需要，否则尽量不要给属性定义 setter 方法；</li><li>尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器，也要防范集合内部数据被修改的风险。</li></ul><h3 id="Constants-类、Utils-类的设计问题"><a href="#Constants-类、Utils-类的设计问题" class="headerlink" title="Constants 类、Utils 类的设计问题"></a>Constants 类、Utils 类的设计问题</h3><ul><li>对于这两种类的设计，尽量能做到职责单一，定义一些细化的小类，比如 RedisConstants、FileUtils，而不是定义一个大而全的 Constants 类、Utils 类；</li><li>如果能将这些类中的属性和方法，划分归并到其他业务类中，能极大地提高类的内聚性和代码的可复用性。</li></ul><h2 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h2><p>面向对象编程中，抽象类和接口是两个经常使用的语法概念，是面向对象四大特性以及很多设计模式、设计思想、设计原则编程实现的基础，例如：</p><ul><li>使用<strong>接口来实现面向对象的抽象特性、多态特性</strong>和<strong>基于接口而非实现</strong>的设计原则；</li><li>使用<strong>抽象类来实现面向对象的继承特性和模板设计模式</strong>等。</li></ul><p>继承关系是 is-a 的关系，接口表示 has-a 关系，表示<strong>具有某些功能</strong>。接口，有一个更形象的叫法：<strong>协议</strong>。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul><li>抽象类<strong>不允许被实例化</strong>，只能被<strong>继承</strong>；</li><li>抽象类可以包含属性和方法。抽象类中的成员变量可以是各种类型的，接口中的成员变量只能是 <strong>public static final</strong> 类型的；<ul><li>抽象类中的方法可以有方法体；</li><li>也可以不包含方法体。不包含代码实现的方法叫作<strong>抽象方法</strong>；</li></ul></li><li>子类继承抽象类，<strong>必须实现抽象类中的所有抽象方法</strong>。</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li><p>接口是隐式抽象的，声明接口时不必使用<strong>abstract</strong>关键字；</p></li><li><p>接口没有构造方法，接口不能实例化；</p></li><li><p>接口支持多继承；</p></li><li><p>接口中<strong>没有成员变量</strong>，<strong>只有方法声明，没有方法实现</strong>，实现接口的类<strong>必须实现接口中的所有方法</strong>；</p><ul><li>接口不包含任何<strong>非常量成员</strong>，任何 field 都是隐含着 public static final 的意义；</li></ul></li><li><p>接口没有<strong>非静态方法实现</strong>，要么是隐式的抽象方法（声明时不需要<strong>abstract</strong>关键字），要么是静态方法；</p><ul><li>JDK 1.8版本及以上，接口里可以有静态方法和方法体了，只有静态方法可以在接口中实现</li></ul></li></ul><h3 id="抽象类-OR-接口"><a href="#抽象类-OR-接口" class="headerlink" title="抽象类 OR 接口"></a>抽象类 OR 接口</h3><ul><li><strong>抽象类是一种自下而上的设计思路</strong>，先有子类的代码重复，然后抽象成上层的父类（抽象类）；</li><li>如果表示 <strong>is-a</strong> 的关系，为了解决<strong>代码复用</strong>的问题，使用<strong>抽象类</strong>；</li><li>接口是一种<strong>自上而下的设计思路</strong>，一般是先设计接口，再考虑具体的实现；</li><li>如果表示 <strong>has-a</strong> 关系，为了解决<strong>抽象</strong>而非代码复用的问题，使用<strong>接口</strong>；</li></ul><h2 id="基于接口而非实现编程"><a href="#基于接口而非实现编程" class="headerlink" title="基于接口而非实现编程"></a>基于接口而非实现编程</h2><p>“基于接口而非实现编程”，也可以表达为“<strong>基于抽象而非实现编程</strong>”。软件开发时一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。</p><p>本质上看，<strong>“接口”是一组“协议”或者“约定”，是功能提供者给使用者的一个“功能列表”</strong>。“接口”在不同的应用场景下会有不同的解读，比如服务端与客户端之间的“接口”，类库提供的“接口”，甚至是一组通信的协议都可以叫作“接口”。落实到具体的编码，“基于接口而非实现编程”原则中的“接口”，可以理解为编程语言中的<strong>接口或者抽象类</strong>。</p><p>这条原则能有效地提高代码质量。可以<strong>将接口和实现相分离，封装不稳定的实现，暴露稳定的接口</strong>。上游系统面向接口而非实现编程，<strong>不依赖不稳定的实现细节</strong>，当实现发生变化时，上游系统的代码基本上不需要改动，以此<strong>降低耦合性，提高扩展性</strong>。</p><h3 id="应用原则"><a href="#应用原则" class="headerlink" title="应用原则"></a>应用原则</h3><p>编写代码时遵从基于接口而非实现编程的原则：</p><ul><li><strong>函数的命名不能暴露任何实现细节</strong>；</li><li><strong>封装具体的实现细节</strong>；</li><li><strong>为实现类定义抽象的接口</strong>。具体的实现类依赖统一的接口定义，使用者依赖接口而非具体的实现类来编程。</li></ul><p>越不稳定的系统，越要在代码的扩展性、维护性上下功夫。不过，如果业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，没有必要为其设计接口，也没有必要基于接口编程，那么直接使用实现类就可以了。</p><h2 id="组合优于继承"><a href="#组合优于继承" class="headerlink" title="组合优于继承"></a>组合优于继承</h2><h3 id="继承的缺点"><a href="#继承的缺点" class="headerlink" title="继承的缺点"></a>继承的缺点</h3><p>继承层次越来越深，会使得继承关系会越来越复杂，引发以下问题：</p><ul><li>代码的可读性变差。因为要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码，一直追溯到最顶层父类的代码；</li><li>破坏了类的封装特性，降低可维护性。父类的实现细节暴露给子类，子类的实现依赖父类的实现，两者高度耦合。父类代码的修改会影响所有子类的逻辑。</li></ul><h3 id="组合的优势"><a href="#组合的优势" class="headerlink" title="组合的优势"></a>组合的优势</h3><p>可以利用组合（composition）、接口、委托（delegation）三个技术，解决继承存在的问题。</p><p>注：<strong>组合</strong>，java代码复用的一种方法。<strong>使用多个已有的对象组合为一个功能更加复杂强大的新对象</strong>。体现的是<strong>整体与部分、拥有的关系</strong>。因为在对象之间，各自的内部细节是不可见的，所以也说这种方式的代码复用是黑盒的。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyable</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span>；</span><span class="hljs-function">&#125;</span><span class="hljs-function"><span class="hljs-keyword">public</span> class FlyAbility implements Flyable </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//... &#125;</span>&#125;<span class="hljs-comment">//省略Tweetable/TweetAbility/EggLayable/EggLayAbility</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ostrich</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Tweetable</span>, <span class="hljs-title">EggLayable</span> </span>&#123;<span class="hljs-comment">//鸵鸟</span>  <span class="hljs-keyword">private</span> TweetAbility tweetAbility = <span class="hljs-keyword">new</span> TweetAbility(); <span class="hljs-comment">//组合</span>  <span class="hljs-keyword">private</span> EggLayAbility eggLayAbility = <span class="hljs-keyword">new</span> EggLayAbility(); <span class="hljs-comment">//组合</span>  <span class="hljs-comment">//... 省略其他属性和方法...</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tweet</span><span class="hljs-params">()</span> </span>&#123;    tweetAbility.tweet(); <span class="hljs-comment">// 委托</span>  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">layEgg</span><span class="hljs-params">()</span> </span>&#123;    eggLayAbility.layEgg(); <span class="hljs-comment">// 委托</span>  &#125;&#125;</code></pre><p>继承主要有三个作用：<strong>表示 is-a 关系，支持多态特性，代码复用</strong>。这三个作用都可以通过其他技术来达成。</p><ul><li>is-a 关系可以通过<strong>组合</strong>和<strong>接口的 has-a</strong> 关系来替代；</li><li>多态特性可以利用接口来实现；</li><li>代码复用可以通过组合和委托来实现。</li></ul><p>理论上讲，通过组合、接口、委托三种技术，可以替代继承。在项目中可以不用或者少用继承关系，特别是一些复杂的继承关系。</p><h3 id="组合-OR-继承"><a href="#组合-OR-继承" class="headerlink" title="组合 OR 继承"></a>组合 OR 继承</h3><p>继承改写成组合意味着要做更细粒度的类的拆分，定义更多的类和接口。类和接口的增多会增加代码的复杂程度和维护成本。实际的项目开发要根据具体的情况，具体地选择该用继承还是组合。</p><p>如果类之间的继承结构稳定，继承层次比较浅，继承关系不复杂，可以使用继承。反之，就尽量使用组合。</p><p>一些设计模式会固定使用继承或者组合。装饰者模式、策略模式、组合模式等都使用了组合关系，而模板模式使用了继承关系。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OOP</tag>
      
      <tag>Encapsulation</tag>
      
      <tag>Inheritance</tag>
      
      <tag>Polymorphism</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划专题</title>
    <link href="/2020/07/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/"/>
    <url>/2020/07/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法专题</title>
    <link href="/2020/07/22/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/"/>
    <url>/2020/07/22/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>字符串专题</title>
    <link href="/2020/07/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%93%E9%A2%98/"/>
    <url>/2020/07/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>哈希表专题</title>
    <link href="/2020/07/22/%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%93%E9%A2%98/"/>
    <url>/2020/07/22/%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>栈和队列专题</title>
    <link href="/2020/07/22/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%98/"/>
    <url>/2020/07/22/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树专题</title>
    <link href="/2020/07/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%98/"/>
    <url>/2020/07/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>链表专题</title>
    <link href="/2020/07/22/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/"/>
    <url>/2020/07/22/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python Tips</title>
    <link href="/2020/07/21/Python-Tips/"/>
    <url>/2020/07/21/Python-Tips/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
